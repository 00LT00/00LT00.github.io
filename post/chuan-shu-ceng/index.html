<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>传输层 | Zer0kiriN</title>

<link rel="shortcut icon" href="http://blog.zerokirin.online/favicon.ico?v=1625011598726">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="http://blog.zerokirin.online/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


<script async src="https://www.googletagmanager.com/gtag/js?id=G-3HHG9VQ3K2"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-3HHG9VQ3K2');
</script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Zer0kiriN
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="http://blog.zerokirin.online/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="http://blog.zerokirin.online/post/every-day" class="menu gt-a-link">
                    Every Day
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1625011598726"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    传输层
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-04-09 ·
                    </time>
                    
                        <a href="http://blog.zerokirin.online/tag/t3AfmBRjr/" class="post-tags">
                            # 传输层
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/4qrh5mF4T5/" class="post-tags">
                            # 计算机网络
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/-Ep2xEDPKR/" class="post-tags">
                            # 笔记
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>提供逻辑上<strong>进程间</strong>通信的功能，使应用看起来像是再两个传输层实体之间有一条端到端的逻辑通信信道</p>
<h2 id="主要协议-udp和tcp">主要协议 UDP和TCP</h2>
<ul>
<li>
<p>用户数据报协议 UDP（User Datagram Protocol）</p>
<p>是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
<p>常用于游戏，音视频流媒体等，对数据完整性要求不是很高，但是对实时性有比较高要求的传输</p>
</li>
<li>
<p>传输控制协议 TCP（Transmission Control Protocol）</p>
<p>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p>
<p>由于有拥塞控制，流量控制，及时性必然不如UDP，但可靠</p>
</li>
</ul>
<h2 id="udpuser-datagram-protocol-用户数据报协议">UDP(User Datagram Protocol) 用户数据报协议</h2>
<figure data-type="image" tabindex="1"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="img" loading="lazy"></figure>
<ul>
<li>
<p>伪首部</p>
<p>从IP首部提取出源IP地址和目的IP地址，然后是0x00，然后是IP首部中协议字段的值，UDP是17，然后是UDP的长度，总共12字节。</p>
<p>伪首部仅用作校验和，仅在发送和接收的时候被临时拼出来，计算出校验和后就抛弃，将校验和填入首部</p>
</li>
<li>
<p>源端口（可选）</p>
<p>UDP是无序应答的，因此没有必要记住源端口</p>
</li>
<li>
<p>目的端口</p>
</li>
<li>
<p>长度</p>
<p>就是UDP长度，和伪首部中的一样，最小值是8字节，因为首部已经占了8字节了</p>
<p>由于IP数据包的最大值不能超过64K字节（只有两个字节用来标识长度，2^16= 64K），所以最大长度不能超过（65,535 − 8字节UDP报头 − 20字节）</p>
</li>
<li>
<p>校验和（可选）</p>
<p>若不需要则全部填充0</p>
</li>
<li>
<p>整体结构，图源维基百科</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://files.catbox.moe/glwzey.png" alt="整体结构" loading="lazy"></figure>
<h2 id="tcptransmission-control-protocol传输控制协议">TCP（Transmission Control Protocol）传输控制协议</h2>
<h3 id="tcp结构">TCP结构</h3>
<figure data-type="image" tabindex="3"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img" loading="lazy"></figure>
<ul>
<li>
<p>序号（sequence number）：为每一个字节都编上序号。这里的值代表本报文发送的数据的第一个字节的序号。例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li>
<p>确认号（acknowledgement number）：期望收到的下一个报文段的起始序号，也即已经收到的数据的字节长度加1。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
</li>
<li>
<p>数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
</li>
<li>
<p>保留字段：6bits，保留今后使用，目前置0处理。（但在RFC 3168和RFC 3540中增加了三个标识符，保留字段只剩3bits）</p>
</li>
<li>
<p>标识符</p>
<p>URG：紧急比特，1bit，当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)<br>
ACK：确认比特，1bit，只有当 ACK=1时确认号字段才有效。当 ACK=0 时，确认号无效<br>
PSH：推送比特，1bit，接收方 TCP 收到推送比特置1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付<br>
RST：复位比特，1bit，当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接<br>
SYN：同步比特，1bit，同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文<br>
FIN：终止比特，1bit，用来释放一个连接。当FIN=1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</p>
</li>
<li>
<p>窗口（WIN）：窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</p>
</li>
<li>
<p>校验和（checksum）：生成12字节的伪首部然后计算出来</p>
</li>
<li>
<p>紧急指针：紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。</p>
</li>
<li>
<p>选项字段：最多40字节。每个选项的开始是1字节的kind字段，说明选项的类型。</p>
<ul>
<li>0：选项表结束（1字节）</li>
<li>1：无操作（1字节）用于选项字段之间的字边界对齐。</li>
<li>2：最大报文段长度（4字节，Maximum Segment Size，MSS）通常在创建连接而设置SYN标志的数据包中指明这个选项，指明本端所能接收的最大长度的报文段。通常将MSS设置为（MTU-40）字节，携带TCP报文段的IP数据报的长度就不会超过MTU（MTU最大长度为1518字节，最短为64字节），从而避免本机发生IP分片。只能出现在同步报文段中，否则将被忽略。</li>
<li>3：窗口扩大因子（3字节，wscale），取值0-14。用来把TCP的窗口的值左移的位数，使窗口值乘倍。只能出现在同步报文段中，否则将被忽略。这是因为现在的TCP接收数据缓冲区（接收窗口）的长度通常大于65535字节。</li>
<li>4：sackOK—发送端支持并同意使用SACK选项。</li>
<li>5：SACK实际工作的选项。</li>
<li>8：时间戳（10字节，TCP Timestamps Option，TSopt）
<ul>
<li>发送端的时间戳（Timestamp Value field，TSval，4字节）</li>
<li>时间戳回显应答（Timestamp Echo Reply field，TSecr，4字节）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="tcp连接过程">TCP连接过程</h3>
<h4 id="三次握手">三次握手</h4>
<figure data-type="image" tabindex="4"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" loading="lazy"></figure>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个随机的初始序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个随机的初始序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<h4 id="为什么是三次挥手">为什么是三次挥手</h4>
<p>通俗但不是根本原因的解释：</p>
<blockquote>
<p>A--&gt;B--&gt;A--&gt;B这样传三次能保证A有发有收，B也有发有收。多一次浪费少一次不够。</p>
</blockquote>
<p>详细版本，来源于知乎问题下的回答<a href="https://www.zhihu.com/question/24853633">TCP 为什么是三次握手，而不是两次或四次？ - 知乎 (zhihu.com)</a>）：</p>
<blockquote>
<p>TCP可靠传输的精髓在于，由操作系统随机的选取两个32位长的初始序列号（Initial Sequence Number）</p>
<p>假设A的初始序列号为1000，以该序列号为原点对将要发送的每个字节编号，然后把自己的初始序列号（ISN）发送个B，<strong>让B有个心理准备</strong>，什么编号的数据才是合法的，<strong>可靠的</strong>，同时B还要对A的数据进行确认，如果A收到的确认号为2001，则证明字节编号1001-2000，一共1000个字节的数据已经被<strong>完整接受</strong></p>
<p>（三次握手的过程中，初始x为1000，B的确认码是x+1=1001，所以真正发送的数据的第一个编号是1001，等B收到数据后返回给A的确认码是2001，代表着期望收到2001数据，也就是说，2000以前的数据已经完整收到了）</p>
</blockquote>
<p>所以原因是为了让双方创建好初始号ISN，完整的流程应该是四步：</p>
<ol>
<li>
<p>A 发送同步信号<strong>SYN</strong> + <strong>A's Initial sequence number</strong></p>
<blockquote>
<p>A --&gt; B SYN my sequence number is X</p>
<p>第一次握手SYN为1，表示请你记录下我的ISN</p>
</blockquote>
</li>
<li>
<p>B 确认收到A的同步信号，并记录 A's ISN 到本地，命名 <strong>B's ACK sequence number</strong></p>
</li>
</ol>
<blockquote>
<p>A &lt;-- B ACK your sequence number is X</p>
<p>第二次握手ACK为1，表示收到了</p>
</blockquote>
<ol start="3">
<li>B发送同步信号<strong>SYN</strong> + <strong>B's Initial sequence number</strong></li>
</ol>
<blockquote>
<p>A &lt;-- B SYN my sequence number is Y</p>
<p>第三次握手SYN为1，表示也请你记录下我的ISN</p>
</blockquote>
<ol start="4">
<li>A确认收到B的同步信号，并记录 B's ISN 到本地，命名 <strong>A's ACK sequence number</strong></li>
</ol>
<blockquote>
<p>A --&gt; B ACK your sequence number is Y</p>
<p>第四次握手ACK为1，表示我也受到了你的ISN了，我要开始传数据了哦</p>
</blockquote>
<p>很显然2和3这两个步骤可以合并，**只需要三次握手，**可以提高连接的速度与效率</p>
<p>最最根本的原因就是，三次通信过程是能够确保可靠传输的理论最小值，所以三次握手不是TCP的要求，而是为了满足在IP这种不可靠通信上建立可靠通信</p>
<h4 id="三次握手中丢包了">三次握手中丢包了</h4>
<ol>
<li>
<p>第一个包，A--&gt;B的带有SYN的包没了</p>
<p>A会周期性超时重传，直到B的确认，毕竟是追女孩子，要勤快一点</p>
</li>
<li>
<p>第二个，B--&gt;A的带有ACK+SYN的包没了</p>
<p>B会周期性重传，直到A的确认，女孩子同意了，怎么男的不回消息了？？？不是你先撩我的？？？我再问问</p>
</li>
<li>
<p>第三个包，A--&gt;B带有ACK的包没了</p>
<p>A知道B同意了就变为了Established，但B很好奇A怎么什么反应都没有</p>
<ol>
<li>如果A倒头就睡了打算明天传数据，B就会一直重传问A到底啥情况（对于B来说和 2 情况一样）</li>
<li>如果A直接给B发送了数据，B会自动更改为Established状态并接受状态，原来大猪蹄子只是睡着了没发晚安，不是渣男</li>
<li>如果B要给A发数据是发不了的，毕竟我同意了你竟然一点反应都没有，老娘一肚子火怎么可能跟你说正事，还是会一直重传ACK+SYN，你给老娘个答复！</li>
</ol>
<p>到这一步A--&gt;B的ACK必须被B接受才行，这代表双方都承认了关系的建立</p>
</li>
</ol>
<h4 id="现实情况">现实情况</h4>
<p>客户端发送的请求如果在网络中滞留，那么客户端要很长一段时间才能收到服务端的反馈，客户端等待时间过长后会超时重传，但是这个请求最后还是会到达服务器，如果没有保存两个ISN，那么就无法确认数据包是传输中还是建立连接的包，那么就会打开两个连接。如果有三次握手，双方保存了ISN，则发现错误后直接抛弃就好。</p>
<h4 id="四次挥手">四次挥手</h4>
<figure data-type="image" tabindex="5"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img" loading="lazy"></figure>
<p>ack，seq自始至终的含义是相同的，无需解释，ACK咋建立连接后全都是1，无需分析</p>
<ul>
<li>
<p>A发送释放连接的报文，FIN=1</p>
</li>
<li>
<p>B收到后还可以继续向A发送数据，但A不能向B发送数据</p>
</li>
<li>
<p>当B决定终止时向A发送释放连接报文，FIN=1</p>
</li>
<li>
<p>A收到后发出确认，进入TIME-WAIT状态，等待2个MSL（Maximum Segment Lifetime）时长后释放连接</p>
</li>
<li>
<p>B收到A的确认后释放连接</p>
</li>
</ul>
<h4 id="time-wait">Time-Wait</h4>
<p>A收到B的FIN报文后不是直接close而是先进入TIME-WAIT状态，等待两个MSL的时间，原因有两个：</p>
<ul>
<li>如果最后一个A--&gt;B的包丢了，那么对于A来说，A时刻+1MSL时还没到达B，B就应该重传了，B重传的时长最多是1MSL，因此A最多等待2MSL就能收到B的重传报文，如果没收到那就证明B已经ok了</li>
<li>让本链接持续时间内所产生的所有报文都从网络消失掉，使下一个新的连接创建的时候不会出现旧的报文</li>
</ul>
<h3 id="tcp可靠传输">TCP可靠传输</h3>
<p>TCP使用重传来实现可靠传输：如果一个已经发送的报文在超时时间内没有收到确认报文，则重传报文</p>
<p>一个报文的往返时间为RTT（Round Trip Time） <code>RTTs=(1-a)*(RTTs)+a*RTT</code> （并未被广泛使用，后来发明了新的算法）a一般为0.8-0.9</p>
<p>超时重传的超时时间为RTO（Restransmission TimeOut）<code>RTO=RTTs+4*RTTd</code></p>
<ul>
<li>
<p>RTO不能小于RTT否则会大量的重传</p>
</li>
<li>
<p>RTO不能太大，否则延迟会变得很大</p>
</li>
<li>
<p>因此RTO应该略大于RTT</p>
</li>
</ul>
<blockquote>
<h5 id="jacobson-karels-算法">Jacobson / Karels 算法</h5>
<p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看<a href="http://tools.ietf.org/html/rfc6298">RFC6289</a>）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）</p>
<p><strong>SRTT</strong> <strong>= S</strong> <strong>RTT</strong>  <strong>+ α</strong> <strong>(</strong> <strong>RTT</strong> <strong>– S</strong> <strong>RTT</strong> <strong>)</strong>  —— 计算平滑RTT</p>
<p><strong>DevRTT</strong> <strong>= (1-β</strong> *<em>)* ** <strong>DevRTT</strong> <strong>+ β</strong></em> <strong>(|</strong> <strong>RTT-SRTT</strong> <strong>|)</strong> ——计算平滑RTT和真实的差距（加权移动平均）</p>
<p><strong>RTO= µ * SRTT + ∂ *DevRTT</strong> —— 神一样的公式</p>
<p>（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609">tcp_rtt_estimator</a>）。</p>
<p>——来源<a href="https://coolshell.cn/articles/11609.html#Karn_Partridge_%E7%AE%97%E6%B3%95">TCP 的那些事儿（下） | 酷 壳 - CoolShell</a></p>
</blockquote>
<h3 id="tcp分段">TCP分段</h3>
<p>这里引入两个概念</p>
<ul>
<li>MTU（Maximum Transmission Unit）最大传输单元，以太网的MTU为1500字节，因此IP包只有1480</li>
<li>MSS（Maximum Segment Size）最大分段大小，这是一个TCP协议中的定义，MSS应该等于MTU-40，也就是1460，但若是双方未指定MSS大小的话，默认情况下MSS大小是536字节，这是因为 <a href="http://tools.ietf.org/html/rfc791">RFC 791</a>里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，网络中不只有以太网，还有很多其他连接方式，而576减去IP头的20个字节和TCP头的20个字节就是536）。</li>
</ul>
<p>为什么要主动引入MSS呢，看起来不是和MTU差不多吗？</p>
<p>其实是因为网络层数据包对IP包来说是透明的，像UDP没有引入MSS，且不会主动分段的话，直接交由IP封装的结果就是这样：</p>
<figure data-type="image" tabindex="6"><img src="https://files.catbox.moe/272t08.png" alt="UDP分段" loading="lazy"></figure>
<p>等接收方拿到第二个包的时候直接就扔了，也就是UDP不讲究。。。</p>
<p>但是对于可靠传输的TCP，这是完全不能忍受的，因此TCP会自己分段，保证自己发出的时候就不大于IP的MTU，别让IP帮我分</p>
<figure data-type="image" tabindex="7"><img src="https://files.catbox.moe/xkj8vx.png" alt="TCP分段" loading="lazy"></figure>
<p>这样第二个包也会被接收端正确解析</p>
<h3 id="tcp滑动窗口">TCP滑动窗口</h3>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文中的WIN字段告知发送方应该发送多大的数据，发送方收到报文后设置自己的窗口大小。</p>
<ul>
<li>
<p>发送窗口</p>
<p>发送窗口内的字节都允许被发送，如果发送窗口左边的字节已经发送并且收到了确认（ack），那么就讲发送窗口向右滑动一定距离，直到左边第一个没被确认的字节为止。</p>
</li>
<li>
<p>接收窗口</p>
<p>接收窗口内的字节都允许被接受，接收窗口只会对最后一个按序到达的字节进行确认，确认后向右滑动接收窗口。</p>
<p>例如：接收窗口已经收到了字节{31，34，35...}，其中{31}是按序到达的，因此只对31进行确认，同时向右滑动，当发送方接收到31的确认时，就知道31号之前的都已经被正确接受了</p>
</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" alt="img" loading="lazy"></figure>
<h4 id="zero-window">Zero Window</h4>
<p>如果某种原因导致接收端返回的确认报文中WIN=0，那么发送端就不会发送数据了，等到接收方的WIN腾出来了应该怎么告诉发送端呢？</p>
<p>这就是ZWP（Zero Window Probe），发送端在窗口变为0后会发送ZWP包给接收方，让接收方来重新设置WIN大小，具体重传次数和间隔看实现方案。如果多次仍为0，就可以直接RST</p>
<h4 id="silly-window-syndrome">Silly Window Syndrome</h4>
<p>翻译成中文就是“愚蠢窗口综合征”，其实也就是TCP的流量控制部分。如果接收方繁忙，每次都只能腾出一两个字节的WIN，但发送方仍会义无反顾地发送数据，但这样很浪费空间，一两个字节要经过TCP包，IP包的封装，仅仅是报文头部就最少有40个字节</p>
<p>一次传输肯定是越接近MTU最好，这样对带宽的利用率最大，不会浪费，因此为了避免数据包太小，那就憋着，等窗口够大了再发送数据，类似于大巴车等人满了再发车一个道理。发送方和接收方都有解决办法：</p>
<ul>
<li>
<p>接收端：</p>
<p>使用David D Clark’s方案。如果收到的数据或者自己处理太慢了，导致WIN小于某个值，就直接窗口0，啥也别发了，等缓过来，<strong>数据大于等于MSS，或者接受buffer腾出一半空间了再设置正常的窗口大小</strong>就好</p>
</li>
<li>
<p>发送端：</p>
<p>使用著名的<a href="https://zh.wikipedia.org/wiki/%E7%B4%8D%E6%A0%BC%E7%AE%97%E6%B3%95">纳格算法</a>，本质思路也是延迟等待。</p>
<pre><code> if有新資料要傳送
   if訊窗大小&gt;= MSS and可傳送的資料&gt;= MSS
     立刻傳送完整MSS大小的segment
   else
    if管線中有尚未確認的資料
      在下一個確認（ACK）封包收到前，將資料排進緩衝區佇列
    else
      立即傳送資料  
</code></pre>
<p>有两个条件：</p>
<ul>
<li>窗口大小&gt;=MSS 且 数据大小&gt;=MSS，立刻发送数据段（Segment）</li>
<li>收到了之前发送的未确认数据的ACK回包，立刻发送数据</li>
</ul>
<p>不过要注意，纳格算法不能和<a href="https://zh.wikipedia.org/wiki/TCP%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4">TCP延迟确认</a>同时开启，TCP延迟确认是将多个ACK回包合并成一个，节约利用资源（毕竟首部太大了），当两者同时开启的时候，一个憋着ACK不放，一个ACK不来不发，两人活生生就憋死了。</p>
<p>另外，纳格算法是默认打开的，但是对于SSH，telnet这种交互性程序，发送的都是小包，就需要主动关闭纳格算法。</p>
</li>
</ul>
<h3 id="tcp拥塞控制">TCP拥塞控制</h3>
<p>主要有四个阶段：</p>
<ol>
<li>慢启动（slow start）</li>
<li>拥塞避免（Congestion Avoidance）</li>
<li>拥塞发生</li>
<li>快速恢复（Fast Recovery）</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://segmentfault.com/img/remote/1460000023924957" alt="img" loading="lazy"></figure>
<h4 id="慢启动">慢启动</h4>
<ol>
<li>连接建立好后初始化一个cwnd（congestion window）=1，表示可以传输一个MSS大小的数据</li>
<li>每当收到一个ACK，cwnd++；线性上升（其实是指数增长）</li>
<li>2的结果是，每当过了一个RTT后，cwnd会刚好变为cwnd*2，因为第一次是一个ACK，所以增加一次，第二次是两个ACK所以增加两次</li>
<li>还有一个ssthresh（slow start threshold）慢启动阈值，<strong>cwnd&gt;=ssthresh后会进入拥塞避免阶段</strong></li>
</ol>
<h4 id="拥塞避免">拥塞避免</h4>
<ol>
<li>收到一个ACK时，cwnd = cwnd+1/cwnd；（其实是线性增长）</li>
<li>1的结果是，每当过了一个RTT后，cwnd =cwnd+1；因为cwnd正好等于可以发送的MSS数量大小，因此ACK的数量就等于cwnd</li>
</ol>
<h4 id="拥塞发生">拥塞发生</h4>
<p>当丢包的时候，有两种方法</p>
<ul>
<li>超时重传，也就是超过RTO的时长就重传，同时进行拥塞控制
<ol>
<li>sshthresh = cwnd/2</li>
<li>cwnd重置为1</li>
<li>进入慢启动过程</li>
</ol>
</li>
<li>快重传（Fast Retransmit），收到三个重复的ACK时就重传，无需等到RTO超时
<ul>
<li>TCP Tahoe：方法和超时一样</li>
<li>TCP Reno：
<ol>
<li>cwnd = cwnd/2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="快速恢复">快速恢复</h4>
<p>TCP Reno中定义的快速恢复算法是这样的：</p>
<ol>
<li>cwnd = sshthresh +3（意思是确认有三个数据包收到了）</li>
<li>重传这个重复的ACK指定的数据包</li>
<li>如果还是收到那个重复的ACK，cwnd = cwnd+1</li>
<li>如果收到了新的ACK，那么cwnd = sshthresh</li>
<li>进入拥塞避免状态</li>
</ol>
<p>然而如果不止重复ACK丢失的话，仅仅重传重复ACK，其他的还是会触发RTO超时重传，但是目前所说的所有方法都没办法知道到底是丢了几个数据包，除非使用SACK字段，但这需要通信双方都支持，基于SACK也有新的FACK算法进行拥塞控制，但若是不支持SACK就没办法了，因此提出了一个新的 TCP New Reno</p>
<ol>
<li>
<p>重传重复的数据包，根据返回的ack和已经发送的seq+长度进行对比，就可以推理出是否有其他包丢失</p>
<p>比如说发送方的seq = 1，长度20，正确的ack应该是21，如果此时收到了三个ack=5，如果说只有5号丢了，那第5号数据发送过去后返回的ack应该时21，如果返回是11，则证明11也丢了，甚至时12，13等等</p>
</li>
<li>
<p>与正确的ack不匹配的被称作Partial ACK，当发送方接收到Partial ACK后会一直重传没有被ack的第一个包，直到再也收不到Partial ACK，结束了快速恢复状态</p>
</li>
<li>
<p>进入拥塞避免阶段</p>
</li>
</ol>
<blockquote>
<p>本文大量引用他人文章，仅作个人笔记使用<br>
[CS-Notes (gitee.io)](http://cyc2018.gitee.io/cs-notes/#/notes/计算机网络 - 传输层)<br>
<a href="https://coolshell.cn/articles/11609.html#TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">TCP 的那些事儿（下） | 酷 壳 - CoolShell</a><br>
<a href="https://segmentfault.com/a/1190000023924934">万字长文 | 23 个问题 TCP 疑难杂症全解析 - SegmentFault 思否</a><br>
<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81">传输控制协议 - 维基百科，自由的百科全书 (wikipedia.org)</a><br>
<a href="https://draveness.me/whys-the-design-tcp-segment-ip-packet/">为什么 TCP/IP 协议会拆分数据 - 面向信仰编程 (draveness.me)</a></p>
</blockquote>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="http://blog.zerokirin.online/post/wang-luo-ceng/" class="post-title gt-a-link">
                    网络层
                </a>
            </div>
        

        
            <span id="/post/chuan-shu-ceng/" class="leancloud_visitors" data-flag-title="传输层">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">0</i>
            </span>
        

        

        
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: 'rIYE7O4AV22Nx8QJGNrgbXkd-gzGzoHsz',
		appKey: 'dME5rqAUTu5n0TFeGj8xJkwt',
		avatar: '',
		pageSize: 10,
		recordIp: false,
		placeholder: 'Just Go Go',
		visitor: true,
	});
</script>

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">记录</div>
    <div class="social-container">
        
            
                <a href="https://github.com/00LT00" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/people/ling-zhu-19-99" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="http://blog.zerokirin.online/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
