<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Mysql基础回顾 | Zer0kiriN</title>

<link rel="shortcut icon" href="http://blog.zerokirin.online/favicon.ico?v=1625011598726">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="http://blog.zerokirin.online/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


<script async src="https://www.googletagmanager.com/gtag/js?id=G-3HHG9VQ3K2"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-3HHG9VQ3K2');
</script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Zer0kiriN
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="http://blog.zerokirin.online/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="http://blog.zerokirin.online/post/every-day" class="menu gt-a-link">
                    Every Day
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1625011598726"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Mysql基础回顾
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-05-16 ·
                    </time>
                    
                        <a href="http://blog.zerokirin.online/tag/QlWdPOjLh/" class="post-tags">
                            # select
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/wQhcZm0ye_/" class="post-tags">
                            # update
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/3EExwt-CBi/" class="post-tags">
                            # delete
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/k9o7itsYG6/" class="post-tags">
                            # insert
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/M3QtfYt2dg/" class="post-tags">
                            # mysql
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/3mkkIacOvl/" class="post-tags">
                            # sql
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/aBLgVGYUdr/" class="post-tags">
                            # char
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/RSdPrssEte/" class="post-tags">
                            # varchar
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/zHUinlwqeK/" class="post-tags">
                            # text
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/lkoJt7TKuY/" class="post-tags">
                            # blob
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/VAofEbOV0f/" class="post-tags">
                            # int
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/H8EsIEIFEm/" class="post-tags">
                            # float
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/EnwgKJ1Hsn/" class="post-tags">
                            # double
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/HSk83ub7Yf/" class="post-tags">
                            # decimal
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/X87d8T0slJ/" class="post-tags">
                            # timestamp
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/BdVYAYj4mu/" class="post-tags">
                            # datetime
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/pvs_6vjYE9c/" class="post-tags">
                            # mysql数据类型
                        </a>
                    
                        <a href="http://blog.zerokirin.online/tag/1E5Eva_N1Pp/" class="post-tags">
                            # sql语法
                        </a>
                    
                </div>
                <div class="post-content">
                    <p><s>ORM库用起来是真的爽，面试的时候被问sql也是真的爽，人自闭了重新复习吧</s></p>
<h2 id="增删改查">增删改查</h2>
<h3 id="select">select</h3>
<pre><code class="language-sql">(8)SELECT (9)[ALL|DISTINCT|DISTINCTROW|TOP]
(11){*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]}
(1)FROM &lt;left_table[,…]&gt;
(3)[[{LEFT|RIGHT|INNER|CROSS}] JOIN &lt;right_table&gt; 
(2)	ON &lt;condition&gt;]
(4)[WHERE &lt;where_condition&gt;]
(5)[GROUP BY {col_name | expr | position}, ... (6)[WITH ROLLUP]]
(7)[HAVING &lt;where_condition&gt;]
(10)[ORDER BY {col_name | expr | position} [ASC | DESC]}
</code></pre>
<p>这是一个缩略版的select的解释顺序，括号中的数字代表解释的优先级，可以看到观察到几个点</p>
<ul>
<li>order by，field_list 等的优先级可以说是整个流程的最低级</li>
<li>group by 和 having 比where的优先级要低，也就是说所有的分组操作都是来源于where筛选后的结果</li>
<li>having做的是对分组后的结果集的再次查询，因此应该先使用where过滤，比如说找到非A用户的登录记录，筛选条件是可以放到having后的，但是A用户已经被分组了，同时参与了count等运算，只是最后剔除了这一组，所以说having可以看作是where的补充，能不用就不用</li>
<li>group by 和 order by 都支持position，也就是下标访问，不过是从1开始的，数组就是field_list</li>
</ul>
<h3 id="insert">insert</h3>
<p>insert into 有三种写法，官网的语句太复杂了，简化一下</p>
<ul>
<li>
<p>一种就是最基础的</p>
<pre><code class="language-sql">INSERT INTO tbl_name [(a,b,c)] VALUES (1,2,3)[, (4,5,6), (7,8,9)];
--或者是
INSERT INTO tbl_name [(a,b,c)] VALUES ROW(1,2,3)[, ROW(4,5,6), ROW(7,8,9)];
</code></pre>
<p>table后面可选择列名，如果不选的话，values后面每个括号中的内容都要按字段顺序填入</p>
<p>多个括号就是批量插入的意思</p>
</li>
<li>
<p>这种是用set代替了values</p>
<pre><code class="language-sql">INSERT INTO
	friend
SET
	name = 'Kim',
	isBFF = true
;
</code></pre>
<p>用法和普通的一样，类似于update语句，个人感觉更符合直觉一点，但是不支持批量插入</p>
</li>
<li>
<p>比较特殊的，从另一个表搜索数据然后插入</p>
<pre><code class="language-sql">INSERT INTO tbl_temp2 (fld_id)
  SELECT tbl_temp1.fld_order_id
  FROM tbl_temp1 WHERE tbl_temp1.fld_order_id &gt; 100;
  
--8.0.19版本后支持用table字段替代select
INSERT INTO ta TABLE tb; --select * from tb;支持limit和order by
</code></pre>
</li>
</ul>
<p>insert的特殊用法</p>
<ul>
<li>
<p>插入的行的主键已经存在 <code>ON DUPLICATE KEY UPDATE</code> ，存在就更新，大概有三种用法</p>
<pre><code class="language-sql">--可以引用a，b列的值，类似于分别设置c=1+2和c=4+5
INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6) ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);
--8.0.19版本后增加了AS关键字，可以通过表名来引用行
INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6) AS new ON DUPLICATE KEY UPDATE c = new.a+new.b;
--更骚的是还支持指定列名
INSERT INTO t1 SET a=1,b=2,c=3 AS new(m,n,p) ON DUPLICATE KEY UPDATE c = m+n;
--如果是插入，影响条数1，更新是2，内容不变的话是0
--这个用法在insert into select中也是可以的，其实就是把values...这部分换成了select...只放例子不再赘述
INSERT INTO t1
  SELECT * FROM (SELECT c, c+d AS e FROM t2) AS dt
  ON DUPLICATE KEY UPDATE b = e; --insert ...select语句的update部分不能使用VALUES()会报错
</code></pre>
</li>
<li>
<p>insert开头的可选项</p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>已存在</strong></th>
<th><strong>不存在</strong></th>
<th><strong>举例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>insert</td>
<td>报错</td>
<td>插入</td>
<td>insert into names(name, age) values(“小明”, 23);</td>
</tr>
<tr>
<td>insert ignore</td>
<td>忽略</td>
<td>插入</td>
<td>insert ignore into names(name, age) values(“小明”, 24);</td>
</tr>
<tr>
<td>replace</td>
<td>替换</td>
<td>插入</td>
<td>replace into names(name, age) values(“小明”, 25);</td>
</tr>
</tbody>
</table>
<p>重点看第三个，replace和on duplicate key的区别</p>
<ul>
<li>如果主键不存在，都是insert，无区别</li>
<li>如果存在，replace是真的delete后再insert，原有数据被清空，因此新行的值要写全不然会置零</li>
<li>on duplicate key是只更新update后面描述的结果，不是删除插入</li>
</ul>
</li>
</ul>
<h3 id="delete">delete</h3>
<p>这个没什么好说的用法不多基础语法如下：</p>
<pre><code class="language-sql">--删除一个表的数据
DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name [[AS] tbl_alias]
    [PARTITION (partition_name [, partition_name] ...)] --这里是分区
    [WHERE where_condition]
    [ORDER BY ...]
    [LIMIT row_count]
    
--多个表一起删或者作为辅助查询，下面两个用法一样，只是写法不同
DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    tbl_name[.*] [, tbl_name[.*]] ...
    FROM table_references --此处的写法和select中的join一样，支持各种join
    [WHERE where_condition]
--实例1. 
DELETE t1, t2 FROM t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id;

DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    FROM tbl_name[.*] [, tbl_name[.*]] ...
    USING table_references
    [WHERE where_condition]
--实例2.
DELETE FROM t1, t2 USING t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id; --没啥子区别，join部分一模一样

--比较实用的例子，从t1中删掉t2没有的行
DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;
</code></pre>
<h3 id="update">update</h3>
<p>最朴实无华的语法（非官方定义）</p>
<pre><code class="language-sql">UPDATE Tab1, [Tab2, [INNER JOIN | LEFT JOIN] Tab1 ON Tab1.C1 = Tab2.C1]  
SET Tab1.C2 = [Tab2.C2, Tab2.C3 =] expression  
WHERE Condition;  
</code></pre>
<p>如果只更新一个表就很简单，直接再set后面写出谁等于谁就好</p>
<pre><code class="language-sql">UPDATE t SET id = id + 1 ORDER BY id DESC; --这里用了orderby desc是因为，如果升序来，会先把1-&gt;2，这样就有两个2的记录了，违反了主键约束原则，因此降序更新
</code></pre>
<p>多个表的例子（多表时不能用order by 和limit）</p>
<pre><code class="language-sql">UPDATE items,month SET items.price=month.price WHERE items.id=month.id; --这里默认是inner join
</code></pre>
<p>左连接例子</p>
<pre><code class="language-sql">UPDATE Employees e LEFT JOIN Performance p   
ON e.performance = p.performance  
SET salary = salary + salary * 0.025  
WHERE p.percentage IS NULL;  
</code></pre>
<p>需要注意的一个问题是，update中where的子语句不能直接使用当前表的结果，例如：</p>
<pre><code class="language-sql">mysql&gt; UPDATE items
     &gt; SET retail = retail * 0.9
     &gt; WHERE id IN
     &gt;     (SELECT id FROM items
     &gt;         WHERE retail / wholesale &gt;= 1.3 AND quantity &gt; 100);
ERROR 1093 (HY000): You can't specify target table 'items' for update in FROM clause
</code></pre>
<p>需要将子查询移到一个新的派生表中</p>
<pre><code class="language-sql">UPDATE items,
       (SELECT id FROM items
        WHERE id IN
            (SELECT id FROM items
             WHERE retail / wholesale &gt;= 1.3 AND quantity &lt; 100))
        AS discounted
SET items.retail = items.retail * 0.9
WHERE items.id = discounted.id;
</code></pre>
<h2 id="数据类型">数据类型</h2>
<p>数据分为数值类型，字符串类型，时间类型，空间类型</p>
<h3 id="数值类型">数值类型</h3>
<h4 id="整型">整型</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left">1 byte</td>
<td style="text-align:left">(-128，127)</td>
<td style="text-align:left">(0，255)</td>
<td style="text-align:left">小整数值</td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left">2 bytes</td>
<td style="text-align:left">(-32 768，32 767)</td>
<td style="text-align:left">(0，65 535)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMINT</td>
<td style="text-align:left">3 bytes</td>
<td style="text-align:left">(-8 388 608，8 388 607)</td>
<td style="text-align:left">(0，16 777 215)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">INT或INTEGER</td>
<td style="text-align:left">4 bytes</td>
<td style="text-align:left">(-2 147 483 648，2 147 483 647)</td>
<td style="text-align:left">(0，4 294 967 295)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">8 bytes</td>
<td style="text-align:left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td style="text-align:left">(0，18 446 744 073 709 551 615)</td>
<td style="text-align:left">极大整数值</td>
</tr>
</tbody>
</table>
<p>借用菜鸟的表格，可以看到每种类型的大小已经固定了，而在类型声明的时候有可能会有这种情况</p>
<pre><code class="language-sql">CREATE TABLE test(
    id1 int(1),
    id2 tinyint(1)
);
</code></pre>
<p>这里内的值我们暂时称为M，M表示的意思就是实际的显示位数，但是<strong>上述写法是没有意义的</strong>，因为int和tinyint本身的长度是已经确定的，加括号的真正写法是</p>
<pre><code class="language-sql">CREATE TABLE test(
    int_test_M int(3) ZEROFILL,
);
</code></pre>
<p>只有用zerofill 修饰才有意义，加了zerofill后，会默认添加unsigned参数，也就是变成无符号数（非负数）</p>
<pre><code class="language-sql">mysql&gt; desc test1;
+------------+--------------------------+------+-----+---------+-------+
| Field      | Type                     | Null | Key | Default | Extra |
+------------+--------------------------+------+-----+---------+-------+
| int_test_M | int(3) unsigned zerofill | YES  |     | NULL    |       |
+------------+--------------------------+------+-----+---------+-------+
1 row in set (0.02 sec)

mysql&gt; select * from test1;
+------------+
| int_test_M |
+------------+
|        001 | --这里吧一位的长度补足了
|       1111 | --没啥用了
+------------+
2 rows in set (0.00 sec)
</code></pre>
<blockquote>
<p>As of MySQL 8.0.17, the <code>ZEROFILL</code> attribute is deprecated for numeric data types; you should expect support for it to be removed in a future version of MySQL. Consider using an alternative means of producing the effect of this attribute. For example, applications could use the <a href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad"><code>LPAD()</code></a> function to zero-pad numbers up to the desired width, or they could store the formatted numbers in <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>CHAR</code></a> columns.</p>
</blockquote>
<p>官方文档已经说了zerofill这玩意已经快废弃了，就别用这种骚操作了</p>
<p>另外还有两个整数型</p>
<ul>
<li>
<p><strong>BIT[(M)]</strong>  表示Mbits的数据大小，默认M为1，存储二进制数据，长度就是M，超过了大小则无法插入</p>
</li>
<li>
<p><strong>BOOL/BOOLEAN</strong> 本质上是TINYINT(1)，1是<code>'true'</code> 0是<code>'false'</code>，其他的值既不是true也不是false</p>
</li>
</ul>
<h4 id="浮点数">浮点数</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">4 bytes</td>
<td style="text-align:left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td style="text-align:left">单精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">8 bytes</td>
<td style="text-align:left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">双精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">小数值</td>
</tr>
</tbody>
</table>
<p>先说float和double，这是最常见的单精度和双精度浮点数，这里我们在M的基础上引入D，M说过了就是位数，D则代表了小数点后的位数，默认情况下float的D是7，double的D是15</p>
<p>这里float还有个特殊的骚操作，float[p]，用p代替了DM，p在0-24时当作float，25-53时当作double</p>
<p>但是给float和double指定精度的操作都是mysql特有的，并不是sql标准语法，并且官方文档已经说明，从8.0.17开始将不再建议此写法，同时有可能在未来的版本中删除，因此不要写这种奇奇怪怪的东西了，又不方便拓展又不能节省空间，何必呢</p>
<p>这里再说下<strong>DECIMAL</strong>，这个类型和float，double<strong>完全不一样</strong>，默认情况下他的(M,D)是(10,0)，M最大支持65，D最大30，千万不要把他理解成double，这是<strong>完全不一样</strong>的类型，众所周知，计算机内浮点数的存储方式和整型不一样，因为阶码和尾数的存在永远只能近似，但是DECIMAL<strong>完全不一样</strong>（三遍）</p>
<p>DECIMAL的英文含义就是十进制，因此它的存储结构和他的名字类似</p>
<table>
<thead>
<tr>
<th style="text-align:center">数位</th>
<th style="text-align:center">字节</th>
<th style="text-align:center">最大值（有符号）</th>
<th style="text-align:center">最大值位数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1-2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">127</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3-4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">32767</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">5-6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">8388607</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">7-9</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2147483647</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
<p>这样，每一个位数的最大值9999999都可以被他的空间完全表示出来，位数逢十进一，每10位占4个字节，整数和小数分开存储，举个例子，decimal(26,14)，小数14位，9+5，所以需要4+3=7字节大小存储小数，整数12位，9+3，也就是4+2=6字节存储，一共6+7=13字节大小</p>
<p>通过这种饱和式的存储方式，可以实现真正意义上的精度，再也不会有<code>1-0.0000000001!=0.9999999999</code>的情况出现，当然缺点就是存储空间大，但如果不是非要用那么大的精度的话，其实还好</p>
<p>当然这个类型也支持unsigned和zerofill，但是同样在8.0.17后已经不被推荐了，以后少用</p>
<h3 id="字符串类型">字符串类型</h3>
<p>字符串类型也大概可以分成两类，字符串和二进制字符串，当然还有一类比较特殊的ENUM和SET，我们先讲这两个</p>
<h4 id="enum-枚举set-集合">ENUM 枚举，SET 集合</h4>
<p>共同点：</p>
<ul>
<li>虽然显示格式是字符串，但是实际上存储的是其定义时的索引位置</li>
<li>直接插入整型变量的时候会当作索引</li>
<li>如果插入的字符串变量不在声明之中，会尝试将其索引化</li>
<li>空值是null，''是一个合法的值，代表着索引0的值，不是null</li>
</ul>
<p>区别就是ENUM只能存定义里的其中一个，SET是存任意多个</p>
<p>在存储上，ENUM只需要存储对应字符串的索引即可，最多支持65535个可选项，因此索引值最大也就是65535，正好是2Bytes的存储上限</p>
<p>而SET，集合就不一样了，集合有很多操作，比如交并补，因此set中子项的保存形式是以二进制字符串中1的位置来确定的，<code>SET('a','b','c','d')</code> 的索引值如下表</p>
<table>
<thead>
<tr>
<th style="text-align:left"><code>SET</code> Member</th>
<th style="text-align:left">Decimal Value</th>
<th style="text-align:left">Binary Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>''</code></td>
<td style="text-align:left"><code>0</code></td>
<td style="text-align:left"><code>0000</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'a'</code></td>
<td style="text-align:left"><code>1</code></td>
<td style="text-align:left"><code>0001</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'b'</code></td>
<td style="text-align:left"><code>2</code></td>
<td style="text-align:left"><code>0010</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'c'</code></td>
<td style="text-align:left"><code>4</code></td>
<td style="text-align:left"><code>0100</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'d'</code></td>
<td style="text-align:left"><code>8</code></td>
<td style="text-align:left"><code>1000</code></td>
</tr>
</tbody>
</table>
<p>这样集合的交并补就变成了两个二进制数的与或非操作</p>
<p>SET最大支持64个子项，也就是最大8Bytes，具体的字节数为 (N+7)/8四舍五入</p>
<p>在匹配的时候可以使用函数FIND_IN_SET()也可以用 like '%value%'</p>
<h4 id="字符串和二进制字符串">字符串和二进制字符串</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CHAR(M)</td>
<td style="text-align:left">0-255 个字符</td>
<td style="text-align:left">定长字符串</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR(M)</td>
<td style="text-align:left">取决于整行的大小</td>
<td style="text-align:left">变长字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYBLOB</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYTEXT</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">短文本字符串</td>
</tr>
<tr>
<td style="text-align:left">BLOB(M)</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:left">TEXT(M)</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">长文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMBLOB</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMTEXT</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGBLOB</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGTEXT</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">极大文本数据</td>
</tr>
</tbody>
</table>
<p><s>表是从菜鸟拿的，错得离谱。。。</s></p>
<h5 id="先从老生常谈的char与varchar说起">先从老生常谈的char与varchar说起</h5>
<ul>
<li>
<p>char</p>
<p>char是固定长度字符串，一般用法是char(M)，如果省略M，默认值1最大长度255，早在5.0以后M就不是字节了，M代表的是字符，菜鸟这么多年都没改过表格吗。。。</p>
<p>一个utf8编码下的中文字符占了3个字节，256*3=768字节，这才是CHAR的标准上限，但是如果使用utf8mb4过长的编码格式，就会超过768字节，innoDB会将多余的字节存到其他位置，所以只要是5.0版本以后就根本不需要care字节数的问题</p>
<p>存储时如果不足M长度，自动在末尾补' '填充，这也是为啥char类型的末尾' '会消失</p>
</li>
<li>
<p>varchar</p>
<p>varchar和char的区别不只是可变长度，其存储结构也不一样</p>
<p>在varchar中开头需要预留1或者2个字节作为长度的值，分别能表示255和65535个字节的长度，但这是字节数的理论上限，M的范围呢？</p>
<p>在innoDB中要求每一行一共能存储65535字节大小的数据，这是所有列共享的，因此M的大小还受到其他的列的影响，假如只有一列，那么一个中文字符大小3个字节，算上开头的两个表示长度的字节，一个NULL标记字节，65535-2-1=65532，65532/3=21844，这就是M在这种情况下的理论最大值</p>
<p>可以看到这个值是很不稳定的，因为还要考虑其他的列，因此不建议设这么大</p>
</li>
</ul>
<h5 id="binary和varbinar">BINARY和VARBINAR</h5>
<p>这俩和char，varchar非常相似，几乎一样，官方文档直说区别仅仅是保存的二进制字符串而已，不再赘述</p>
<h5 id="剩下的主要就是blob和text">剩下的主要就是BLOB和TEXT</h5>
<p>在mysql的官方文档中，可以看到它和varchar与varbinary十分类似</p>
<blockquote>
<p>In most respects, you can regard a <code>BLOB</code> column as a <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>VARBINARY</code></a> column that can be as large as you like. Similarly, you can regard a <code>TEXT</code> column as a <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a> column. <code>BLOB</code> and <code>TEXT</code> differ from <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>VARBINARY</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a> in the following ways:</p>
<ul>
<li>For indexes on <code>BLOB</code> and <code>TEXT</code> columns, you must specify an index prefix length. For <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>CHAR</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a>, a prefix length is optional. See <a href="https://dev.mysql.com/doc/refman/8.0/en/column-indexes.html">Section 8.3.5, “Column Indexes”</a>.</li>
<li><code>BLOB</code> and <code>TEXT</code> columns cannot have <code>DEFAULT</code> values.</li>
</ul>
</blockquote>
<p>主要的区别就是TEXT和BLOB需要指定前缀位数作为索引，不可以设置默认值</p>
<p>他们的存储方式取决于<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-dynamic">InnoDB Row Formats</a>， 在mysql5.7.9以后默认是dynamic</p>
<p>我们暂且只介绍dynamic模式，在这种存储方式下，数据会尽可能的填充满整个行，但不是我们所谓的65535的上限值，官方提供了一个例子</p>
<pre><code class="language-sql">mysql&gt; CREATE TABLE t4 (
       c1 CHAR(255),c2 CHAR(255),c3 CHAR(255),
       c4 CHAR(255),c5 CHAR(255),c6 CHAR(255),
       c7 CHAR(255),c8 CHAR(255),c9 CHAR(255),
       c10 CHAR(255),c11 CHAR(255),c12 CHAR(255),
       c13 CHAR(255),c14 CHAR(255),c15 CHAR(255),
       c16 CHAR(255),c17 CHAR(255),c18 CHAR(255),
       c19 CHAR(255),c20 CHAR(255),c21 CHAR(255),
       c22 CHAR(255),c23 CHAR(255),c24 CHAR(255),
       c25 CHAR(255),c26 CHAR(255),c27 CHAR(255),
       c28 CHAR(255),c29 CHAR(255),c30 CHAR(255),
       c31 CHAR(255),c32 CHAR(255),c33 CHAR(255)
       ) ENGINE=InnoDB ROW_FORMAT=DYNAMIC DEFAULT CHARSET latin1;
ERROR 1118 (42000): Row size too large (&gt; 8126). Changing some columns to TEXT or BLOB may help.
In current row format, BLOB prefix of 0 bytes is stored inline.
</code></pre>
<p>算算字节数，255*33=8415这点字节还远不到65535，但是却提示超过了8126，这个数是哪来的呢？</p>
<p>原来65535是mysql层判断的，实际存储的时候还需要存储引擎去判断，innoDB的策略是略小于存储页面大小的一半，默认的页面大小是16KB，它的一半就是8192，因此在innoDB看来最大行不能超过8126字节，这样上限我们就搞清楚了</p>
<p>TEXT与BLOB类型都会尽可能的存在这一行中，也就是B+树的叶子节点中，当长度已经满了的时候，会从所有的字段中选择最长的一列放到外部存储，dynamic的思想是，如果要用外部页面存储，就把整个数据都放过去，页内只留20字节的指针指向外部存储，对于长度小于40字节的TEXT和BLOB，并不会转移到外部，而是直接存在行内</p>
<p>BLOB和TEXT都支持M的用法（但是真的别用了，挺没意义的，都已经用这个类型了还纠结长度不如取用varchar，人家速度还快），如果用了M，会返回一个能满足M的要求的最小的预定义的TEXT或BLOB，举个例子：</p>
<pre><code class="language-sql">mysql&gt; alter table test1 add text_test text(20);
mysql&gt; desc test1;
+----------------+--------------------------+------+-----+---------+-------+
| Field          | Type                     | Null | Key | Default | Extra |
+----------------+--------------------------+------+-----+---------+-------+
| int_test_M     | int(3) unsigned zerofill | YES  |     | NULL    |       |
| bit_test_M     | bit(3)                   | YES  |     | NULL    |       |
| decimal_test_M | decimal(65,0)            | YES  |     | NULL    |       |
| binary_test    | binary(6)                | YES  |     | NULL    |       |
| set_test       | set('1','一')            | YES  |     | NULL    |       |
| text_test      | tinytext                 | YES  |     | NULL    |       |
+----------------+--------------------------+------+-----+---------+-------+
6 rows in set (0.02 sec)
</code></pre>
<p>可以看到，text_test并没有像其他的一样有M，而是直接分配了一个tinytext，blob同理，至此字符串基本上讲完了</p>
<h3 id="时间类型">时间类型</h3>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小 ( bytes)</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1000-01-01/9999-12-31</td>
<td style="text-align:left">YYYY-MM-DD</td>
<td style="text-align:left">日期值</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">3</td>
<td style="text-align:left">'-838:59:59'/'838:59:59'</td>
<td style="text-align:left">HH:MM:SS</td>
<td style="text-align:left">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1901/2155</td>
<td style="text-align:left">YYYY</td>
<td style="text-align:left">年份值</td>
</tr>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">8</td>
<td style="text-align:left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td style="text-align:left">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:left">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">4</td>
<td style="text-align:left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07，本质是一个存着时间戳的四字节整型</td>
<td style="text-align:left">YYYYMMDD HHMMSS</td>
<td style="text-align:left">混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<p>datetime和timestamp有个区别就是，当存入数据库的时候，datetime存储的是当前时区的时间，而时间戳是全球统一的，无需担心时区的问题</p>
<ul>
<li>8.0.19版本开始，可以在datetime和timestamp类型修改的时候添加时间偏移量</li>
<li>8.0.22版本开始，支持通过CAST()函数将timestamp转换成特定时区的datetime值</li>
</ul>
<p>举两个魔改的官方例子解释</p>
<pre><code class="language-sql">mysql&gt; SELECT @@system_time_zone; --提示了系统时区，现在是EST，北美东部标准时间，-05:00，我国是+08:00
+--------------------+
| @@system_time_zone |
+--------------------+
| EST                |
+--------------------+

mysql&gt; CREATE TABLE ts (
    -&gt;     id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -&gt;     col TIMESTAMP NOT NULL
    -&gt; ) AUTO_INCREMENT = 1;

mysql&gt; SET @@time_zone = 'SYSTEM'; -- -05:00

mysql&gt; INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');
--这里插入了三个，后两个的含义是，当前时区为+05:30的10.10.10，和当前时区-08:00的10.10.10，如果转换成UTC，分别应该-5.30和+8.00，但和第一个值明显对不上，原因看下一个

mysql&gt; SET @@time_zone = '+00:00';

mysql&gt; INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00'); 
--这里已经将时区切换成标准UTC时间了，再让我们看看结果，下面的23和56都是一样的，也就是说，当我们手动添加时区的偏移量的时候，会屏蔽掉设置的时区 


mysql&gt; SET @@time_zone = 'SYSTEM';
--这里又切换回了-5的时区，导致UTC时间的10.10.10，在显示的时候按照-5的时区显示，变成了05.10.10

mysql&gt; SELECT col, UNIX_TIMESTAMP(col) FROM ts ORDER BY id;
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 | --这里代表了-5:00的时区下的时间
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 05:10:10 |          1577873410 | --这里才是真实的UTC标准时间
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
+---------------------+---------------------+


mysql&gt; CREATE TABLE dt (
    -&gt;     id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -&gt;     col DATETIME NOT NULL
    -&gt; ) AUTO_INCREMENT = 1;

mysql&gt; INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');

mysql&gt; SET @@time_zone = '+00:00';

mysql&gt; INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');
--从这里的1，4可以看到，不管在哪个时区下，datetime的值只取决于获取时的时间，不随时区变化而改变
--但是一旦手动设置了偏移量，偏移量的大小都会先计算一次时区偏移，比如23的结果，都是在10.10.10的基础上-5，然后再-05.30和+08.00
--也就是说它老把自己当成UTC时间，手动改修改偏移量后然后自作聪明的想存进该时区时间，所以会先算一次时区，再计算时间戳

mysql&gt; SET @@time_zone = 'SYSTEM';

mysql&gt; SELECT col, UNIX_TIMESTAMP(col) FROM dt ORDER BY id;
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 10:10:10 |          1577891410 |
| 2020-01-01 04:40:10 |          1577871610 |
| 2020-01-01 18:10:10 |          1577920210 |
+---------------------+---------------------+
</code></pre>
<p>可以看到，timestamp和datetime在面对不一样的时区时做的操作是完全不同的，相比之下timestamp更通用一些</p>
<p>timestamp和datetime还支持自动更新</p>
<pre><code class="language-sql">created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP --创建时间
updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP --更新时间
</code></pre>
<p>至此时间类型也差不多讲完了，空间类型这个是真的一般用不到，等用到了再细究不迟，这里就不再赘述了，现在才发现其实mysql的官方文档才是最好的教程，远比网上搜的东西清楚</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="http://blog.zerokirin.online/post/ru-he-zai-github-shang-kai-yuan-zi-ji-de-bao/" class="post-title gt-a-link">
                    如何在github上开源自己的包
                </a>
            </div>
        

        
            <span id="/post/mysql-ji-chu-hui-gu/" class="leancloud_visitors" data-flag-title="Mysql基础回顾">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">0</i>
            </span>
        

        

        
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: 'rIYE7O4AV22Nx8QJGNrgbXkd-gzGzoHsz',
		appKey: 'dME5rqAUTu5n0TFeGj8xJkwt',
		avatar: '',
		pageSize: 10,
		recordIp: false,
		placeholder: 'Just Go Go',
		visitor: true,
	});
</script>

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">记录</div>
    <div class="social-container">
        
            
                <a href="https://github.com/00LT00" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/people/ling-zhu-19-99" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="http://blog.zerokirin.online/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
