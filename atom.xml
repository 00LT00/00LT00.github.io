<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.zerokirin.online</id>
    <title>Zer0kiriN</title>
    <updated>2021-07-03T13:09:28.250Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.zerokirin.online"/>
    <link rel="self" href="http://blog.zerokirin.online/atom.xml"/>
    <subtitle>记录</subtitle>
    <logo>http://blog.zerokirin.online/images/avatar.png</logo>
    <icon>http://blog.zerokirin.online/favicon.ico</icon>
    <rights>All rights reserved 2021, Zer0kiriN</rights>
    <entry>
        <title type="html"><![CDATA[Channel底层如何实现阻塞的]]></title>
        <id>http://blog.zerokirin.online/post/channel-di-ceng-ru-he-shi-xian-zu-sai-de/</id>
        <link href="http://blog.zerokirin.online/post/channel-di-ceng-ru-he-shi-xian-zu-sai-de/">
        </link>
        <updated>2021-06-29T06:24:06.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>每日一问系列（一）</p>
</blockquote>
<p>我们都知道，channel在缓冲区满或者无缓冲的时候，发送数据会阻塞，缓冲区空或无缓冲的时候，接受也会阻塞</p>
<p>那么这个阻塞，是怎么实现的呢？</p>
<p>之前我们只是粗略的讲解了channel的实现的结构体，这次我们详细的看看发送和接受的源码</p>
<p>源码位于<code>go 1.15.4 src/runtime/chan.go</code></p>
<h2 id="读取的两种方式">读取的两种方式</h2>
<pre><code class="language-go">ch := make(chan int, 10)
a := &lt;-ch
b,ok := &lt;-ch
</code></pre>
<p>golang有两种读取channel 的方式，</p>
<pre><code class="language-go">// entry points for &lt;- c from compiled code
//go:nosplit
func chanrecv1(c *hchan, elem unsafe.Pointer) {
	chanrecv(c, elem, true)
}

//go:nosplit
func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { //看这里多了个返回值，received
	_, received = chanrecv(c, elem, true)
	return
}
</code></pre>
<p>这两个函数也就是读取的两个方法，第二个带有一个名为received的返回值</p>
<p>他们同时都调用了<code>chanrecv</code>函数，所以重点就在这个函数中</p>
<h2 id="读取函数">读取函数</h2>
<p>函数原型</p>
<pre><code class="language-go">// chanrecv receives on channel c and writes the received data to ep.
// ep may be nil, in which case received data is ignored.
// If block == false and no elements are available, returns (false, false).
***重点在这，如果block是false，且无法获取到数据，则直接返回(false,false)
***这个的另一个意思就是，即便缓冲区buf为空，也不会阻塞，而是直接返回，那么这个的使用场景是？
// Otherwise, if c is closed, zeros *ep and returns (true, false).
// Otherwise, fills in *ep with an element and returns (true, true).
// A non-nil ep must point to the heap or the caller's stack.
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)
</code></pre>
<p>上面调用chanrecv的函数里面都是写死了block为true，那么什么时候是false呢？</p>
<pre><code class="language-go">// compiler implements
//
//	select {
//	case v = &lt;-c:
//		... foo
//	default:
//		... bar
//	}
//
// as
//
//	if selectnbrecv(&amp;v, c) {
//		... foo
//	} else {
//		... bar
//	}
//
func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected bool) {
	selected, _ = chanrecv(c, elem, false)
	return
}

// compiler implements
//
//	select {
//	case v, ok = &lt;-c:
//		... foo
//	default:
//		... bar
//	}
//
// as
//
//	if c != nil &amp;&amp; selectnbrecv2(&amp;v, &amp;ok, c) {
//		... foo
//	} else {
//		... bar
//	}
//
func selectnbrecv2(elem unsafe.Pointer, received *bool, c *hchan) (selected bool) {
	// TODO(khr): just return 2 values from this function, now that it is in Go.
	selected, *received = chanrecv(c, elem, false)
	return
}
</code></pre>
<p>select的用法就是，哪个可以取到数据就执行哪个case，而如果无法读取到则不会执行，所以肯定不能是阻塞的，所以两个用法的block的都是false</p>
<p>chanrecv的返回值名字也很直白，selected和received</p>
<p>selected只在执行select语句的时候判断case是否可以执行，至于数据是否获取到，则要看第二个参数received</p>
<p>那么我们详细来看chanrecv的内容吧，过程中我删掉了部分race检测的代码以及原有的英文注释</p>
<pre><code class="language-go">//原子操作检测是否能读取或者缓冲是否为空
func empty(c *hchan) bool {
	// c.dataqsiz is immutable.
	if c.dataqsiz == 0 { //无缓冲，检测发送队列是否是nil
		return atomic.Loadp(unsafe.Pointer(&amp;c.sendq.first)) == nil
	}
    //有缓冲，检测当前数量有多少
	return atomic.Loaduint(&amp;c.qcount) == 0
}

func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
    //如果是nil
	if c == nil {
        //在select语句中block是false，所以会在这直接返回(false,false)，也就是说select永远不会进入一个对nil的chan操作的步骤
        if !block { 
			return
		}
        //阻塞了，所以读取nil并不会直接报错
		gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)
		throw(&quot;unreachable&quot;)
	}

	// chan中是空的，没有办法直接获取值，且在select中，无需等待取值
	if !block &amp;&amp; empty(c) {
		//这里官方用了很长一段来描述为什么会这么写，大意是说
        //在竞争检测关闭时，可能会有多个goroutine对channel进行操作
        //比如说，一开始是，没有close的，非空的
        //后来被关闭了，然后把数据排空了
        //这时候由于检测语句的不合理安排以及并发访问
        //很有可能会得出一个，没有close的，空了的结果
        //所以对empty和closed都是原子操作去检测
        
		if atomic.Load(&amp;c.closed) == 0 { //未关闭
			//由于channel不能关了再开，所以如果检测到未关闭
            //则证明在一开始就是未关闭的
            //返回false，false
            //select不会继续下去，因为他还有收到值的可能性
			return
		}
		
        //执行到这一定是closed的了，再检测一次empty是因为
        //有可能在上面判断closed之前，有了新的数据，那么可能会是closed和非空
		if empty(c) {
			//确定是空，若接受体不为空，也就是不用_抛弃，则直接置为0值
			if ep != nil {
				typedmemclr(c.elemtype, ep)
			}
            //selected，可以执行这条路，但是v,ok=&lt;-ch的ok是false
			return true, false
		}
	}

    //后文初始化sudog的条件（暂时看不懂干嘛的，下次研究）
	var t0 int64
	if blockprofilerate &gt; 0 {
		t0 = cputicks()
	}

    //加锁
	lock(&amp;c.lock)

    //closed，且 缓冲buf 是空的
    //无论有无缓冲区，都是这个流程
	if c.closed != 0 &amp;&amp; c.qcount == 0 {
		unlock(&amp;c.lock)
		if ep != nil { //清空接收者
			typedmemclr(c.elemtype, ep)
		}
		return true, false
	}

    //如果发送队列不为空的话执行，注意
    //也就是要么无缓冲，要么缓冲buf满了，两种情况处理方法不一样，recv函数待会再讲
	if sg := c.sendq.dequeue(); sg != nil {
		recv(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)
		return true, true
	}

    //数据个数大于0，那肯定是有缓冲类型的
	if c.qcount &gt; 0 {
        //通过这个chanbuf，获取到数据地址，存到qp中
		qp := chanbuf(c, c.recvx)
        //把qp移动到ep中
		if ep != nil {
			typedmemmove(c.elemtype, ep, qp)
		}
        //原来的数据置空
        //还有一点就是，如果上一个ep是nil，也就是用_忽略了的话，这一步也会把数据清掉
		typedmemclr(c.elemtype, qp)
        //循环链表，所以下标正常增长
		c.recvx++
        //涨到最大值后变为0，循环嘛
		if c.recvx == c.dataqsiz {
			c.recvx = 0
		}
        //取数据了，所以肯定要减小
		c.qcount--
		unlock(&amp;c.lock)
		return true, true
	}

    /*	前面我们已经排除了
    *	closed的，有发送队列的（缓冲类型溢出了，无缓冲类型有被阻塞的发送），缓冲区有值的
    *	剩下的就是，未closed的，缓冲区没数据且发送队列空的
    *	人话就是，轮到阻塞等待有缘人发送数据了
    */
    
    //select中没必要阻塞，直接就略过了
	if !block {
		unlock(&amp;c.lock)
		return false, false
	}

	//从这里开始就是阻塞的流程
    
    //获取当前运行的g的指针
	gp := getg()
    //获取一个sudog结构体
	mysg := acquireSudog()
	mysg.releasetime = 0
	if t0 != 0 {
		mysg.releasetime = -1
	}
	// No stack splits between assigning elem and enqueuing mysg
	// on gp.waiting where copystack can find it.
	mysg.elem = ep
	mysg.waitlink = nil
    //当前g正在等待的sudog
	gp.waiting = mysg
    //对应的g
	mysg.g = gp
    //是否在select语句中
	mysg.isSelect = false
    //标识是哪个chan
	mysg.c = c
    //唤醒时传递的参数，一般都是空
	gp.param = nil
    //将这个sudog放到接收队列中，等待唤醒
	c.recvq.enqueue(mysg)
	// Signal to anyone trying to shrink our stack that we're about
	// to park on a channel. The window between when this G's status
	// changes and when we set gp.activeStackChans is not safe for
	// stack shrinking.
    //这里设置个标志位，通知任何想要缩小栈空间情况，告诉他们这个g现在在等待channel的唤醒
    //这里会有线程安全问题，所以用atomic操作
	atomic.Store8(&amp;gp.parkingOnChan, 1)
    //暂停当前g，也就是实质上的阻塞，函数原型放在最后
	gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2)

	// someone woke us up
    //唤醒，检查下有没有呗错误唤醒
	if mysg != gp.waiting {
		throw(&quot;G waiting list is corrupted&quot;)
	}
    //等待的置空
	gp.waiting = nil
	gp.activeStackChans = false
	if mysg.releasetime &gt; 0 {
		blockevent(mysg.releasetime-t0, 2)
	}
	closed := gp.param == nil
	gp.param = nil
	mysg.c = nil
    //释放sudog
	releaseSudog(mysg)
	return true, !closed
}

// Puts the current goroutine into a waiting state and calls unlockf.
// If unlockf returns false, the goroutine is resumed.
// unlockf must not access this G's stack, as it may be moved between
// the call to gopark and the call to unlockf.
// Reason explains why the goroutine has been parked.
// It is displayed in stack traces and heap dumps.
// Reasons should be unique and descriptive.
// Do not re-use reasons, add new ones.
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) 
</code></pre>
<p>再来让我们看看上面说的recv函数，上面的调用方式是这样的</p>
<p><code>recv(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)</code></p>
<pre><code class="language-go">// recv processes a receive operation on a full channel c.
// There are 2 parts:
// 1) The value sent by the sender sg is put into the channel
//    and the sender is woken up to go on its merry way.
// 2) The value received by the receiver (the current G) is
//    written to ep.
// For synchronous channels, both values are the same.
// For asynchronous channels, the receiver gets its data from
// the channel buffer and the sender's data is put in the
// channel buffer.
// Channel c must be full and locked. recv unlocks c with unlockf.
// sg must already be dequeued from c.
// A non-nil ep must point to the heap or the caller's stack.

//上面注释写的很清楚，两个情况，一个是缓冲区满了，一个是没有缓冲区的
//总归都是sg不为空，也就是发送队列有人在等着发送数据
func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
    //缓冲区0，也就是无缓冲
   if c.dataqsiz == 0 {
      if ep != nil {
         // copy data from sender
          //直接从发送者的sg中提取内容
         recvDirect(c.elemtype, sg, ep)
      }
   } else {
      // Queue is full. Take the item at the
      // head of the queue. Make the sender enqueue
      // its item at the tail of the queue. Since the
      // queue is full, those are both the same slot.
      //缓冲区满了
      //计算出当前应该提取的内容的位置
      qp := chanbuf(c, c.recvx)
      // copy data from queue to receiver
      //这里校验ep是因为有可能有 &lt;-ch 直接取值的情况存在
      if ep != nil {
          //将数据从刚刚计算好的位置拿出来
         typedmemmove(c.elemtype, ep, qp)
      }
      // copy data from sender to queue
      //把发送队列的东西复制到刚刚拿走了的位置
      typedmemmove(c.elemtype, qp, sg.elem)
      //下标加一，满了就置0
      c.recvx++
      if c.recvx == c.dataqsiz {
         c.recvx = 0
      }
      //设置一下已经发送的位置到哪了
      //也就是新数据该往哪放了
      c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
   }
   //发送完了就卸磨杀驴，该请的要清了
   sg.elem = nil
   //把发送的g的信息保存一下
   gp := sg.g
    //解锁函数，一般来说都是unlock(&amp;c.lock)
   unlockf()
   gp.param = unsafe.Pointer(sg)
   if sg.releasetime != 0 {
      sg.releasetime = cputicks()
   }
   //唤醒这个发送者，因为他的数据已经发送完成了，就没必要阻塞了
   goready(gp, skip+1)
}
</code></pre>
<h2 id="发送过程">发送过程</h2>
<p>和接受过程几乎一样，快速的看一下</p>
<pre><code class="language-go">/*
 * generic single channel send/recv
 * If block is not nil,
 * then the protocol will not
 * sleep but return if it could
 * not complete.
 *
 * sleep can wake up with g.param == nil
 * when a channel involved in the sleep has
 * been closed.  it is easiest to loop and re-run
 * the operation; we'll see that it's now closed.
 */
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
	if c == nil {
		if !block {
			return false
		}
		gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)
		throw(&quot;unreachable&quot;)
	}

	// Fast path: check for failed non-blocking operation without acquiring the lock.
	//
	// After observing that the channel is not closed, we observe that the channel is
	// not ready for sending. Each of these observations is a single word-sized read
	// (first c.closed and second full()).
	// Because a closed channel cannot transition from 'ready for sending' to
	// 'not ready for sending', even if the channel is closed between the two observations,
	// they imply a moment between the two when the channel was both not yet closed
	// and not ready for sending. We behave as if we observed the channel at that moment,
	// and report that the send cannot proceed.
	//
	// It is okay if the reads are reordered here: if we observe that the channel is not
	// ready for sending and then observe that it is not closed, that implies that the
	// channel wasn't closed during the first observation. However, nothing here
	// guarantees forward progress. We rely on the side effects of lock release in
	// chanrecv() and closechan() to update this thread's view of c.closed and full().
    
    //上面一大串的注释就是告诉你，如何在不获取锁的情况下判断是否准备好发送数据了，先判断close和和先判断full(c)都是正确的
    
	if !block &amp;&amp; c.closed == 0 &amp;&amp; full(c) {
		return false
	}

	var t0 int64
	if blockprofilerate &gt; 0 {
		t0 = cputicks()
	}

	lock(&amp;c.lock)
	
    //已经关闭了，所以要panic，不能继续发送了
	if c.closed != 0 {
		unlock(&amp;c.lock)
		panic(plainError(&quot;send on closed channel&quot;))
	}

    //接收队列有东西，要么是缓冲区空了，要么是没有缓冲区
	if sg := c.recvq.dequeue(); sg != nil {
		// Found a waiting receiver. We pass the value we want to send
		// directly to the receiver, bypassing the channel buffer (if any).
        //下文详细讲下这个函数
		send(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)
		return true
	}

    //缓冲区还没满，这里dataqsiz至少大于0，所以是有缓冲的
	if c.qcount &lt; c.dataqsiz {
		// Space is available in the channel buffer. Enqueue the element to send.
        //确定好应该存放的地址
		qp := chanbuf(c, c.sendx)
		typedmemmove(c.elemtype, qp, ep)
		c.sendx++
		if c.sendx == c.dataqsiz {
			c.sendx = 0
		}
		c.qcount++
		unlock(&amp;c.lock)
		return true
	}

    //没有能放的位置了，只能阻塞了
    //select中，非阻塞的直接返回了
	if !block {
		unlock(&amp;c.lock)
		return false
	}

	// Block on the channel. Some receiver will complete our operation for us.
	gp := getg()
	mysg := acquireSudog()
	mysg.releasetime = 0
	if t0 != 0 {
		mysg.releasetime = -1
	}
	// No stack splits between assigning elem and enqueuing mysg
	// on gp.waiting where copystack can find it.
	mysg.elem = ep
	mysg.waitlink = nil
	mysg.g = gp
	mysg.isSelect = false
	mysg.c = c
	gp.waiting = mysg
	gp.param = nil
    //把自己放到发送队列中
	c.sendq.enqueue(mysg)
	// Signal to anyone trying to shrink our stack that we're about
	// to park on a channel. The window between when this G's status
	// changes and when we set gp.activeStackChans is not safe for
	// stack shrinking.
	atomic.Store8(&amp;gp.parkingOnChan, 1)
    //阻塞住了
	gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)
	// Ensure the value being sent is kept alive until the
	// receiver copies it out. The sudog has a pointer to the
	// stack object, but sudogs aren't considered as roots of the
	// stack tracer.
    
    //这里和接受的方法不一样的是，多了个keepalive
    //原因是，在接受方法中，ep是一个外部传进来的，数据的目的地址，那么ep在外部一定是被使用的，所以ep一定不会在阻塞的时候被gc回收掉，如果没有使用，那回收了就回收了，问题不大
    //但是，在这里ep是一个数据源地址，很有可能在发送以后就不存在了，那么阻塞的过程中就很有可能被回收掉，所以要加入一个保活的函数，策略就是，我后面还会用到这个变量，那么gc就不会扫描这个，这样只有被唤醒后，keepalive才会调用，然后ep数据已经发送出去了，回收就无所谓了
	KeepAlive(ep)

	// someone woke us up.
    //收尾工作没什么好讲的了
	if mysg != gp.waiting {
		throw(&quot;G waiting list is corrupted&quot;)
	}
	gp.waiting = nil
	gp.activeStackChans = false
	if gp.param == nil {
		if c.closed == 0 {
			throw(&quot;chansend: spurious wakeup&quot;)
		}
		panic(plainError(&quot;send on closed channel&quot;))
	}
	gp.param = nil
	if mysg.releasetime &gt; 0 {
		blockevent(mysg.releasetime-t0, 2)
	}
	mysg.c = nil
	releaseSudog(mysg)
	return true
}
</code></pre>
<p>看看send函数</p>
<p><code>send(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)</code></p>
<pre><code class="language-go">// send processes a send operation on an empty channel c.
// The value ep sent by the sender is copied to the receiver sg.
// The receiver is then woken up to go on its merry way.
// Channel c must be empty and locked.  send unlocks c with unlockf.
// sg must already be dequeued from c.
// ep must be non-nil and point to the heap or the caller's stack.
func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
	//前面一大串都是涉及到竞争检测的内容，本次暂时不分析
	if sg.elem != nil {
        //看名字就很清楚了，从sg复制到ep
		sendDirect(c.elemtype, sg, ep)
		sg.elem = nil
	}
    //找到那个等待的g
	gp := sg.g
    //解锁
	unlockf()
	gp.param = unsafe.Pointer(sg)
	if sg.releasetime != 0 {
		sg.releasetime = cputicks()
	}
    //唤醒
	goready(gp, skip+1)
}
</code></pre>
<h2 id="总结">总结</h2>
<p>主要有两个方面，一个是block参数，为了方便实现select语句，所以是非阻塞的操作，不能执行就不执行了</p>
<p>另一方面就是gopark和goready函数，通过这两个函数对g进行阻塞，其中发送任务还要用keepalive保活</p>
<p><s>不愧是每日一问，写了四天好家伙</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql 并发控制详解（四）——并发一致性错误的解决方式]]></title>
        <id>http://blog.zerokirin.online/post/mysql-bing-fa-kong-zhi-xiang-jie-si-bing-fa-yi-zhi-xing-cuo-wu-de-jie-jue-fang-shi/</id>
        <link href="http://blog.zerokirin.online/post/mysql-bing-fa-kong-zhi-xiang-jie-si-bing-fa-yi-zhi-xing-cuo-wu-de-jie-jue-fang-shi/">
        </link>
        <updated>2021-06-07T03:55:15.000Z</updated>
        <content type="html"><![CDATA[<p>至此我们讲完了锁和MVCC，对数据库事务方面的理解应该更深了，还记得第一章我们讲的并发一致性问题吗，现在就让我们逐个分析</p>
<p><s>（读未提交和第一类丢失修改就不了，这个暂时真没搞明白）</s></p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离等级</th>
<th>未解决的并发一致性问题</th>
<th style="text-align:right">解决的并发一致性问题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读未提交</td>
<td>幻影读，不可重复读，读脏数据，第二类丢失修改</td>
<td style="text-align:right">第一类丢失修改</td>
</tr>
<tr>
<td style="text-align:center">读已提交</td>
<td>幻影读，不可重复读，第二类丢失修改</td>
<td style="text-align:right">读脏数据，第一类丢失修改</td>
</tr>
<tr>
<td style="text-align:center">可重复读</td>
<td>幻影读，第二类丢失修改（具体类型具体分析）</td>
<td style="text-align:right">不可重复读，读脏数据，第一类丢失修改</td>
</tr>
<tr>
<td style="text-align:center">串行化</td>
<td></td>
<td style="text-align:right">幻影读，不可重复读，读脏数据，两类丢失修改</td>
</tr>
</tbody>
</table>
<h2 id="封锁协议">封锁协议</h2>
<p>讲之前发现还得把这个说清楚了，有三级封锁协议和两段锁协议，这个指的是数据库如何利用前面讲到的锁</p>
<p>三级封锁协议：</p>
<ul>
<li>一级封锁协议	任何写操作需要加X锁，直到事务结束</li>
<li>二级封锁协议	在一级封锁协议的基础上，读取数据时必须加S锁，读取完<strong>马上</strong>释放S锁</li>
<li>三级封锁协议	在一级封锁协议的基础上，读取数据时必须加S锁，<strong>直到事务结束</strong>才释放</li>
</ul>
<p>两段锁协议：</p>
<ul>
<li>
<p>多个事务们的加锁和解锁分为两个阶段，要么一起加要么一起解</p>
</li>
<li>
<p>两段锁协议保证了加锁过程是可串行化调度（和那个串行化级别无关），是充分条件，也就是两段锁一定保证可串行化，但可串行化不一定要两段锁，例如</p>
<ul>
<li>
<pre><code>lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
两段锁协议，先一起加锁后一起解锁
</code></pre>
</li>
<li>
<pre><code>lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
分开加解锁，但它依然是可串行化调度
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="一级封锁协议协议-和-读未提交">一级封锁协议协议 和 读未提交</h2>
<p>举个例子，我们把mysql降为读未提交的级别，然后看看锁</p>
<pre><code class="language-sql">--事务A
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from gap;
+----+------+
| id | name |
+----+------+
|  1 | 张三 |
|  4 | 王哥 |
|  7 | 王五 |
|  8 | 赵四 |
| 11 | 刘能 |
+----+------+
5 rows in set (0.01 sec)

--事务B
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; update gap set name = '老王比' where id = 4;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0
--注意这里B还没提交

--事务A
mysql&gt; select * from gap;
+----+--------+
| id | name   |
+----+--------+
|  1 | 张三   |
|  4 | 老王比 | --虽然没提交但是已经查到了变化了
|  7 | 王五   |
|  8 | 赵四   |
| 11 | 刘能   |
+----+--------+
5 rows in set (0.01 sec)

--再看看锁
mysql&gt; SELECT event_id,OBJECT_NAME,index_name,LOCK_TYPE,LOCK_MODE,LOCK_STATUS,LOCK_DATA FROM performance_schema.data_locks\G;
*************************** 1. row ***************************
   event_id: 13
OBJECT_NAME: gap
 index_name: NULL
  LOCK_TYPE: TABLE
  LOCK_MODE: IX --意向锁
LOCK_STATUS: GRANTED
  LOCK_DATA: NULL
*************************** 2. row ***************************
   event_id: 13
OBJECT_NAME: gap
 index_name: PRIMARY
  LOCK_TYPE: RECORD
  LOCK_MODE: X,REC_NOT_GAP --一级封锁协议中提到的，更改的时候增加X锁
LOCK_STATUS: GRANTED
  LOCK_DATA: 4
2 rows in set (0.00 sec)
</code></pre>
<p>可以看到这里只有个记录锁和意向锁，可以浅显的理解为，读未提交是一级封锁协议的实现</p>
<p>同时它还可以解决第一类丢失修改，这个就不演示了，确实没有，为啥呢，等我问完老师再说</p>
<h2 id="读已提交和脏读">读已提交和脏读</h2>
<p>脏读就是上面演示过的，明明没提交，就已经被看到了，那么这个隔离级别是怎么避免的呢？</p>
<p>我们看二级封锁协议的定义，每个读取都要先添加S锁，那么实际上呢？</p>
<p>同样，我们把mysql降到读已提交</p>
<pre><code class="language-sql">mysql&gt; show variables like '%isolation%';
+-----------------------+----------------+
| Variable_name         | Value          |
+-----------------------+----------------+
| transaction_isolation | READ-COMMITTED |
+-----------------------+----------------+
1 row in set, 1 warning (0.00 sec)

--事务B
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; update gap set name = '老王比' where id &gt; 4; --即便是范围，但因为是RC等级，所以不存在gap锁，只有record锁
Query OK, 3 rows affected (0.04 sec)
Rows matched: 3  Changed: 3  Warnings: 0

--这里看都是加了X锁的
mysql&gt; SELECT event_id,OBJECT_NAME,index_name,LOCK_TYPE,LOCK_MODE,LOCK_STATUS,LOCK_DATA FROM performance_schema.data_locks\G;
*************************** 1. row ***************************
   event_id: 8
OBJECT_NAME: gap
 index_name: NULL
  LOCK_TYPE: TABLE
  LOCK_MODE: IX
LOCK_STATUS: GRANTED
  LOCK_DATA: NULL
*************************** 2. row ***************************
   event_id: 8
OBJECT_NAME: gap
 index_name: PRIMARY
  LOCK_TYPE: RECORD
  LOCK_MODE: X,REC_NOT_GAP
LOCK_STATUS: GRANTED
  LOCK_DATA: 7
*************************** 3. row ***************************
   event_id: 8
OBJECT_NAME: gap
 index_name: PRIMARY
  LOCK_TYPE: RECORD
  LOCK_MODE: X,REC_NOT_GAP
LOCK_STATUS: GRANTED
  LOCK_DATA: 8
*************************** 4. row ***************************
   event_id: 8
OBJECT_NAME: gap
 index_name: PRIMARY
  LOCK_TYPE: RECORD
  LOCK_MODE: X,REC_NOT_GAP
LOCK_STATUS: GRANTED
  LOCK_DATA: 11
4 rows in set (0.00 sec)

--事务A
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from gap;
+----+------+
| id | name |
+----+------+
|  1 | 张三 |
|  4 | 王哥 |
|  7 | 王五 |
|  8 | 赵四 |
| 11 | 刘能 |
+----+------+
5 rows in set (0.00 sec)
</code></pre>
<p>很显然，事务A在读取的过程中并没有加S锁，因为有X锁存在的前提下，S是无法加锁的，那么读取操作必然会被阻塞</p>
<p>所以读已提交并不是通过二级封锁协议实现的，而是通过MVCC实现的，说的好听些叫做<strong>一致性非锁定读</strong></p>
<p>我们上一章讲过，在事务没有结束的时候，它的内部对外是不可见的，因此其它事务只能根据read view读取该行之前的版本，脏读问题自然没有了</p>
<p>但是封锁协议只是一种思想，而它的核心思想在于，读取完立即释放S锁，在MVCC的实现过程中就变成了每次select都创建一个新的read view</p>
<p>可以把二级封锁协议看作是读未提交的悲观锁实现方式，MVCC是乐观锁方式</p>
<p>悲观锁的问题就是并发量不足，这也是为什么会用MVCC去实现的原因</p>
<h2 id="可重复读下的非锁定读">可重复读下的非锁定读</h2>
<p>其实这个所谓的非锁定读，就是正常使用select语句不带for update或for share的读，也是mysql默认的隔离级别中所说的哪个可重复读，同样是通过MVCC实现的</p>
<p>它和RC的区别就是，它的select生成的read view 是第一个select 生成，一直到事务结束的</p>
<p>看看三级封锁协议，是不是很像，三级封锁协议也是，直到事务结束才释放锁，所以三级封锁协议和MVCC的实现方式都可以避免不可重复读的问题</p>
<p>和RC一样，可以把三级封锁协议看作是悲观锁版本，MVCC是乐观锁版本</p>
<p>既然是MVCC的实现方式，为什么我要把它专门分出来一个非锁定读？</p>
<p>因为它没有解决我们之前提到过的，第二类丢失修改，和另一个很重要的错误，幻影读</p>
<h3 id="错误的第二类丢失修改">错误的第二类丢失修改</h3>
<p>我们先来看一个错误的实例</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>转账事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T2</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询账户余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元把余额<strong>减少100元</strong></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><strong>提交事务</strong></td>
</tr>
<tr>
<td>T7</td>
<td>汇入100元，把余额<strong>增加100</strong>元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td><strong>提交事务</strong></td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>余额是1000元，无白嫖</td>
<td>（这里的正确答案是1000元，并没有出错）</td>
</tr>
</tbody>
</table>
<p>这个错误的例子常被人拿来宣称“RR的隔离级别可以解决第二类丢失修改”</p>
<p>这是彻头彻尾的胡扯，上一章讲MVCC的文章中说过，这种非锁定读也称作快照读，相对应的还有个叫做当前读，当前读是完全不受MVCC的限制的</p>
<p>而更改这个操作在它生成临时表的那一刻用的就是<strong>当前读</strong></p>
<p>上述这个错误的例子中，即便T6时刻它仍然会显示余额为1000（因为MVCC），但是在T7，更改时它读出的临时表中，余额是900，<strong>因为他是当前读查出来的结果</strong></p>
<p>那有人会说为什么不干脆就这么写了呢，为什么还要select呢？因为会有各种意外啊，而且直接这么写，某种程度上就是主动把隔离级别降到了RC，反而把这个问题变成了不可重复读的问题，简直是开倒车了</p>
<p>那趁着这个错误的例子，我们来讲讲幻影读</p>
<h3 id="幻影读">幻影读</h3>
<p>第一章就说过了，幻影读不是不可重复读，它的本质是当你使用select 和增删改操作时，手动混合了当前读和快照读，导致一致性失效，而不可重复读是read view 的创建时机不同</p>
<p>把第一章的例子拿出来分析</p>
<pre><code class="language-sql">--事务1
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select count(*) from gap;
+----------+
| count(*) |
+----------+
|        4 |
+----------+
1 row in set (0.04 sec)

mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select count(*) from gap;
+----------+
| count(*) |
+----------+
|        4 |
+----------+
1 row in set (0.04 sec)

--事务2
mysql&gt; insert into gap values(8,'老王');
Query OK, 1 row affected (0.05 sec)

--事务1
mysql&gt; select count(*) from gap;
+----------+
| count(*) |
+----------+
|        4 | --没有任何变化
+----------+
1 row in set (0.00 sec)

mysql&gt; select * from gap;
+----+------+
| id | name |
+----+------+
|  1 | 张三 |
|  5 | 李四 |
|  7 | 王五 |
| 11 | 赵6  |
+----+------+
4 rows in set (0.00 sec)

--事务1
mysql&gt; insert into gap values(8,'赵四');
ERROR 1062 (23000): Duplicate entry '8' for key 'gap.PRIMARY'

mysql&gt; update gap set name = '刘能' where id = 8;
Query OK, 1 row affected (0.04 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; select * from gap;
+----+------+
| id | name |
+----+------+
|  1 | 张三 |
|  5 | 李四 |
|  7 | 王五 |
|  8 | 刘能 |
| 11 | 赵6  |
+----+------+
5 rows in set (0.00 sec)
</code></pre>
<p>由于是可重复读级别，默认查询使用的是快照读，在第一个select的时候生成的read view直到事务结束才失效，所以插入后再查是找不到的（这不就是可重复读的基本定义嘛）</p>
<p>但插入和更新的时候会变成当前读，因此插入报错，那么更新后为什么能搜到呢？</p>
<p>注意看上一章我们讲的MVCC，更新后它的隐藏列会更新是哪个事务更改了他，而那个事务ID正是当前的事务ID，所以在查询的时候，curr_trx_id == DB_TRX_ID，满足展示条件，就显示了出来</p>
<p>所以RR并没有解决幻影读，而上文讲的那个错误的第二类丢失更新本质上和幻影读一样，都是当前读和快照读发生了冲突</p>
<h3 id="真正的第二类丢失修改">真正的第二类丢失修改</h3>
<p>第二类的丢失修改流程是这样的</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>转账事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T2</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询账户余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元<strong>把余额改为900元</strong></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><strong>提交事务</strong></td>
</tr>
<tr>
<td>T7</td>
<td>汇入100元<strong>把余额改为1100 元</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td><strong>提交事务</strong></td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>最后结果是1100元</td>
<td>（这个是真的会变成1100，白嫖100）</td>
</tr>
</tbody>
</table>
<p>看到了吗，两个update 操作都是直接更新成了一个我们计算好的数值，而仅仅通过MVCC是无法避免这种错误的</p>
<p>这种操作会在该记录行上增加两个undo log，1100的回滚指针指向的是900而不是1000，因为在更新的时候是当前读，所以在T7时刻，innoDB是很清楚当前值已经被更改为900了</p>
<p>上一个案例我们知道，900+100又变回了1000，但是这次我们是手动写值的，这就意味着我们在业务代码中判断的更新的值是错误的，因此innoDB会看着你把900变成了1100，这波貌似不能怪mysql？</p>
<p>在innoDB看来这是你自己写错了，和他没半毛钱关系，都不能算是卡了个MVCC的bug。。。</p>
<p>这也是为什么很多博客都在说，其实RR级别不能解决第二类丢失修改，因为这本来就不是MVCC应该控制的问题</p>
<p>那么怎么解决这类丢失修改和幻影读问题呢？还记得上面说过，MVCC是RR的乐观锁版本，而基于三级封锁协议的它的悲观锁版本就是最好的答案</p>
<h2 id="rr-with-next-key">RR with next-key</h2>
<p>MVCC的RR被称作一致性非锁定读，那么这个使用了next-key的RR就是一致性锁定读，也可以理解成它实现了三级封锁协议，是RR的悲观锁版本</p>
<p>前文中我们详细介绍了record lock，gap lock，next-key lock的锁定范围及使用方法，还有什么时候会加这些锁，而我们所有的实例中几乎都是</p>
<pre><code class="language-sql">select * from ...... for [update|share]
</code></pre>
<p>通过加上<code>for update</code>，select就变成了一致性锁定读，也就是三级封锁协议的描述，读取数据时必须加S锁，<strong>直到事务结束</strong>才释放，此时将不再通过MVCC去判断展示的数据</p>
<h3 id="幻读">幻读</h3>
<p>由于我们的select ... for update 会给搜索到的数据添加next-key和gap锁，而插入操作的时候会先获取插入意向锁（实际上是个X的gap锁）</p>
<p>当该范围内有锁的时候，插入意向锁没法添加，所以就保证了我们搜索到的范围内不会被插入新的数据，从根本上避免了幻读的出现</p>
<h3 id="第二类丢失修改">第二类丢失修改</h3>
<p>上面我们说过，这类错误是innoDB允许的，是他看着你自己改错了，那么要想避免这个错误，就要通过<code>for update</code> 通知innoDB，“帮我锁定下，我待会要根据这个查询出来的值更新”</p>
<p>innoDB就会给查到的行增加X类型的锁，其他事务的查询就要等该事务结束后才能继续，这样就避免了查询出来后的值和改的时候不一样，也就是当前读和快照读的冲突</p>
<p>再把流程展示一下</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>转账事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T2</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询账户余额为1000元 for update 加了X锁</td>
</tr>
<tr>
<td>T4</td>
<td>查询账户余额为？元 for update 加X锁等待中</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元<strong>把余额改为900元</strong></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><strong>提交事务</strong> 释放X锁</td>
</tr>
<tr>
<td>T7</td>
<td>查询账户余额为900元 for update 获取了X锁</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>汇入100元<strong>把余额改为1000 元</strong></td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td><strong>提交事务</strong></td>
<td></td>
</tr>
<tr>
<td>T10</td>
<td>最后结果是1000元</td>
<td>（白嫖失败，这次一定）</td>
</tr>
</tbody>
</table>
<p>这样我们就通过带有next-key的RR级别，避免了丢失修改，但这种方法也有很大的缺点，如果需要频繁的对该表修改，这种方式就会频繁的加锁解锁，并发性能就会受到很大的影响</p>
<p>所以当前常用的做法是给该表增加一个显示的版本行，当更新写回的时候判断版本号是否更改过，如果改过则回滚，也就是我们所说的乐观锁，这样查询可以利用innoDB的MVCC，更新的时候用自己做的MVCC，避免了频繁加锁解锁导致的事务等待而浪费性能</p>
<h2 id="总结">总结</h2>
<p>至此，我们所有的并发一致性错误已经全部解决了（其实还有很多新世代发现的错误，但这里笔者能力实在过于菜，无力顾及了）</p>
<p>四个事务隔离级别我们也讲了三个，最后一个串行化已经不能算并发了</p>
<p>通过三级封锁协议的思想和MVCC的实现，尽最大可能的保证了RC和RR的并发</p>
<p>另外两个超出MVCC能力的并发错误也通过next-key等锁解决了</p>
<p>事务，并发，锁，MVCC，封锁协议的问题暂时就告一段落<s>同时十分感谢各位被偷图的老板</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql 并发控制详解（三）——MVCC]]></title>
        <id>http://blog.zerokirin.online/post/mysql-mvcc-qian-xi/</id>
        <link href="http://blog.zerokirin.online/post/mysql-mvcc-qian-xi/">
        </link>
        <updated>2021-06-05T11:29:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="multi-version-concurrency-control">Multi-version concurrency control</h2>
<p>多版本并发控制，首先我们先来问个问题，为什么要用MVCC？</p>
<p>我们都知道mysql有四个事务隔离等级</p>
<ul>
<li>
<p>读未提交</p>
<p>压根没有事务和版本这个概念，裸奔不需要mvcc</p>
</li>
<li>
<p>串行化</p>
<p>对所有的操作都加互斥锁，无需版本管理，因为整个数据库中只有一个唯一的版本</p>
</li>
</ul>
<p>所以mvcc的应用场景是为了实现读已提交和可重复读，说的专业一点叫做<strong>一致性非锁定读</strong>，那么它是如何实现的呢？</p>
<h2 id="记录行中自带的版本信息">记录行中自带的版本信息</h2>
<p>首先，在InnoDB引擎中，每行数据都有三个隐藏列</p>
<ul>
<li>6-byte <code>DB_TRX_ID</code> 用来表示这行数据最后是被哪个事务增删改的（删除其实也算更新）</li>
<li>7-byte <code>DB_ROLL_PTR</code> 回滚指针，指向的是undo log 中对应的记录，主要是指向事务未提交的数据位置，也就是记录了要怎么回滚，一共有四种undo log，不过这不是本文的重点</li>
<li>6-byte <code>DB_ROW_ID</code> 行ID，就是主键ID或者是字段中的一个unique ID，如果都没有，那就用哪个隐藏的主键ID（一定记住，聚簇索引不可能没有主键）</li>
</ul>
<p>千万注意，<strong>TRX_ID是递增的</strong>，通过事务ID确定版本号，所以版本号不可能开倒车吧</p>
<h2 id="read-view-是什么">read view 是什么</h2>
<p>再来看一个概念read view，它包括四个结构</p>
<ul>
<li><code>rw_trx_ids</code>：表示在生成 Read View 时，当前活跃的读写事务数组。</li>
<li><code>min_trx_id</code>：表示在生成 Read View 时，当前已提交的事务号 + 1，也就是在 <code>rw_trx_ids</code> 中的最小事务号。</li>
<li><code>max_trx_id</code>：表示在生成 Read View 时，当前已分配的事务号 + 1，也就是将要分配给下一个事务的事务号。</li>
<li><code>curr_trx_id</code>：创建 Read View 的当前事务 id。</li>
</ul>
<p>可以看到，一个read view 中记录了当前数据库中的各种事务版本，这样我们通过把每个行记录与read view对比，就可以判断出该记录的状态以及是否应该展示，所以read view在某种程度上起到了一个快照的作用</p>
<h2 id="read-view-和事务id的关系">read view 和事务ID的关系</h2>
<ul>
<li>DB_TRX_ID &lt; min_trx_id  这一行的事务ID比已经提交了的事务ID小，所以在生成readview的时候他已经commit了，<strong>可以展示</strong></li>
<li>DB_TRX_ID &gt;= max_trx_id  最后修改它的ID比这个时间点上最大的事务ID都大，那肯定<strong>不能展示</strong></li>
<li>DB_TRX_ID &gt;= min_trx_id 时 DB_TRX_ID == curr_trx_id  自己创建的自己肯定<strong>可以看到</strong>，其他的那就都是其他事务创建的，还没提交<strong>所以看不到</strong></li>
</ul>
<p>这样，我们就能够根据read view 确定当前到底哪些可以被展示出来，而这种查找的时候根据read view匹配的方式被称作<strong>快照读</strong>，和它对应的叫做<strong>当前读</strong>，当前读就完全不受mvcc的限制</p>
<p>我们最开始提到了，RR和RC是通过mvcc实现的，在这两个隔离级别下，默认的select语句就是快照读，区别是</p>
<ul>
<li>RR（可重复读） 事务开始后，第一次select就创建一个read view，后续的所有查询都是用的第一个read view</li>
<li>RC（读已提交） 事务开始后，每一个select都会创建一个read view，也因此，它无法解决不可重复读的问题，因为事务过程中如果其他事务更新了记录，新的read view的min_trx_id会大于那个新记录的trx_id，就会把新记录也查出来</li>
</ul>
<h2 id="实例">实例</h2>
<p><s>图源<a href="https://juejin.cn/post/6844904194206351373">MySQL 中你必须要懂的 MVCC (juejin.cn)</a> 这个图做的很nice，偷偷搬过来</s></p>
<p>假设我们现在是RC级别（为了方便看看read view的更新）</p>
<ul>
<li>
<p>假设当前这行记录长这样，和红色表头直接挨着的就是存在B+Tree上的数据，可以看到回滚指针没有值，表明当前数据未发生过更改</p>
<figure data-type="image" tabindex="1"><img src="https://files.catbox.moe/1yq6gp.png" alt="初始记录" loading="lazy"></figure>
</li>
<li>
<p>现在一个id为101的事务修改了它</p>
<figure data-type="image" tabindex="2"><img src="https://files.catbox.moe/nosz69.png" alt="修改1" loading="lazy"></figure>
<p>可以看到它的回滚指针指到了undo log中的旧记录</p>
</li>
<li>
<p>事务 0 执行了一个 <code>select</code> 操作，事务 0 会生成一个 Read View。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://files.catbox.moe/au6i7v.png" alt="read view" loading="lazy"></figure>
<p>注意，这个min_trx_id存的是最后一个提交的ID+1，所以此时此刻数据库中已经提交了ID是100，也就是说上面的修改并没有提交，所以根据匹配规则可以发现，该行的最新记录并不符合要求，就会沿着他的回滚指针找到第一个满足要求的也就是100的记录</p>
<ul>
<li>事务 101 又更新了一下，然后提交事务</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://files.catbox.moe/j9yjos.png" alt="commit后" loading="lazy"></figure>
<ul>
<li>如果再select一次，生成的新的read view为</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://files.catbox.moe/ibs0r7.png" alt="read view2" loading="lazy"></figure>
<p>最新提交的变成了101，活跃的事务已经没有了（101提交了），那这时候就可以看到最新记录了</p>
<figure data-type="image" tabindex="6"><img src="https://files.catbox.moe/jpbq4c.png" alt="select 2" loading="lazy"></figure>
<p>那个黄色的 age=21 的记录是不会展示出来的，因为对于其他事务来说，它是一个中间状态，只有他自己可以看到</p>
<h2 id="总结">总结</h2>
<p>innoDB通过比较隐藏列和read view的关系，确定该记录是否展示，或者通过回滚指针找到第一个能展示的版本</p>
<ul>
<li>
<p>RC 是每一次select 都会生成新的read view</p>
</li>
<li>
<p>RR 是只有第一次select 生成新的，后续都不会更新了</p>
</li>
</ul>
<p>也正是这个区别，决定了两者是否会产生不可重复读的问题</p>
<p>读未提交和串行化都不需要mvcc</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql 并发控制详解（二）——锁]]></title>
        <id>http://blog.zerokirin.online/post/mysql-shi-wu-ge-chi-deng-ji-he-suo-xiang-jie-er/</id>
        <link href="http://blog.zerokirin.online/post/mysql-shi-wu-ge-chi-deng-ji-he-suo-xiang-jie-er/">
        </link>
        <updated>2021-06-01T20:50:18.000Z</updated>
        <content type="html"><![CDATA[<p>书接上回，我们罗列了一下事务隔离等级和并发一致性问题，那么这一章就让我们看看锁是怎么工作的，又是怎么和事务联系起来的</p>
<p>官方文档如下：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-shared-exclusive-locks">Shared and Exclusive Locks</a> 共享锁和独占锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-intention-locks">Intention Locks</a> 意向锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-record-locks">Record Locks</a> 记录锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-gap-locks">Gap Locks</a> 间隙锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-next-key-locks">Next-Key Locks</a> 临键锁</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-insert-intention-locks">Insert Intention Locks</a> 插入意向锁</li>
</ul>
<h2 id="逻辑意义上的锁">逻辑意义上的锁</h2>
<h3 id="共享锁和独占锁">共享锁和独占锁</h3>
<p>换句话说就是读锁和写锁（互斥锁，排他锁），简称S和X，innoDB中的行级锁就是这两种锁</p>
<ul>
<li>读锁可以重复加，共享锁嘛</li>
<li>写锁和读锁不能共存，也就是独占的意思，当有读锁存在的时候不能加写锁</li>
</ul>
<p><s>偷图<a href="https://draveness.me/mysql-innodb/">『浅入浅出』MySQL 和 InnoDB - 面向信仰编程 (draveness.me)</a></s></p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/Draveness/Analyze/master/contents/Database/images/mysql/Shared-Exclusive-Lock.jpg" alt="Shared-Exclusive-Lock" loading="lazy"></figure>
<h3 id="意向锁">意向锁</h3>
<p>刚刚我们说到，行级锁包括读锁和写锁，而mysql支持多粒度的锁，也就是说，存在表级别的读锁和写锁，这样就带来个问题，如果要对某个表加锁，那么就要判断它的每一行是否有锁，这是非常影响性能的，因此提出了意向锁的概念</p>
<p>意向锁分为读写两种，简称IS和IX，是表级锁，他们之间是互相兼容的，<s>继续偷图</s></p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/Draveness/Analyze/master/contents/Database/images/mysql/Lock-Type-Compatibility-Matrix.jpg" alt="Lock-Type-Compatibility-Matrix" loading="lazy"></figure>
<p>这里的几个锁都代表了表级锁，因为意向锁<strong>只有表级</strong>，不能把行级混进来</p>
<ul>
<li>要获取行级的S或X锁，必须先获取其表的意向锁</li>
<li>获取表锁的时候不需要意向锁</li>
</ul>
<p>这样当我们要增加表级的S或X锁时，如果其中某行已经有了S或X锁，那么表上就会有对应的IS和IX锁，这样就不用每行都去检测了</p>
<h2 id="物理意义上的锁">物理意义上的锁</h2>
<h3 id="record-lock">record lock</h3>
<p>record lock 记录锁是索引记录上的锁，也就是我们上述所说的行锁的实现，同样有S和X之分，它是后面的各种行锁的基础，也可以直接理解为，record lock就是行锁，因为innoDB用的是聚簇索引，所以所有的数据最后都是主键索引去找，锁住了主键索引也就代表锁住了这一行</p>
<p>它通过对索引进行锁定，让我们举个小例子，假设锁的结构和索引如下：</p>
<pre><code class="language-sql">mysql&gt; desc salaries;
+-----------+------+------+-----+---------+----------------+
| Field     | Type | Null | Key | Default | Extra          |
+-----------+------+------+-----+---------+----------------+
| id        | int  | NO   | PRI | NULL    | auto_increment |
| emp_no    | int  | NO   | MUL | NULL    |                |
| salary    | int  | NO   | MUL | NULL    |                |
| from_date | date | NO   | MUL | NULL    |                |
| to_date   | date | NO   |     | NULL    |                |
+-----------+------+------+-----+---------+----------------+
5 rows in set (0.00 sec)

mysql&gt; show index from salaries\G;
*************************** 1. row ***************************
        Table: salaries
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: id
    Collation: A
  Cardinality: 2837536
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 2. row ***************************
        Table: salaries
   Non_unique: 0
     Key_name: idx_emp_date
 Seq_in_index: 1
  Column_name: emp_no
    Collation: A
  Cardinality: 293002
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 3. row ***************************
        Table: salaries
   Non_unique: 0
     Key_name: idx_emp_date
 Seq_in_index: 2
  Column_name: from_date
    Collation: A
  Cardinality: 2837536
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
3 rows in set (0.00 sec)
</code></pre>
<p>对表中的第一行加共享类型的record锁</p>
<pre><code class="language-sql">mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from salaries where id = 1 for share;
+----+--------+--------+------------+------------+
| id | emp_no | salary | from_date  | to_date    |
+----+--------+--------+------------+------------+
|  1 |  10001 |  60117 | 1986-06-26 | 1987-06-26 |
+----+--------+--------+------------+------------+
1 row in set (0.00 sec)

mysql&gt; select * from performance_schema.data_locks\G;
*************************** 1. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:1215:2835495239768
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 39
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2835495239768
            LOCK_TYPE: TABLE --意向锁，因为要获取行锁，所以必须先加上意向锁
            LOCK_MODE: IS
          LOCK_STATUS: GRANTED
            LOCK_DATA: NULL
*************************** 2. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:157:9:2:2835495236984
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 39
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY --主键索引
OBJECT_INSTANCE_BEGIN: 2835495236984
            LOCK_TYPE: RECORD --这里看到了吗，锁的类型是record
            LOCK_MODE: S,REC_NOT_GAP --模式是S，是record锁而非gap锁（下文介绍）
          LOCK_STATUS: GRANTED --以获取锁的意思
            LOCK_DATA: 1 --锁定的数据是id=1的主键索引
2 rows in set (0.00 sec)
</code></pre>
<p>可以看到，当我们通过主键索引找到数据的时候，会对该主键索引加锁，那么二级索引呢</p>
<pre><code class="language-sql">mysql&gt; explain select * from salaries where emp_no = 10001 limit 1 for share\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: salaries
   partitions: NULL
         type: ref
possible_keys: idx_emp_date,idx_emp_no
          key: idx_emp_date --用的是辅助索引
      key_len: 4
          ref: const
         rows: 17
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)

ERROR:
No query specified

mysql&gt;  select * from salaries where emp_no = 10001 limit 1 for share;
+----+--------+--------+------------+------------+
| id | emp_no | salary | from_date  | to_date    |
+----+--------+--------+------------+------------+
|  1 |  10001 |  60117 | 1986-06-26 | 1987-06-26 |
+----+--------+--------+------------+------------+
1 row in set (0.00 sec)

mysql&gt; select * from performance_schema.data_locks\G;
*************************** 1. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:1215:2835495239768
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 39
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2835495239768
            LOCK_TYPE: TABLE
            LOCK_MODE: IS
          LOCK_STATUS: GRANTED
            LOCK_DATA: NULL
*************************** 2. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:157:9:2:2835495236984
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 39
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 2835495236984
            LOCK_TYPE: RECORD
            LOCK_MODE: S,REC_NOT_GAP
          LOCK_STATUS: GRANTED
            LOCK_DATA: 1
*************************** 3. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:157:43:2:2835495237328
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 41
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: idx_emp_date --看这里，第三个锁的是实际使用的索引
OBJECT_INSTANCE_BEGIN: 2835495237328
            LOCK_TYPE: RECORD
            LOCK_MODE: S --共享模式
          LOCK_STATUS: GRANTED
            LOCK_DATA: 10001, 1017050, 1 --对应索引上被锁住的数据
3 rows in set (0.00 sec)
</code></pre>
<p>上述可以看到，当我们使用辅助索引的时候就会对辅助索引加record锁，那么如果一开始就是用辅助索引呢？</p>
<pre><code class="language-sql">mysql&gt; begin; --重开个事务
Query OK, 0 rows affected (0.00 sec)

mysql&gt; explain select * from salaries where emp_no = 10001 limit 1 for share\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: salaries
   partitions: NULL
         type: ref
possible_keys: idx_emp_date,idx_emp_no
          key: idx_emp_date --用的是辅助索引
      key_len: 4
          ref: const
         rows: 17
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)

ERROR:
No query specified

mysql&gt; select * from salaries where emp_no = 10001 limit 1 for share;
+----+--------+--------+------------+------------+
| id | emp_no | salary | from_date  | to_date    |
+----+--------+--------+------------+------------+
|  1 |  10001 |  60117 | 1986-06-26 | 1987-06-26 |
+----+--------+--------+------------+------------+
1 row in set (0.00 sec)

mysql&gt; select * from performance_schema.data_locks\G;
*************************** 1. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:1215:2835495239768
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 47
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2835495239768
            LOCK_TYPE: TABLE
            LOCK_MODE: IS
          LOCK_STATUS: GRANTED
            LOCK_DATA: NULL
            
--看这里，两个锁的顺序不一样了，对比上面的可以看到，这次是辅助索引在上
*************************** 2. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:157:43:2:2835495236984
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 47
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: idx_emp_date --先辅助索引
OBJECT_INSTANCE_BEGIN: 2835495236984
            LOCK_TYPE: RECORD
            LOCK_MODE: S
          LOCK_STATUS: GRANTED
            LOCK_DATA: 10001, 1017050, 1 --锁住的值
*************************** 3. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:157:9:2:2835495237328
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 47
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY --然后才是主键索引
OBJECT_INSTANCE_BEGIN: 2835495237328
            LOCK_TYPE: RECORD
            LOCK_MODE: S,REC_NOT_GAP
          LOCK_STATUS: GRANTED
            LOCK_DATA: 1
3 rows in set (0.00 sec)
</code></pre>
<p>这也很好解释，先加意向锁，然后通过辅助索引找到主键索引，最后从主键索引那取数据</p>
<p>那我们再加个互斥锁呢？</p>
<pre><code class="language-sql">mysql&gt; select * from salaries where emp_no = 10001 limit 1 for update;
+----+--------+--------+------------+------------+
| id | emp_no | salary | from_date  | to_date    |
+----+--------+--------+------------+------------+
|  1 |  10001 |  60117 | 1986-06-26 | 1987-06-26 |
+----+--------+--------+------------+------------+
1 row in set (0.00 sec)

mysql&gt; select * from performance_schema.data_locks\G;
*************************** 1. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:1215:2835495239768
ENGINE_TRANSACTION_ID: 59891
            THREAD_ID: 274
             EVENT_ID: 47
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2835495239768
            LOCK_TYPE: TABLE
            LOCK_MODE: IS
          LOCK_STATUS: GRANTED
            LOCK_DATA: NULL
*************************** 2. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:157:43:2:2835495236984
ENGINE_TRANSACTION_ID: 59891
            THREAD_ID: 274
             EVENT_ID: 47
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: idx_emp_date
OBJECT_INSTANCE_BEGIN: 2835495236984
            LOCK_TYPE: RECORD
            LOCK_MODE: S
          LOCK_STATUS: GRANTED
            LOCK_DATA: 10001, 1017050, 1
*************************** 3. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:157:9:2:2835495237328
ENGINE_TRANSACTION_ID: 59891
            THREAD_ID: 274
             EVENT_ID: 47
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 2835495237328
            LOCK_TYPE: RECORD
            LOCK_MODE: S,REC_NOT_GAP
          LOCK_STATUS: GRANTED
            LOCK_DATA: 1
            
--看这里，上面的和原来一样，共享锁的基础上加互斥锁并不意味着直接升级，而是额外加锁
*************************** 4. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:1215:2835495239856
ENGINE_TRANSACTION_ID: 59891
            THREAD_ID: 274
             EVENT_ID: 55
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2835495239856
            LOCK_TYPE: TABLE
            LOCK_MODE: IX
          LOCK_STATUS: GRANTED
            LOCK_DATA: NULL
*************************** 5. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:157:43:2:2835495237672
ENGINE_TRANSACTION_ID: 59891
            THREAD_ID: 274
             EVENT_ID: 55
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: idx_emp_date
OBJECT_INSTANCE_BEGIN: 2835495237672
            LOCK_TYPE: RECORD
            LOCK_MODE: X
          LOCK_STATUS: GRANTED
            LOCK_DATA: 10001, 1017050, 1
*************************** 6. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:157:9:2:2835495238016
ENGINE_TRANSACTION_ID: 59891
            THREAD_ID: 274
             EVENT_ID: 55
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 2835495238016
            LOCK_TYPE: RECORD
            LOCK_MODE: X,REC_NOT_GAP
          LOCK_STATUS: GRANTED
            LOCK_DATA: 1
6 rows in set (0.00 sec)
</code></pre>
<p>如果先加互斥锁再加共享锁呢</p>
<pre><code class="language-sql">--互斥锁
mysql&gt; select * from salaries where emp_no = 10001 limit 1 for update;
+----+--------+--------+------------+------------+
| id | emp_no | salary | from_date  | to_date    |
+----+--------+--------+------------+------------+
|  1 |  10001 |  60117 | 1986-06-26 | 1987-06-26 |
+----+--------+--------+------------+------------+
1 row in set (0.00 sec)

--共享锁
mysql&gt; select * from salaries where emp_no = 10001 limit 1 for share;
+----+--------+--------+------------+------------+
| id | emp_no | salary | from_date  | to_date    |
+----+--------+--------+------------+------------+
|  1 |  10001 |  60117 | 1986-06-26 | 1987-06-26 |
+----+--------+--------+------------+------------+
1 row in set (0.00 sec)

mysql&gt; select * from performance_schema.data_locks\G;
*************************** 1. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:1215:2835495239768
ENGINE_TRANSACTION_ID: 59892
            THREAD_ID: 274
             EVENT_ID: 62
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2835495239768
            LOCK_TYPE: TABLE
            LOCK_MODE: IX --意向锁
          LOCK_STATUS: GRANTED
            LOCK_DATA: NULL
*************************** 2. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:157:43:2:2835495236984
ENGINE_TRANSACTION_ID: 59892
            THREAD_ID: 274
             EVENT_ID: 62
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: idx_emp_date
OBJECT_INSTANCE_BEGIN: 2835495236984
            LOCK_TYPE: RECORD
            LOCK_MODE: X --互斥锁
          LOCK_STATUS: GRANTED
            LOCK_DATA: 10001, 1017050, 1
*************************** 3. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:157:9:2:2835495237328
ENGINE_TRANSACTION_ID: 59892
            THREAD_ID: 274
             EVENT_ID: 62
        OBJECT_SCHEMA: employees
          OBJECT_NAME: salaries
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 2835495237328
            LOCK_TYPE: RECORD
            LOCK_MODE: X,REC_NOT_GAP
          LOCK_STATUS: GRANTED
            LOCK_DATA: 1
3 rows in set (0.00 sec)
</code></pre>
<p>可以看到，当我们拥有了互斥锁后，再加共享锁就没有意义了，我们也可以称，互斥锁是比共享锁更高级别的锁定</p>
<h3 id="gap-lock">Gap lock</h3>
<p>间隙锁，这个锁<strong>只</strong>存在于<strong>可重复读</strong>这一隔离级别，同时这个锁不分S和X，它锁住的是一个区间，其他事务在这个区间内的插入删除更新操作都会被阻塞</p>
<p>同时它很特别的一点是，加多个Gap锁不会阻塞，可以有多个事务同时添加Gaplock，因为本质上他是为了保护一个区间不会插入，而不是为了锁定具体的数据</p>
<p>让我们看个小例子，先建表：</p>
<pre><code class="language-sql">mysql&gt; CREATE TABLE `gap` (
    -&gt;   `id` int(1) NOT NULL AUTO_INCREMENT,
    -&gt;   `name` varchar(8) DEFAULT NULL,
    -&gt;   PRIMARY KEY (`id`)
    -&gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
Query OK, 0 rows affected, 2 warnings (0.03 sec)

mysql&gt;
mysql&gt; INSERT INTO `gap` VALUES ('1', '张三');
Query OK, 1 row affected (0.01 sec)

mysql&gt; INSERT INTO `gap` VALUES ('5', '李四');
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO `gap` VALUES ('7', '王五');
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO `gap` VALUES ('11', '赵六');
Query OK, 1 row affected (0.00 sec)
</code></pre>
<p>让我们对其中一部分数据加锁：</p>
<pre><code class="language-sql">mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from gap where id between 3 and 8 for share;
+----+------+
| id | name |
+----+------+
|  5 | 李四 |
|  7 | 王五 |
+----+------+
2 rows in set (0.00 sec)

--查看锁
mysql&gt; select * from performance_schema.data_locks\G;
*************************** 1. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:1216:2835495239768
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 288
        OBJECT_SCHEMA: employees
          OBJECT_NAME: gap
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 2835495239768
            LOCK_TYPE: TABLE
            LOCK_MODE: IS
          LOCK_STATUS: GRANTED
            LOCK_DATA: NULL
*************************** 2. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:158:4:3:2835495236984
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 288
        OBJECT_SCHEMA: employees
          OBJECT_NAME: gap
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 2835495236984
            LOCK_TYPE: RECORD
            LOCK_MODE: S
          LOCK_STATUS: GRANTED
            LOCK_DATA: 5
*************************** 3. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:158:4:4:2835495236984
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 288
        OBJECT_SCHEMA: employees
          OBJECT_NAME: gap
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 2835495236984
            LOCK_TYPE: RECORD
            LOCK_MODE: S
          LOCK_STATUS: GRANTED
            LOCK_DATA: 7
            
--上面的都是正常记录锁，可以不看
*************************** 4. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 2835531521376:158:4:5:2835495237328
ENGINE_TRANSACTION_ID: 284310508232032
            THREAD_ID: 274
             EVENT_ID: 289
        OBJECT_SCHEMA: employees
          OBJECT_NAME: gap
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 2835495237328
            LOCK_TYPE: RECORD --行锁，所以类型是record锁
            LOCK_MODE: S,GAP --看这里，Gap锁出现了，S和X没有意义，因为11本身没有被锁
          LOCK_STATUS: GRANTED
            LOCK_DATA: 11 --看GAP锁到底锁到了哪一行？
4 rows in set (0.00 sec)
</code></pre>
<p>看最后我们会发现，明明锁定的id区间是3-8，但最后却锁到了11头上，最后的这个Gap锁意味着，从他以前直到上一条record锁的所有数据都会被锁定，插入操作都会被阻塞</p>
<p>其实是这样，表里的记录有1,5,7,11，而8没有对应的记录，因此它会按照索引向后找到第一个记录（如果没有就不设置Gap锁了），然后给它添加Gap锁也就是11，而这样就代表锁住了 (7,11) 的区间</p>
<p>所以<strong>Gap锁最大的缺点</strong>是，即便我们查询的数据范围并不大，只有3-8，但他却把9,10这两个<strong>无辜的行也占住</strong>了，在事务释放之前不能进行插入操作</p>
<p>想起了上文提到过的记录锁吗</p>
<pre><code class="language-sql">*************************** 2. row ***************************
            LOCK_TYPE: RECORD --这里看到了吗，锁的类型是record
            LOCK_MODE: S,REC_NOT_GAP --模式是S，是record锁而非gap锁（下文介绍）
</code></pre>
<p>我们已经见过的LOCK_MODE的值现在有（X和S暂时不去管他）：</p>
<ul>
<li>S</li>
<li>S,GAP</li>
<li>S,REC_NOT_GAP</li>
</ul>
<p>暂时先放着，等我们把next-key locks讲完就能串起来了</p>
<h3 id="next-key-lock">Next-Key lock</h3>
<p>临键锁，next-key lock = record lock + Gap lock</p>
<p>这玩意在data_locks中都找不到，因为它其实也不是什么物理上的锁，而是一个锁机制，它和Gap一样都是只存在于<strong>可重复读</strong>的隔离级别，它存在的意义是为了<strong>解决幻影读</strong>的问题，让我们接着上面的例子看看</p>
<pre><code class="language-sql">mysql&gt; select * from gap;
+----+------+
| id | name |
+----+------+
|  1 | 张三 |
|  7 | 王五 |
|  8 | 赵四 |
| 11 | 刘能 |
+----+------+
4 rows in set (0.00 sec)

mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from gap where id between 5 and 9 for update; --锁的是5-9
+----+------+
| id | name |
+----+------+
|  7 | 王五 |
|  8 | 赵四 |
+----+------+
2 rows in set (0.03 sec)
</code></pre>
<p>现在id上一共有4个区间 (1,7],(7,8],(8,11],(11,+∞)，看看锁有哪些啊</p>
<pre><code class="language-sql">mysql&gt; SELECT event_id,OBJECT_NAME,index_name,LOCK_TYPE,LOCK_MODE,LOCK_STATUS,LOCK_DATA FROM performance_schema.data_locks;
+----------+-------------+------------+-----------+-----------+-------------+-----------+
| event_id | OBJECT_NAME | index_name | LOCK_TYPE | LOCK_MODE | LOCK_STATUS | LOCK_DATA |
+----------+-------------+------------+-----------+-----------+-------------+-----------+
|       19 | gap         | NULL       | TABLE     | IX        | GRANTED     | NULL      |
|       19 | gap         | PRIMARY    | RECORD    | X         | GRANTED     | 7         |
|       19 | gap         | PRIMARY    | RECORD    | X         | GRANTED     | 8         |
|       19 | gap         | PRIMARY    | RECORD    | X,GAP     | GRANTED     | 11        |
+----------+-------------+------------+-----------+-----------+-------------+-----------+
4 rows in set (0.00 sec)
</code></pre>
<p>我们锁的区间是5-9，但是行锁分别是7，8，11，最后一个Gap锁上面讲过了不再赘述</p>
<p>那么，前面的(5,7)这个是怎么锁的呢？插入下看看</p>
<pre><code class="language-sql">mysql&gt; insert into gap values(6,'随便吧');
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction

mysql&gt; SELECT event_id,index_name,LOCK_TYPE,LOCK_MODE,LOCK_STATUS,LOCK_DATA FROM performance_schema.data_locks; --省略了表名，方便排版
+----------+------------+-----------+------------------------+-------------+-----------+
| event_id | index_name | LOCK_TYPE | LOCK_MODE              | LOCK_STATUS | LOCK_DATA |
+----------+------------+-----------+------------------------+-------------+-----------+
|       11 | NULL       | TABLE     | IX                     | GRANTED     | NULL      |
|       11 | PRIMARY    | RECORD    | X,GAP,INSERT_INTENTION | WAITING     | 7         |
|       19 | NULL       | TABLE     | IX                     | GRANTED     | NULL      |
|       19 | PRIMARY    | RECORD    | X                      | GRANTED     | 7         |
|       19 | PRIMARY    | RECORD    | X                      | GRANTED     | 8         |
|       19 | PRIMARY    | RECORD    | X,GAP                  | GRANTED     | 11        |
+----------+------------+-----------+------------------------+-------------+-----------+
6 rows in set (0.00 sec)
</code></pre>
<p>看看看，插不进去，而且查看锁的时候会发现一个新的event_id，它多出来了个等待中的锁，lock_mode待会讲</p>
<p>为什么6也被阻止了？试试看4</p>
<pre><code class="language-sql">mysql&gt; insert into gap values(4,'随便吧');
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</code></pre>
<p>怎么4也插不进去了？？？？这就是next-lock在起作用了，让我们再看看锁定7-11会怎么样</p>
<pre><code class="language-sql">mysql&gt; select * from gap where id between 7 and 11 for update;
+----+------+
| id | name |
+----+------+
|  7 | 王五 |
|  8 | 赵四 |
| 11 | 刘能 |
+----+------+
3 rows in set (0.04 sec)

mysql&gt; SELECT event_id,index_name,LOCK_TYPE,LOCK_MODE,LOCK_STATUS,LOCK_DATA FROM performance_schema.data_locks;
+----------+------------+-----------+---------------+-------------+------------------------+
| event_id | index_name | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA              |
+----------+------------+-----------+---------------+-------------+------------------------+
|       23 | NULL       | TABLE     | IX            | GRANTED     | NULL                   |
|       23 | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 7                      |
|       23 | PRIMARY    | RECORD    | X             | GRANTED     | supremum pseudo-record |
|       23 | PRIMARY    | RECORD    | X             | GRANTED     | 8                      |
|       23 | PRIMARY    | RECORD    | X             | GRANTED     | 11                     |
+----------+------------+-----------+---------------+-------------+------------------------+
5 rows in set (0.00 sec)
</code></pre>
<p>再插入4呢</p>
<pre><code class="language-sql">mysql&gt; insert into gap values(4,'随便吧');
Query OK, 1 row affected (0.01 sec)
</code></pre>
<p>成功了，why?那个lock_data的<code>supremum pseudo-record</code>是什么？</p>
<p>好的让我们把三个锁串起来看吧，看看上文说的lock_mode的区别，假设有上个记录和当前记录分别是 <code>prev,cur</code></p>
<table>
<thead>
<tr>
<th>LOCK_MODE</th>
<th>锁模式</th>
<th>锁住的范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>next-key lock</td>
<td>(prev,cur]</td>
</tr>
<tr>
<td>X,GAP</td>
<td>gap lock</td>
<td>(prev,cur)</td>
</tr>
<tr>
<td>X,REC_NOT_GAP</td>
<td>record lock</td>
<td>cur</td>
</tr>
</tbody>
</table>
<p>X就代表了一个next-lock锁，他会锁住从它到上一个节点中间的所有记录，和gap非常像，区别是，gap并不会对当前记录加锁，而next-lock会，所以还记得开头怎么说的吗 <code>next-key lock = record lock + Gap lock</code>！</p>
<p>那么它的缺点也是，把本来无辜的数据行也锁住了，比如上面的id=4就插不进去</p>
<p><code>supremum pseudo-record</code> 中文翻译叫做，上限 虚拟记录，很直白，就是一个表示了上限的虚拟记录，当我们锁定7-11的时候，11已经是当前的最大记录了，因此他的后面就是这个虚拟记录，对他加next-key lock就可以保证从11到正无穷的区间都会被锁住</p>
<p><s>总算快讲完了</s></p>
<h3 id="insert-intention-locks">Insert Intention Locks</h3>
<p>插入意向锁，其实和意向锁没关系，他更像是Gap锁的一个分支</p>
<pre><code class="language-sql">|       11 | PRIMARY    | RECORD    | X,GAP,INSERT_INTENTION | WAITING     | 7         |
</code></pre>
<p>这是上文插入时，等待中的锁，这就是个插入意向锁，看他的LOCK_MODE其实和Gap差不多</p>
<p>当有插入操作的时候，他会通过Gap先锁住当前要插入的区间，和Gap不同的是，Gap没有S和X的区别，同一区间的Gap是不会阻塞的，但当Gap变成了插入意向锁的时候就不一样了，因为插入操作一定是个互斥的X锁，所以如果当前区间已经存在了一个Gap锁或者Next-key锁的话他就会被阻塞，也就实现了对区间插入的限制</p>
<h3 id="注意事项">注意事项</h3>
<p>以上所有的测试都是建立在主键或者唯一索引的基础上，如果是个普通索引那么情况会有所不同，但其实区别不大，主要是record锁的区别，当我们通过where能够直接找到记录行的时候</p>
<ul>
<li>如果是通过唯一索引，那么只会有一个record类型的锁，并不会锁住其他区间</li>
<li>如果是普通索引，那么他会给自己添加next-key锁以及它下一个索引记录添加gap锁，人话就是从 (prev,cur]，(cur,next)这两个区间都会被锁（next这个记录要和主键一起才能确定是否被锁）</li>
</ul>
<p>我们知道innoDB是聚簇索引，所以二级索引最终都是通过主键索引去访问数据的，也因此当我们查找到了主键索引后，会给主键索引添加一个record锁（X,REC_NOT_GAP），匹配到几个主键索引就添加几个，不会在主键上添加其他任何锁</p>
<p>如果没有主键？不可能的小伙子，只是你没有显示指出主键而已，要存数据肯定是有个隐式的虚拟主键的</p>
<h2 id="总结">总结</h2>
<p>锁有两种模式，S和X，读写不兼容，表锁行锁都有；</p>
<p>意向锁是为了减少扫描次数，当有IS和IX的时候肯定不能对表加X锁</p>
<p>行锁的本质是record lock，但它只锁具体的行</p>
<p>范围锁Gap的本质是对它下一个索引记录添加行锁（record锁），表示锁住这个区间</p>
<p>next-key锁真的就是record和gap的结合，真的就是这个意思</p>
<p>两章也只是讲了锁，下一章还有个关键内容——MVCC</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql 并发控制详解（一）]]></title>
        <id>http://blog.zerokirin.online/post/mysql-shi-wu-ge-chi-deng-ji-he-suo-xiang-jie-yi/</id>
        <link href="http://blog.zerokirin.online/post/mysql-shi-wu-ge-chi-deng-ji-he-suo-xiang-jie-yi/">
        </link>
        <updated>2021-05-28T19:12:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一致性">一致性</h2>
<p>我们都知道数据库原理中著名的ACID</p>
<ul>
<li>atomicity 原子性</li>
<li>consistency 一致性</li>
<li>isolation 隔离性</li>
<li>durability 持久性</li>
</ul>
<p>这其中一致性是通过原子性和隔离性保证的，如何保证一致性是数据库的最重要的问题，这是一切的开头</p>
<h2 id="并发一致性问题">并发一致性问题</h2>
<p>这里借用下<a href="http://cyc2018.gitee.io/cs-notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86">CS-Notes (gitee.io)</a>的图，图很清楚，但是有几个地方有明显问题</p>
<h3 id="丢失修改">丢失修改</h3>
<p>emmm丢失修改有两类，名字很粗暴的叫做第一类和第二类</p>
<ul>
<li>
<p>第一类丢失修改，当前所有的主流数据库都不允许这件事发生，如果事务A回滚了，那么数据库的最新版本就是1100元</p>
<p>（这个我也不知道数据库是怎么实现的，我已经尽可能地搜了(中-english)，但是都是干巴巴的一句话，说什么即便是最低的读未提交也不会这样，那就把它当个特性吧，反正他已经消失在历史舞台了）</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>取款事务A</th>
<th>转账事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T3</td>
<td>查询账户余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>汇入100元把余额改为1100元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><strong>提交事务</strong></td>
</tr>
<tr>
<td>T7</td>
<td>取出100元把余额改为900元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td><strong>撤销事务</strong></td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>余额恢复为1000 元（<strong>丢失更新</strong>）</td>
<td>（这个不会发生，回滚了也是1100）</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>第二类丢失修改，严格来说这个不能算是数据库自身的bug，更像是不可重复读的一个特殊例子，但也不能算作是不可重复读，这里先描述现象，后面我们再详解</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>转账事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T2</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询账户余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元把余额改为900元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><strong>提交事务</strong></td>
</tr>
<tr>
<td>T7</td>
<td>汇入100元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td><strong>提交事务</strong></td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td><strong>把余额改为1100</strong> <strong>元（丢失更新）</strong></td>
<td>（这个是真的会变成1100，白嫖100）</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="读脏数据">读脏数据</h3>
<figure data-type="image" tabindex="1"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png" alt="img" loading="lazy"></figure>
<h3 id="不可重复读">不可重复读</h3>
<figure data-type="image" tabindex="2"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png" alt="img" loading="lazy"></figure>
<h3 id="幻影读">幻影读</h3>
<table>
<thead>
<tr>
<th style="text-align:left">时间点</th>
<th style="text-align:left">事务A</th>
<th style="text-align:left">事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">开启事务</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"></td>
<td style="text-align:left">开启事务</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">查询数据“老王”，不存在</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"></td>
<td style="text-align:left">插入数据“老王”</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"></td>
<td style="text-align:left">提交事务</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">查询数据“老王”，不存在</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">插入数据“老王”，不成功</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">更新数据“老王”，成功 ？</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">查询数据“老王”，成功 ？</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>官网对幻影读的讲解非常模糊，网上还有很多乱讲的东西，比如什么范围中间插入后，个数发生变化，错</p>
<p>我们先看个例子：</p>
<pre><code class="language-sql">--事务1
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select count(*) from gap;
+----------+
| count(*) |
+----------+
|        4 |
+----------+
1 row in set (0.04 sec)

mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select count(*) from gap;
+----------+
| count(*) |
+----------+
|        4 |
+----------+
1 row in set (0.04 sec)

--事务2
mysql&gt; insert into gap values(8,'老王');
Query OK, 1 row affected (0.05 sec)

--事务1
mysql&gt; select count(*) from gap;
+----------+
| count(*) |
+----------+
|        4 | --没有任何变化
+----------+
1 row in set (0.00 sec)

mysql&gt; select * from gap;
+----+------+
| id | name |
+----+------+
|  1 | 张三 |
|  5 | 李四 |
|  7 | 王五 |
| 11 | 赵6  |
+----+------+
4 rows in set (0.00 sec)
</code></pre>
<p>那么幻读幻到哪去了？继续看</p>
<pre><code class="language-sql">--事务1
mysql&gt; insert into gap values(8,'赵四');
ERROR 1062 (23000): Duplicate entry '8' for key 'gap.PRIMARY'
</code></pre>
<p>看到了么，明明没有查到，但是却没法添加，但他却可以被更新</p>
<pre><code class="language-sql">mysql&gt; update gap set name = '刘能' where id = 8;
Query OK, 1 row affected (0.04 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; select * from gap;
+----+------+
| id | name |
+----+------+
|  1 | 张三 |
|  5 | 李四 |
|  7 | 王五 |
|  8 | 刘能 |
| 11 | 赵6  |
+----+------+
5 rows in set (0.00 sec)
</code></pre>
<p>明明没有的数据，凭空冒了出来这才是幻读，和不可重复读有很大区别。</p>
<h2 id="事务隔离等级">事务隔离等级</h2>
<ul>
<li>read uncommitted   读未提交</li>
<li>read committed   读已提交</li>
<li>repeatable read   可重复读</li>
<li>serializable   串行化</li>
</ul>
<p>从上到下依次严格，每个隔离等级都解决了一个并行问题</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离等级</th>
<th>未解决的并发一致性问题</th>
<th style="text-align:right">解决的并发一致性问题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读未提交</td>
<td>幻影读，不可重复读，读脏数据，第二类丢失修改</td>
<td style="text-align:right">第一类丢失修改</td>
</tr>
<tr>
<td style="text-align:center">读已提交</td>
<td>幻影读，不可重复读，第二类丢失修改</td>
<td style="text-align:right">读脏数据，第一类丢失修改</td>
</tr>
<tr>
<td style="text-align:center">可重复读</td>
<td>幻影读，第二类丢失修改（具体类型具体分析）</td>
<td style="text-align:right">不可重复读，读脏数据，第一类丢失修改</td>
</tr>
<tr>
<td style="text-align:center">串行化</td>
<td></td>
<td style="text-align:right">幻影读，不可重复读，读脏数据，两类丢失修改</td>
</tr>
</tbody>
</table>
<p>暂时先不要关注隔离等级，让我们先了解下实现他们的前置知识——锁和MVCC</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql基础回顾]]></title>
        <id>http://blog.zerokirin.online/post/mysql-ji-chu-hui-gu/</id>
        <link href="http://blog.zerokirin.online/post/mysql-ji-chu-hui-gu/">
        </link>
        <updated>2021-05-16T13:32:23.000Z</updated>
        <content type="html"><![CDATA[<p><s>ORM库用起来是真的爽，面试的时候被问sql也是真的爽，人自闭了重新复习吧</s></p>
<h2 id="增删改查">增删改查</h2>
<h3 id="select">select</h3>
<pre><code class="language-sql">(8)SELECT (9)[ALL|DISTINCT|DISTINCTROW|TOP]
(11){*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]}
(1)FROM &lt;left_table[,…]&gt;
(3)[[{LEFT|RIGHT|INNER|CROSS}] JOIN &lt;right_table&gt; 
(2)	ON &lt;condition&gt;]
(4)[WHERE &lt;where_condition&gt;]
(5)[GROUP BY {col_name | expr | position}, ... (6)[WITH ROLLUP]]
(7)[HAVING &lt;where_condition&gt;]
(10)[ORDER BY {col_name | expr | position} [ASC | DESC]}
</code></pre>
<p>这是一个缩略版的select的解释顺序，括号中的数字代表解释的优先级，可以看到观察到几个点</p>
<ul>
<li>order by，field_list 等的优先级可以说是整个流程的最低级</li>
<li>group by 和 having 比where的优先级要低，也就是说所有的分组操作都是来源于where筛选后的结果</li>
<li>having做的是对分组后的结果集的再次查询，因此应该先使用where过滤，比如说找到非A用户的登录记录，筛选条件是可以放到having后的，但是A用户已经被分组了，同时参与了count等运算，只是最后剔除了这一组，所以说having可以看作是where的补充，能不用就不用</li>
<li>group by 和 order by 都支持position，也就是下标访问，不过是从1开始的，数组就是field_list</li>
</ul>
<h3 id="insert">insert</h3>
<p>insert into 有三种写法，官网的语句太复杂了，简化一下</p>
<ul>
<li>
<p>一种就是最基础的</p>
<pre><code class="language-sql">INSERT INTO tbl_name [(a,b,c)] VALUES (1,2,3)[, (4,5,6), (7,8,9)];
--或者是
INSERT INTO tbl_name [(a,b,c)] VALUES ROW(1,2,3)[, ROW(4,5,6), ROW(7,8,9)];
</code></pre>
<p>table后面可选择列名，如果不选的话，values后面每个括号中的内容都要按字段顺序填入</p>
<p>多个括号就是批量插入的意思</p>
</li>
<li>
<p>这种是用set代替了values</p>
<pre><code class="language-sql">INSERT INTO
	friend
SET
	name = 'Kim',
	isBFF = true
;
</code></pre>
<p>用法和普通的一样，类似于update语句，个人感觉更符合直觉一点，但是不支持批量插入</p>
</li>
<li>
<p>比较特殊的，从另一个表搜索数据然后插入</p>
<pre><code class="language-sql">INSERT INTO tbl_temp2 (fld_id)
  SELECT tbl_temp1.fld_order_id
  FROM tbl_temp1 WHERE tbl_temp1.fld_order_id &gt; 100;
  
--8.0.19版本后支持用table字段替代select
INSERT INTO ta TABLE tb; --select * from tb;支持limit和order by
</code></pre>
</li>
</ul>
<p>insert的特殊用法</p>
<ul>
<li>
<p>插入的行的主键已经存在 <code>ON DUPLICATE KEY UPDATE</code> ，存在就更新，大概有三种用法</p>
<pre><code class="language-sql">--可以引用a，b列的值，类似于分别设置c=1+2和c=4+5
INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6) ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);
--8.0.19版本后增加了AS关键字，可以通过表名来引用行
INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6) AS new ON DUPLICATE KEY UPDATE c = new.a+new.b;
--更骚的是还支持指定列名
INSERT INTO t1 SET a=1,b=2,c=3 AS new(m,n,p) ON DUPLICATE KEY UPDATE c = m+n;
--如果是插入，影响条数1，更新是2，内容不变的话是0
--这个用法在insert into select中也是可以的，其实就是把values...这部分换成了select...只放例子不再赘述
INSERT INTO t1
  SELECT * FROM (SELECT c, c+d AS e FROM t2) AS dt
  ON DUPLICATE KEY UPDATE b = e; --insert ...select语句的update部分不能使用VALUES()会报错
</code></pre>
</li>
<li>
<p>insert开头的可选项</p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>已存在</strong></th>
<th><strong>不存在</strong></th>
<th><strong>举例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>insert</td>
<td>报错</td>
<td>插入</td>
<td>insert into names(name, age) values(“小明”, 23);</td>
</tr>
<tr>
<td>insert ignore</td>
<td>忽略</td>
<td>插入</td>
<td>insert ignore into names(name, age) values(“小明”, 24);</td>
</tr>
<tr>
<td>replace</td>
<td>替换</td>
<td>插入</td>
<td>replace into names(name, age) values(“小明”, 25);</td>
</tr>
</tbody>
</table>
<p>重点看第三个，replace和on duplicate key的区别</p>
<ul>
<li>如果主键不存在，都是insert，无区别</li>
<li>如果存在，replace是真的delete后再insert，原有数据被清空，因此新行的值要写全不然会置零</li>
<li>on duplicate key是只更新update后面描述的结果，不是删除插入</li>
</ul>
</li>
</ul>
<h3 id="delete">delete</h3>
<p>这个没什么好说的用法不多基础语法如下：</p>
<pre><code class="language-sql">--删除一个表的数据
DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name [[AS] tbl_alias]
    [PARTITION (partition_name [, partition_name] ...)] --这里是分区
    [WHERE where_condition]
    [ORDER BY ...]
    [LIMIT row_count]
    
--多个表一起删或者作为辅助查询，下面两个用法一样，只是写法不同
DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    tbl_name[.*] [, tbl_name[.*]] ...
    FROM table_references --此处的写法和select中的join一样，支持各种join
    [WHERE where_condition]
--实例1. 
DELETE t1, t2 FROM t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id;

DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    FROM tbl_name[.*] [, tbl_name[.*]] ...
    USING table_references
    [WHERE where_condition]
--实例2.
DELETE FROM t1, t2 USING t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id; --没啥子区别，join部分一模一样

--比较实用的例子，从t1中删掉t2没有的行
DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;
</code></pre>
<h3 id="update">update</h3>
<p>最朴实无华的语法（非官方定义）</p>
<pre><code class="language-sql">UPDATE Tab1, [Tab2, [INNER JOIN | LEFT JOIN] Tab1 ON Tab1.C1 = Tab2.C1]  
SET Tab1.C2 = [Tab2.C2, Tab2.C3 =] expression  
WHERE Condition;  
</code></pre>
<p>如果只更新一个表就很简单，直接再set后面写出谁等于谁就好</p>
<pre><code class="language-sql">UPDATE t SET id = id + 1 ORDER BY id DESC; --这里用了orderby desc是因为，如果升序来，会先把1-&gt;2，这样就有两个2的记录了，违反了主键约束原则，因此降序更新
</code></pre>
<p>多个表的例子（多表时不能用order by 和limit）</p>
<pre><code class="language-sql">UPDATE items,month SET items.price=month.price WHERE items.id=month.id; --这里默认是inner join
</code></pre>
<p>左连接例子</p>
<pre><code class="language-sql">UPDATE Employees e LEFT JOIN Performance p   
ON e.performance = p.performance  
SET salary = salary + salary * 0.025  
WHERE p.percentage IS NULL;  
</code></pre>
<p>需要注意的一个问题是，update中where的子语句不能直接使用当前表的结果，例如：</p>
<pre><code class="language-sql">mysql&gt; UPDATE items
     &gt; SET retail = retail * 0.9
     &gt; WHERE id IN
     &gt;     (SELECT id FROM items
     &gt;         WHERE retail / wholesale &gt;= 1.3 AND quantity &gt; 100);
ERROR 1093 (HY000): You can't specify target table 'items' for update in FROM clause
</code></pre>
<p>需要将子查询移到一个新的派生表中</p>
<pre><code class="language-sql">UPDATE items,
       (SELECT id FROM items
        WHERE id IN
            (SELECT id FROM items
             WHERE retail / wholesale &gt;= 1.3 AND quantity &lt; 100))
        AS discounted
SET items.retail = items.retail * 0.9
WHERE items.id = discounted.id;
</code></pre>
<h2 id="数据类型">数据类型</h2>
<p>数据分为数值类型，字符串类型，时间类型，空间类型</p>
<h3 id="数值类型">数值类型</h3>
<h4 id="整型">整型</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left">1 byte</td>
<td style="text-align:left">(-128，127)</td>
<td style="text-align:left">(0，255)</td>
<td style="text-align:left">小整数值</td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left">2 bytes</td>
<td style="text-align:left">(-32 768，32 767)</td>
<td style="text-align:left">(0，65 535)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMINT</td>
<td style="text-align:left">3 bytes</td>
<td style="text-align:left">(-8 388 608，8 388 607)</td>
<td style="text-align:left">(0，16 777 215)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">INT或INTEGER</td>
<td style="text-align:left">4 bytes</td>
<td style="text-align:left">(-2 147 483 648，2 147 483 647)</td>
<td style="text-align:left">(0，4 294 967 295)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">8 bytes</td>
<td style="text-align:left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td style="text-align:left">(0，18 446 744 073 709 551 615)</td>
<td style="text-align:left">极大整数值</td>
</tr>
</tbody>
</table>
<p>借用菜鸟的表格，可以看到每种类型的大小已经固定了，而在类型声明的时候有可能会有这种情况</p>
<pre><code class="language-sql">CREATE TABLE test(
    id1 int(1),
    id2 tinyint(1)
);
</code></pre>
<p>这里内的值我们暂时称为M，M表示的意思就是实际的显示位数，但是<strong>上述写法是没有意义的</strong>，因为int和tinyint本身的长度是已经确定的，加括号的真正写法是</p>
<pre><code class="language-sql">CREATE TABLE test(
    int_test_M int(3) ZEROFILL,
);
</code></pre>
<p>只有用zerofill 修饰才有意义，加了zerofill后，会默认添加unsigned参数，也就是变成无符号数（非负数）</p>
<pre><code class="language-sql">mysql&gt; desc test1;
+------------+--------------------------+------+-----+---------+-------+
| Field      | Type                     | Null | Key | Default | Extra |
+------------+--------------------------+------+-----+---------+-------+
| int_test_M | int(3) unsigned zerofill | YES  |     | NULL    |       |
+------------+--------------------------+------+-----+---------+-------+
1 row in set (0.02 sec)

mysql&gt; select * from test1;
+------------+
| int_test_M |
+------------+
|        001 | --这里吧一位的长度补足了
|       1111 | --没啥用了
+------------+
2 rows in set (0.00 sec)
</code></pre>
<blockquote>
<p>As of MySQL 8.0.17, the <code>ZEROFILL</code> attribute is deprecated for numeric data types; you should expect support for it to be removed in a future version of MySQL. Consider using an alternative means of producing the effect of this attribute. For example, applications could use the <a href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad"><code>LPAD()</code></a> function to zero-pad numbers up to the desired width, or they could store the formatted numbers in <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>CHAR</code></a> columns.</p>
</blockquote>
<p>官方文档已经说了zerofill这玩意已经快废弃了，就别用这种骚操作了</p>
<p>另外还有两个整数型</p>
<ul>
<li>
<p><strong>BIT[(M)]</strong>  表示Mbits的数据大小，默认M为1，存储二进制数据，长度就是M，超过了大小则无法插入</p>
</li>
<li>
<p><strong>BOOL/BOOLEAN</strong> 本质上是TINYINT(1)，1是<code>'true'</code> 0是<code>'false'</code>，其他的值既不是true也不是false</p>
</li>
</ul>
<h4 id="浮点数">浮点数</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">4 bytes</td>
<td style="text-align:left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td style="text-align:left">单精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">8 bytes</td>
<td style="text-align:left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">双精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">小数值</td>
</tr>
</tbody>
</table>
<p>先说float和double，这是最常见的单精度和双精度浮点数，这里我们在M的基础上引入D，M说过了就是位数，D则代表了小数点后的位数，默认情况下float的D是7，double的D是15</p>
<p>这里float还有个特殊的骚操作，float[p]，用p代替了DM，p在0-24时当作float，25-53时当作double</p>
<p>但是给float和double指定精度的操作都是mysql特有的，并不是sql标准语法，并且官方文档已经说明，从8.0.17开始将不再建议此写法，同时有可能在未来的版本中删除，因此不要写这种奇奇怪怪的东西了，又不方便拓展又不能节省空间，何必呢</p>
<p>这里再说下<strong>DECIMAL</strong>，这个类型和float，double<strong>完全不一样</strong>，默认情况下他的(M,D)是(10,0)，M最大支持65，D最大30，千万不要把他理解成double，这是<strong>完全不一样</strong>的类型，众所周知，计算机内浮点数的存储方式和整型不一样，因为阶码和尾数的存在永远只能近似，但是DECIMAL<strong>完全不一样</strong>（三遍）</p>
<p>DECIMAL的英文含义就是十进制，因此它的存储结构和他的名字类似</p>
<table>
<thead>
<tr>
<th style="text-align:center">数位</th>
<th style="text-align:center">字节</th>
<th style="text-align:center">最大值（有符号）</th>
<th style="text-align:center">最大值位数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1-2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">127</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3-4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">32767</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">5-6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">8388607</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">7-9</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2147483647</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
<p>这样，每一个位数的最大值9999999都可以被他的空间完全表示出来，位数逢十进一，每10位占4个字节，整数和小数分开存储，举个例子，decimal(26,14)，小数14位，9+5，所以需要4+3=7字节大小存储小数，整数12位，9+3，也就是4+2=6字节存储，一共6+7=13字节大小</p>
<p>通过这种饱和式的存储方式，可以实现真正意义上的精度，再也不会有<code>1-0.0000000001!=0.9999999999</code>的情况出现，当然缺点就是存储空间大，但如果不是非要用那么大的精度的话，其实还好</p>
<p>当然这个类型也支持unsigned和zerofill，但是同样在8.0.17后已经不被推荐了，以后少用</p>
<h3 id="字符串类型">字符串类型</h3>
<p>字符串类型也大概可以分成两类，字符串和二进制字符串，当然还有一类比较特殊的ENUM和SET，我们先讲这两个</p>
<h4 id="enum-枚举set-集合">ENUM 枚举，SET 集合</h4>
<p>共同点：</p>
<ul>
<li>虽然显示格式是字符串，但是实际上存储的是其定义时的索引位置</li>
<li>直接插入整型变量的时候会当作索引</li>
<li>如果插入的字符串变量不在声明之中，会尝试将其索引化</li>
<li>空值是null，''是一个合法的值，代表着索引0的值，不是null</li>
</ul>
<p>区别就是ENUM只能存定义里的其中一个，SET是存任意多个</p>
<p>在存储上，ENUM只需要存储对应字符串的索引即可，最多支持65535个可选项，因此索引值最大也就是65535，正好是2Bytes的存储上限</p>
<p>而SET，集合就不一样了，集合有很多操作，比如交并补，因此set中子项的保存形式是以二进制字符串中1的位置来确定的，<code>SET('a','b','c','d')</code> 的索引值如下表</p>
<table>
<thead>
<tr>
<th style="text-align:left"><code>SET</code> Member</th>
<th style="text-align:left">Decimal Value</th>
<th style="text-align:left">Binary Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>''</code></td>
<td style="text-align:left"><code>0</code></td>
<td style="text-align:left"><code>0000</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'a'</code></td>
<td style="text-align:left"><code>1</code></td>
<td style="text-align:left"><code>0001</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'b'</code></td>
<td style="text-align:left"><code>2</code></td>
<td style="text-align:left"><code>0010</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'c'</code></td>
<td style="text-align:left"><code>4</code></td>
<td style="text-align:left"><code>0100</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'d'</code></td>
<td style="text-align:left"><code>8</code></td>
<td style="text-align:left"><code>1000</code></td>
</tr>
</tbody>
</table>
<p>这样集合的交并补就变成了两个二进制数的与或非操作</p>
<p>SET最大支持64个子项，也就是最大8Bytes，具体的字节数为 (N+7)/8四舍五入</p>
<p>在匹配的时候可以使用函数FIND_IN_SET()也可以用 like '%value%'</p>
<h4 id="字符串和二进制字符串">字符串和二进制字符串</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CHAR(M)</td>
<td style="text-align:left">0-255 个字符</td>
<td style="text-align:left">定长字符串</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR(M)</td>
<td style="text-align:left">取决于整行的大小</td>
<td style="text-align:left">变长字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYBLOB</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYTEXT</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">短文本字符串</td>
</tr>
<tr>
<td style="text-align:left">BLOB(M)</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:left">TEXT(M)</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">长文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMBLOB</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMTEXT</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGBLOB</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGTEXT</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">极大文本数据</td>
</tr>
</tbody>
</table>
<p><s>表是从菜鸟拿的，错得离谱。。。</s></p>
<h5 id="先从老生常谈的char与varchar说起">先从老生常谈的char与varchar说起</h5>
<ul>
<li>
<p>char</p>
<p>char是固定长度字符串，一般用法是char(M)，如果省略M，默认值1最大长度255，早在5.0以后M就不是字节了，M代表的是字符，菜鸟这么多年都没改过表格吗。。。</p>
<p>一个utf8编码下的中文字符占了3个字节，256*3=768字节，这才是CHAR的标准上限，但是如果使用utf8mb4过长的编码格式，就会超过768字节，innoDB会将多余的字节存到其他位置，所以只要是5.0版本以后就根本不需要care字节数的问题</p>
<p>存储时如果不足M长度，自动在末尾补' '填充，这也是为啥char类型的末尾' '会消失</p>
</li>
<li>
<p>varchar</p>
<p>varchar和char的区别不只是可变长度，其存储结构也不一样</p>
<p>在varchar中开头需要预留1或者2个字节作为长度的值，分别能表示255和65535个字节的长度，但这是字节数的理论上限，M的范围呢？</p>
<p>在innoDB中要求每一行一共能存储65535字节大小的数据，这是所有列共享的，因此M的大小还受到其他的列的影响，假如只有一列，那么一个中文字符大小3个字节，算上开头的两个表示长度的字节，一个NULL标记字节，65535-2-1=65532，65532/3=21844，这就是M在这种情况下的理论最大值</p>
<p>可以看到这个值是很不稳定的，因为还要考虑其他的列，因此不建议设这么大</p>
</li>
</ul>
<h5 id="binary和varbinar">BINARY和VARBINAR</h5>
<p>这俩和char，varchar非常相似，几乎一样，官方文档直说区别仅仅是保存的二进制字符串而已，不再赘述</p>
<h5 id="剩下的主要就是blob和text">剩下的主要就是BLOB和TEXT</h5>
<p>在mysql的官方文档中，可以看到它和varchar与varbinary十分类似</p>
<blockquote>
<p>In most respects, you can regard a <code>BLOB</code> column as a <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>VARBINARY</code></a> column that can be as large as you like. Similarly, you can regard a <code>TEXT</code> column as a <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a> column. <code>BLOB</code> and <code>TEXT</code> differ from <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>VARBINARY</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a> in the following ways:</p>
<ul>
<li>For indexes on <code>BLOB</code> and <code>TEXT</code> columns, you must specify an index prefix length. For <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>CHAR</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a>, a prefix length is optional. See <a href="https://dev.mysql.com/doc/refman/8.0/en/column-indexes.html">Section 8.3.5, “Column Indexes”</a>.</li>
<li><code>BLOB</code> and <code>TEXT</code> columns cannot have <code>DEFAULT</code> values.</li>
</ul>
</blockquote>
<p>主要的区别就是TEXT和BLOB需要指定前缀位数作为索引，不可以设置默认值</p>
<p>他们的存储方式取决于<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-dynamic">InnoDB Row Formats</a>， 在mysql5.7.9以后默认是dynamic</p>
<p>我们暂且只介绍dynamic模式，在这种存储方式下，数据会尽可能的填充满整个行，但不是我们所谓的65535的上限值，官方提供了一个例子</p>
<pre><code class="language-sql">mysql&gt; CREATE TABLE t4 (
       c1 CHAR(255),c2 CHAR(255),c3 CHAR(255),
       c4 CHAR(255),c5 CHAR(255),c6 CHAR(255),
       c7 CHAR(255),c8 CHAR(255),c9 CHAR(255),
       c10 CHAR(255),c11 CHAR(255),c12 CHAR(255),
       c13 CHAR(255),c14 CHAR(255),c15 CHAR(255),
       c16 CHAR(255),c17 CHAR(255),c18 CHAR(255),
       c19 CHAR(255),c20 CHAR(255),c21 CHAR(255),
       c22 CHAR(255),c23 CHAR(255),c24 CHAR(255),
       c25 CHAR(255),c26 CHAR(255),c27 CHAR(255),
       c28 CHAR(255),c29 CHAR(255),c30 CHAR(255),
       c31 CHAR(255),c32 CHAR(255),c33 CHAR(255)
       ) ENGINE=InnoDB ROW_FORMAT=DYNAMIC DEFAULT CHARSET latin1;
ERROR 1118 (42000): Row size too large (&gt; 8126). Changing some columns to TEXT or BLOB may help.
In current row format, BLOB prefix of 0 bytes is stored inline.
</code></pre>
<p>算算字节数，255*33=8415这点字节还远不到65535，但是却提示超过了8126，这个数是哪来的呢？</p>
<p>原来65535是mysql层判断的，实际存储的时候还需要存储引擎去判断，innoDB的策略是略小于存储页面大小的一半，默认的页面大小是16KB，它的一半就是8192，因此在innoDB看来最大行不能超过8126字节，这样上限我们就搞清楚了</p>
<p>TEXT与BLOB类型都会尽可能的存在这一行中，也就是B+树的叶子节点中，当长度已经满了的时候，会从所有的字段中选择最长的一列放到外部存储，dynamic的思想是，如果要用外部页面存储，就把整个数据都放过去，页内只留20字节的指针指向外部存储，对于长度小于40字节的TEXT和BLOB，并不会转移到外部，而是直接存在行内</p>
<p>BLOB和TEXT都支持M的用法（但是真的别用了，挺没意义的，都已经用这个类型了还纠结长度不如取用varchar，人家速度还快），如果用了M，会返回一个能满足M的要求的最小的预定义的TEXT或BLOB，举个例子：</p>
<pre><code class="language-sql">mysql&gt; alter table test1 add text_test text(20);
mysql&gt; desc test1;
+----------------+--------------------------+------+-----+---------+-------+
| Field          | Type                     | Null | Key | Default | Extra |
+----------------+--------------------------+------+-----+---------+-------+
| int_test_M     | int(3) unsigned zerofill | YES  |     | NULL    |       |
| bit_test_M     | bit(3)                   | YES  |     | NULL    |       |
| decimal_test_M | decimal(65,0)            | YES  |     | NULL    |       |
| binary_test    | binary(6)                | YES  |     | NULL    |       |
| set_test       | set('1','一')            | YES  |     | NULL    |       |
| text_test      | tinytext                 | YES  |     | NULL    |       |
+----------------+--------------------------+------+-----+---------+-------+
6 rows in set (0.02 sec)
</code></pre>
<p>可以看到，text_test并没有像其他的一样有M，而是直接分配了一个tinytext，blob同理，至此字符串基本上讲完了</p>
<h3 id="时间类型">时间类型</h3>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小 ( bytes)</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1000-01-01/9999-12-31</td>
<td style="text-align:left">YYYY-MM-DD</td>
<td style="text-align:left">日期值</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">3</td>
<td style="text-align:left">'-838:59:59'/'838:59:59'</td>
<td style="text-align:left">HH:MM:SS</td>
<td style="text-align:left">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1901/2155</td>
<td style="text-align:left">YYYY</td>
<td style="text-align:left">年份值</td>
</tr>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">8</td>
<td style="text-align:left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td style="text-align:left">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:left">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">4</td>
<td style="text-align:left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07，本质是一个存着时间戳的四字节整型</td>
<td style="text-align:left">YYYYMMDD HHMMSS</td>
<td style="text-align:left">混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<p>datetime和timestamp有个区别就是，当存入数据库的时候，datetime存储的是当前时区的时间，而时间戳是全球统一的，无需担心时区的问题</p>
<ul>
<li>8.0.19版本开始，可以在datetime和timestamp类型修改的时候添加时间偏移量</li>
<li>8.0.22版本开始，支持通过CAST()函数将timestamp转换成特定时区的datetime值</li>
</ul>
<p>举两个魔改的官方例子解释</p>
<pre><code class="language-sql">mysql&gt; SELECT @@system_time_zone; --提示了系统时区，现在是EST，北美东部标准时间，-05:00，我国是+08:00
+--------------------+
| @@system_time_zone |
+--------------------+
| EST                |
+--------------------+

mysql&gt; CREATE TABLE ts (
    -&gt;     id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -&gt;     col TIMESTAMP NOT NULL
    -&gt; ) AUTO_INCREMENT = 1;

mysql&gt; SET @@time_zone = 'SYSTEM'; -- -05:00

mysql&gt; INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');
--这里插入了三个，后两个的含义是，当前时区为+05:30的10.10.10，和当前时区-08:00的10.10.10，如果转换成UTC，分别应该-5.30和+8.00，但和第一个值明显对不上，原因看下一个

mysql&gt; SET @@time_zone = '+00:00';

mysql&gt; INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00'); 
--这里已经将时区切换成标准UTC时间了，再让我们看看结果，下面的23和56都是一样的，也就是说，当我们手动添加时区的偏移量的时候，会屏蔽掉设置的时区 


mysql&gt; SET @@time_zone = 'SYSTEM';
--这里又切换回了-5的时区，导致UTC时间的10.10.10，在显示的时候按照-5的时区显示，变成了05.10.10

mysql&gt; SELECT col, UNIX_TIMESTAMP(col) FROM ts ORDER BY id;
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 | --这里代表了-5:00的时区下的时间
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 05:10:10 |          1577873410 | --这里才是真实的UTC标准时间
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
+---------------------+---------------------+


mysql&gt; CREATE TABLE dt (
    -&gt;     id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -&gt;     col DATETIME NOT NULL
    -&gt; ) AUTO_INCREMENT = 1;

mysql&gt; INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');

mysql&gt; SET @@time_zone = '+00:00';

mysql&gt; INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');
--从这里的1，4可以看到，不管在哪个时区下，datetime的值只取决于获取时的时间，不随时区变化而改变
--但是一旦手动设置了偏移量，偏移量的大小都会先计算一次时区偏移，比如23的结果，都是在10.10.10的基础上-5，然后再-05.30和+08.00
--也就是说它老把自己当成UTC时间，手动改修改偏移量后然后自作聪明的想存进该时区时间，所以会先算一次时区，再计算时间戳

mysql&gt; SET @@time_zone = 'SYSTEM';

mysql&gt; SELECT col, UNIX_TIMESTAMP(col) FROM dt ORDER BY id;
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 10:10:10 |          1577891410 |
| 2020-01-01 04:40:10 |          1577871610 |
| 2020-01-01 18:10:10 |          1577920210 |
+---------------------+---------------------+
</code></pre>
<p>可以看到，timestamp和datetime在面对不一样的时区时做的操作是完全不同的，相比之下timestamp更通用一些</p>
<p>timestamp和datetime还支持自动更新</p>
<pre><code class="language-sql">created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP --创建时间
updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP --更新时间
</code></pre>
<p>至此时间类型也差不多讲完了，空间类型这个是真的一般用不到，等用到了再细究不迟，这里就不再赘述了，现在才发现其实mysql的官方文档才是最好的教程，远比网上搜的东西清楚</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在github上开源自己的包]]></title>
        <id>http://blog.zerokirin.online/post/ru-he-zai-github-shang-kai-yuan-zi-ji-de-bao/</id>
        <link href="http://blog.zerokirin.online/post/ru-he-zai-github-shang-kai-yuan-zi-ji-de-bao/">
        </link>
        <updated>2021-05-07T14:46:53.000Z</updated>
        <content type="html"><![CDATA[<p>由于go没有自带的栈结构，因此我们手写了两种stack方便刷题及日后使用，顺便尝试下开源</p>
<p>由于栈有切片和链表两种实现方式，因此仓库内有两个package，此时有两种发布方式</p>
<h3 id="1-将两个package当作一个module发布">1. 将两个package当作一个module发布</h3>
<p>此时只要在根目录上创建go.mod文件，文件内容如下</p>
<pre><code>module github.com/00LT00/go-stack

go 1.15
</code></pre>
<p>这样我们的module根目录地址就是<code>github.com/00LT00/go-stack</code></p>
<p>此时总文件结构</p>
<pre><code>│  go.mod
│  README.md
│
├─nodelistStack
│      stack.go
│      stack_test.go
│
└─sliceStack
        stack.go
        stack_test.go
</code></pre>
<p>下属的nodelistStack和sliceStack作为go-stack这个module的子package存在</p>
<pre><code class="language-go">import &quot;github.com/00LT00/go-stack&quot;
</code></pre>
<p>此时go.mod文件中会有版本号，和最后一次提交的时间与md5相关</p>
<p>当然也可以打tag，或者通过github release发布一个新的版本，比如现在的最新版就是</p>
<pre><code class="language-go">require github.com/00LT00/go-stack v0.4.0 // 根目录下没有package有可能会报错，应手动写入go.mod中
</code></pre>
<p>当然只是引入了go-stack是肯定不能用的，毕竟根目录下毛都没有，要想用肯定要引入两个package之一</p>
<pre><code class="language-go">import (
	stack1 &quot;github.com/00LT00/go-stack/sliceStack&quot;
	stack2 &quot;github.com/00LT00/go-stack/nodelistStack&quot;
)
</code></pre>
<p>这样的不足之处在于两者依赖同一个tag，如果对其中一个进行修改，打出来的新tag对两个都会生效，因此还有第二种方式</p>
<h3 id="2-发布两个不一样的module">2. 发布两个不一样的module</h3>
<p>文件结构如下</p>
<pre><code>│  README.md
│
├─nodelistStack
|	   go.mod
│      stack.go
│      stack_test.go
│
└─sliceStack
		go.mod
        stack.go
        stack_test.go
</code></pre>
<p>两个go.mod文件开头就自由发挥</p>
<pre><code>module github.com/00LT00/go-stack/nodelistStack

go 1.15
</code></pre>
<pre><code>module github.com/00LT00/go-stack/sliceStack

go 1.15
</code></pre>
<p>这时可以通过github release 发布不同的版本号解决问题</p>
<figure data-type="image" tabindex="1"><img src="https://files.catbox.moe/lurk0v.png" alt="image-20210508002249201" loading="lazy"></figure>
<p>这里就给子目录单独创建了一个版本号 v0.1.3</p>
<p>虽然引用方式和之前没有任何变化，仍然是</p>
<pre><code class="language-go">import (
	stack2 &quot;github.com/00LT00/go-stack/nodelistStack&quot;
)
</code></pre>
<p>但是go.mod文件中已经发生了变化</p>
<pre><code>require github.com/00LT00/go-stack/nodelistStack v0.1.3
</code></pre>
<p>此时这就是一个单独的module，自己管理自己的package，这样的好处是，可以单独对两个目录发布不一样的版本</p>
<figure data-type="image" tabindex="2"><img src="https://files.catbox.moe/p3rjem.png" alt="image-20210508003849181" loading="lazy"></figure>
<p>可以参考<a href="https://golang.org/ref/mod#vcs-version">go mod 官方文档</a></p>
<blockquote>
<p>If a module is defined in a subdirectory within the repository, that is, the module subdirectory portion of the module path is not empty, then each tag name must be prefixed with the module subdirectory, followed by a slash. For example, the module golang.org/x/tools/gopls is defined in the gopls subdirectory of the repository with root path golang.org/x/tools. The version v0.4.0 of that module must have the tag named gopls/v0.4.0 in that repository.</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 运行时（一）]]></title>
        <id>http://blog.zerokirin.online/post/golang-yun-xing-shi-yi/</id>
        <link href="http://blog.zerokirin.online/post/golang-yun-xing-shi-yi/">
        </link>
        <updated>2021-04-23T16:36:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="内存分区">内存分区</h2>
<p>一个应用程序在运行的时候会分出对应的区域</p>
<ol>
<li>
<p>text 代码区</p>
<p>用于存放cpu执行的机器指令，只读</p>
</li>
<li>
<p>data 数据区</p>
<ul>
<li>初始化后的全局变量</li>
<li>初始化后的静态变量（包括全局和局部）</li>
<li>常量</li>
</ul>
</li>
<li>
<p>bss 未初始化区</p>
<ul>
<li>未初始化的全局变量</li>
<li>未初始化的静态变量</li>
</ul>
<p>尽管会被默认分配为零值，但仍属于未初始化区</p>
</li>
<li>
<p>stack 栈区</p>
<p>由编译器自动分配释放的，一般用于存储哈描述的参数值、返回值、局部变量等。一般只有1M，可自动扩充，基本上也就是函数运行的空间，所以无限递归会造成的是栈溢出</p>
<p>分配的方式是从高地址向低地址</p>
</li>
<li>
<p>heap 堆区</p>
<p>由程序员手动分配，手动回收或者较高级语言有GC自动回收</p>
<p>分配的地址是在栈区地址和.bss区之间</p>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://github.com/overnote/over-golang/raw/master/images/go/runtime-02.svg" alt="img" loading="lazy"></figure>
<h2 id="逃逸分析">逃逸分析</h2>
<pre><code class="language-go">func toHeap() *int {
	var x int
	return &amp;x
}

func toStack() int {
	y := new(int)
	*y = 1
	return *y
}

func main() {

}
</code></pre>
<p>如果我们暂时忘记go，用C/C++语言的思维来看，上述的<code>toHeap()</code>函数就是一个典型的空指针错误，在函数内部创建了一个变量，调用结束后将指针返回，而该地址是随着函数的调用而被分配在函数栈上的，因此当调用结束后栈会被清空，该指针就成了一个野指针。而对于<code>toStack</code>函数来说，手动使用new从堆上分配了一块变量，直到使用对应的delete函数手动释放空间</p>
<p>但是在go中，情况完全不同，go在一定程度上消除了堆栈的区别，在编译的时候会自动进行<strong>逃逸分析</strong>，将逃逸的对象放到堆上，不逃逸的对象放到栈上</p>
<p>由于x是返回值，而这个指针会被函数外部进行操作，从外部是可以找到这个变量的，因此就可以说是变量逃逸</p>
<p>第一种情况就可以说发生了逃逸，go会在编译阶段将x放到堆上，而y在函数结束后就无法访问了，因此分配到栈上，随着函数结束而消失</p>
<p>Go的GC判断变量是否回收的实现思路：从每个包级的变量、每个当前运行的函数的局部变量开始，通过指针和引用的访问路径遍历，是否可以找到该变量，如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响后续计算结果。</p>
<h3 id="逃逸案例">逃逸案例</h3>
<ol>
<li>
<p>指针逃逸</p>
<pre><code class="language-go">func f() *int{
    var i int
    i = 1
    return &amp;i
}
</code></pre>
</li>
<li>
<p>局部变量大小过大</p>
<pre><code class="language-go">s := make([]int, 0, 10000)//其实就是stack区不够分了，所以分到heap上
</code></pre>
</li>
<li>
<p>动态类型逃逸</p>
<pre><code class="language-go">cap:= 20
s := make([]int, 0, cap) //大小是动态的，不能确定，因此放入heap
</code></pre>
</li>
<li>
<p>闭包引用逃逸</p>
<pre><code class="language-go">//闭包函数在这里声明了两个隐式变量a，b，当f()被多次调用的时候，其使用的是被Fibonacci()创建出来大的时候的a，b，因此a，b不会随着f()函数的结束而小时，因此会被分配到heap
func Fibonacci() func() int { 
    a, b := 0, 1
	return func() int {
		a, b = b, a+b
		return a
	}
}

f:= Fibonacci()
</code></pre>
</li>
<li>
<p>切片，map逃逸</p>
<pre><code class="language-go">i := 1
s := make([]*int, 0, 10) //m没有被转移给其他的函数调用，也没有分配过大的空间，也不是全局变量，因此没有必要分配到heap上
s = append(s, &amp;i) //i被添加到m中，没有人知道什么时候会用到，因此无论有没有被用到，都会分配到heap上

j := 1
m := make(map[int]*int) //一个道理，也是分配在stack上
m[1] = &amp;j //heap上
</code></pre>
</li>
</ol>
<h3 id="分配位置的原则">分配位置的原则</h3>
<ul>
<li>变量是否被取地址</li>
<li>变量是否发生逃逸</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang基础语法题]]></title>
        <id>http://blog.zerokirin.online/post/golang-ji-chu-yu-fa-ti/</id>
        <link href="http://blog.zerokirin.online/post/golang-ji-chu-yu-fa-ti/">
        </link>
        <updated>2021-04-17T12:10:32.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>使用值为nil的slice、map会发生啥？</p>
<p>slice可以正常添加内容，map会报错，需要通过make分配地址</p>
<pre><code class="language-go">// map 错误示例
func main() {
    var m map[string]int
    m[&quot;one&quot;] = 1  // error: panic: assignment to entry in nil map
    // m := make(map[string]int)// map 的正确声明，分配了实际的内存
}    
 
// slice 正确示例
func main() {
 var s []int
 s = append(s, 1)
}
</code></pre>
<p>再往细了说，slice底层用指针维护了一个数组，无论是empty还是nil都可以通过append进行扩容，毕竟append强制返回一个原类型的结构，但是map的底层是一个叫做hmap的东西，非常复杂，需要通过makemap这个函数进行初始化才能进行使用（比如说最起码得给人一个hash函数不是）因此对着nil直接赋值是不现实的</p>
</li>
<li>
<p>map中key是否存在？</p>
<p>对于不存在的key，map一定会返回默认零值，因此需要通过第二个参数来判断</p>
<pre><code class="language-go">// 错误的 key 检测方式
func main() {
 x := map[string]string{&quot;one&quot;: &quot;2&quot;, &quot;two&quot;: &quot;&quot;, &quot;three&quot;: &quot;3&quot;}
 if v := x[&quot;two&quot;]; v == &quot;&quot; {
  fmt.Println(&quot;key two is no entry&quot;) // 键 two 存不存在都会返回的空字符串
 }
}
 
// 正确示例
func main() {
 x := map[string]string{&quot;one&quot;: &quot;2&quot;, &quot;two&quot;: &quot;&quot;, &quot;three&quot;: &quot;3&quot;}
 if _, ok := x[&quot;two&quot;]; !ok {
  fmt.Println(&quot;key two is no entry&quot;)
 }
}
</code></pre>
<p>两种取值方式调用的是不同的函数，但他们的区别也仅仅就是判断下key存不存在而已</p>
</li>
<li>
<p>string类型可以修改吗</p>
<p>不能，go中的string类型本质是一个slice，里面存储的是utf-8，但是utf-8是不固定长的（utf-8的意义就是为了压缩字节数）英文字母和数字是1个字节，但中文是3或4字节，这就导致如果直接对下标进行操作的话，会导致编码错乱。</p>
<p>要修改可以转换成[]byte类型，此时实质上是把每个字符转换成了rune类型，rune也就是int32的别名，因此4字节可以存储下完整的utf-8中文字符了，不用担心结构错乱</p>
</li>
<li>
<p>switch 默认带有break，如果想和其它语言一样继续执行下一个case，可以写上fallthrough</p>
</li>
<li>
<p>解析json时的默认数据格式</p>
<pre><code class="language-json">Bool                   对应JSON布尔类型
float64                对应JSON数字类型
string                 对应JSON字符串类型
[]interface{}          对应JSON数组
map[string]interface{} 对应JSON对象
nil                    对应JSON的null
</code></pre>
</li>
<li>
<p>简短声明</p>
<p>只能在函数内部进行简短声明，如果是函数外部则只能用var</p>
<p>struct的变量不能用:=（别问我为什么，官方文档说的无法推断）</p>
<p>不能重复申明，至少有一个新的变量名才行</p>
</li>
<li>
<p>map迭代顺序</p>
<p>完全无序，1.9版本以前，如果是对硬编码的map还可以说有序，但是1.10版本在迭代的时候已经纯随机了，详见<a href="http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-map/">go语法基础巩固（map）</a></p>
</li>
<li>
<p>recover</p>
<p>recover函数是用来捕捉祖父级调用时的异常，需要用在defer中</p>
<pre><code class="language-go">func main(){
    defer func(){
        r:= recover()
        log.Println(r)
    }()
    panic(&quot;error&quot;)
}
</code></pre>
</li>
<li>
<p>闭包函数传参数</p>
<p>如果不传参数进去，他们引用的都是同一个变量， 这样当迭代的时候，还没有执行到的goroutine打印出来的是已经变化了的i，不是调用时的i</p>
<pre><code class="language-go">func main(){
    for i:=0;i&lt;10;i++{
        go func(i int){
            fmt.Println(i)
        }(i) //如果不传参会导致他们实际使用的是同一个变量
    }
    ......
}
</code></pre>
</li>
<li>
<p>goroutine内存泄露</p>
<p>本质上就是goroutine函数执行过程中没有正确的结束，因此就不会被释放，最终可能会导致内存越来越高</p>
</li>
<li>
<p>for select 一起使用的时候break 标签跳出</p>
<p>若无标签，直接break只是退出select语句而已</p>
<pre><code class="language-go">func main() {
	var ch chan int
exit:
	for {
		select {
		case v, ok := &lt;-ch:
			if !ok {
				break exit//跳出了整个exit循环，直接到最下方了
			}
			fmt.Println(v)
		}
	}
	
    fmt.Println(&quot;exit&quot;)
}
</code></pre>
</li>
<li>
<p>sort包对slice进行快排及搜索操作</p>
<p>注：当要找的目标不存在时，返回的值是其在排序后因该存在的位置</p>
<pre><code class="language-go">func main() {
	ints := []int{1, 2, 5, 4, 3, 7}
	sort.Ints(ints)
	fmt.Println(sort.SearchInts(ints, 6))
	fmt.Println(sort.SearchInts(ints, 4))
	fmt.Println(ints)
}

------------
5 //没有6，但是6应该放在第5个位置（从0开始）
3 //4在第3个位置
[1 2 3 4 5 7]

</code></pre>
</li>
<li>
<p>数组和切片的区别</p>
<table>
<thead>
<tr>
<th style="text-align:center">数组</th>
<th style="text-align:center">切片</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">值类型</td>
<td style="text-align:center">引用类型</td>
</tr>
<tr>
<td style="text-align:center">var arr [5]int</td>
<td style="text-align:center">var sli []int</td>
</tr>
<tr>
<td style="text-align:center">固定长度</td>
<td style="text-align:center">可变长度</td>
</tr>
<tr>
<td style="text-align:center">作为函数参数时是值传递，复制一份</td>
<td style="text-align:center">引用传递，相当于传了地址，本质上还是通一slice</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>new make 区别</p>
<table>
<thead>
<tr>
<th style="text-align:center">new</th>
<th style="text-align:center">make</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始化一个指向类型的指针</td>
<td style="text-align:center">为slice，map，chan初始化出其需要的</td>
</tr>
<tr>
<td style="text-align:center">返回值是指向分配的零值的指针，因此对引用类型的变量返回的就是nil</td>
<td style="text-align:center">返回的是类型的一个经过初始化的实例</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>for 循环多变量赋值</p>
<p>for循环中如果有多个变量，需要平行赋值</p>
<pre><code class="language-go">for i, j := 0, 0; i &lt; j; i, j = j+1, i+1 { //最后一个 i++,j++是不被允许的，因为这本身就是两个语句
	......
}
</code></pre>
</li>
<li>
<p>go的接口是什么</p>
<p>interface，方法的集合，不关心数据，只关心如何实现，只要实现了interface定义的方法，就可以说实现了该接口，也因此，一个空的interface{}可以说是被所有的数据类型所共有的一个父类，也可以说所有的数据类型都是的本质都是interface，其底层包括eface（无方法），iface（有方法）两种结构</p>
<p>对于第一种，在动态赋值的时候，其内部的_type指针会随数据类型变化</p>
<pre><code class="language-go">//不带函数的interface
var e interface{}
tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}

e = tty
</code></pre>
<p>这里的e完全就是个工具人，赋值以后的结构就是<img src="https://i6448038.github.io/img/reflection/eface2.png" alt="img" loading="lazy"></p>
<p>第二种除了其原本的静态类型指针以外，还有一个动态混合类型指针，eg.</p>
<pre><code class="language-go">//带函数的interface
var r io.Reader 

tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}

r = tty
</code></pre>
<p>这本来是一个静态类型的io.Reader，但是我们知道os.File类型一样实现了Reader方法，因此可以说os.File实现了io.Reader接口，因此<code>r = tty</code>是被允许的这时候，结构就变为了<img src="https://i6448038.github.io/img/reflection/iface2.png" alt="img" loading="lazy"></p>
<p>可以看到，其依然是静态类型io.Reader，但是实际上他已经是动态混合类型了</p>
<p>因此我们可以通过对interface的操作实现多态</p>
</li>
<li>
<p>类型断言</p>
<p>当想知道interface的具体类型时就需要断言</p>
<pre><code class="language-go">var e interface{}
tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return err.Error()
}

e = tty
//接上例
_, ok := e.(*os.File) //断言是否是该类型
if !ok {
    return &quot;error&quot;
}
switch v := e.(type) { //根据e的不同类型选择不同的方法
    case *os.File:
    	return v.Name()
    default:
    	return &quot;error&quot;
}
</code></pre>
</li>
<li>
<p>方法和函数是两个概念</p>
<p>但是怎么看他们也都差不多。。。我更愿意把方法称作成员函数，方法只不过是在函数的基础上，写上了这是属于谁的函数而已</p>
<pre><code class="language-go">func(s Service)Run(){//最奇怪的用法，这里的s是通过值传递调用的，因此这里无论做什么都不能影响原本的s，而且对于大型结构体还会导致频繁的复制。。暂时没用过。。。
    
}

func(s *Service)Run(){//方法，大写开头，因此是公开函数，函数外部可以调用
    foo() //同一个包内调用
}

func foo(){//函数,小写开头，所以是包内函数，其他package不能访问
    
}
</code></pre>
<pre><code class="language-go">type P struct {
	val int
}

func main() {
	p := new(P)
	p.val = 1
	fmt.Printf(&quot;%p,%p,%v\n&quot;, &amp;p, p, p)
	p.addr()
	p.addr2()
	fmt.Printf(&quot;%p,%p,%v\n&quot;, &amp;p, p, p)
}

func (p P) addr() {
	i := &amp;p
	p.val = 2
	fmt.Printf(&quot;%p,%p,%v\n&quot;, &amp;i, &amp;p, p)
}
func (p *P) addr2() {
	fmt.Printf(&quot;%p,%p,%v\n&quot;, &amp;p, p, p)
	p.val = 3
}
------------------------------
0xc000006028,0xc0000120b0,&amp;{1}
0xc000006038,0xc0000120e0,{2}
0xc000006040,0xc0000120b0,&amp;{1}
0xc000006028,0xc0000120b0,&amp;{3}
</code></pre>
<p>可以看到134行很明显是同一个地址，前面的是放p指针的地址，因此函数调用的时候只复制了地址过去，而第2行就明显的是值传递了</p>
</li>
<li>
<p>slice的扩容机制</p>
<ul>
<li>如果申请容量长度大于2倍的旧容量，则最终容量就是新申请的容量</li>
<li>如果旧其切片长度小于1024则新容量变为两倍</li>
<li>如果是大于等于1024，则旧容量增加原来的4分之一，直到大于新容量为止，然后进行内存对齐操作，因此是大于等于</li>
<li>如果容量计算溢出了，那新容量就是溢出之前的值</li>
<li>一旦触发扩容，则扩容后的slice就指向了新的地址</li>
</ul>
</li>
<li>
<p>empty slice 和nil slice</p>
<pre><code class="language-go">func main() {
	s1 := make([]int, 0)
	var s2 []int
	str, _ := json.Marshal(struct {
		S1 interface{} `json:&quot;s1&quot;`
		S2 interface{} `json:&quot;s2&quot;`
	}{
		S1: s1,
		S2: s2,
	})
	fmt.Printf(&quot;%+s&quot;, str)
}
-------------------
{&quot;s1&quot;:[],&quot;s2&quot;:null}
</code></pre>
</li>
<li>
<p>Data Race问题</p>
<p>互斥锁sync.Mutex或者是管道，管道的效率高一点</p>
</li>
<li>
<p>range slice 遍历</p>
<p>用range遍历slice得到的是要给值的拷贝，要对值修改需要用下标访问</p>
</li>
<li>
<p>nil interface</p>
<pre><code class="language-go">func main() {
   var data *byte
   var in interface{}

   fmt.Println(data, data == nil) // &lt;nil&gt; true
   fmt.Println(in, in == nil) // &lt;nil&gt; true

   in = data
   fmt.Println(in, in == nil) // &lt;nil&gt; false // data 值为 nil，但 in 值不为 nil
}
</code></pre>
<p>in原本是一个nil，最后被赋值了一个nil，nil也是个类型，因此赋值过后in就不是nil了，但他指向的值还是nil（没有十年脑血栓写不出这种代码，少一天都不行）</p>
</li>
</ol>
<p>本来以为是个什么考题，结果都是一些基础知识，就当再复习一遍吧</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一次完整的请求及改进]]></title>
        <id>http://blog.zerokirin.online/post/yi-ci-wan-zheng-de-qing-qiu-ji-gai-jin/</id>
        <link href="http://blog.zerokirin.online/post/yi-ci-wan-zheng-de-qing-qiu-ji-gai-jin/">
        </link>
        <updated>2021-04-16T11:48:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="准备阶段">准备阶段</h2>
<p>当你通过网线或者是WIFI连接到宿舍路由器时，无论进行何种访问，首当其冲的都是要清楚的知道自己所处的网络位置，因此需要初始化<strong>IP地址，默认网关，子网掩码</strong>，这决定了最基础的，你在当前局域网内的网络位置</p>
<h3 id="dhcp">DHCP</h3>
<h4 id="发现服务">发现服务</h4>
<ol>
<li><strong>笔记本A</strong>的操作系统首先生成一个<strong>DHCP发现报文</strong></li>
<li>放入一个UDP报文，目的端口67（DHCP服务器），源端口68（DHCP客户端）</li>
<li>UDP报文被放入一个IP数据报，目的IP地址为<code>255.255.255.255</code>（广播地址），源IP地址为<code>0.0.0.0</code>，因为此时A还没有有效的IP地址，所以才要获取呀</li>
<li>IP数据报被放入一个以太网帧，该帧的目的地址是<code>FF:FF:FF:FF:FF:FF</code>（广播地址），源地址是A自己的MAC地址，该帧会被广播到所有与交换机（在这里也就是寝室路由器，它充当了交换机的功能）相连的所有设备</li>
<li>这个以太网帧是第一个由A发送到交换机的帧，该交换机将在所有的出端口把此帧广播出去，包括路由器（寝室路由器的另一个功能）连接的端口</li>
<li>路由器收到该广播帧后进行解析，抽出IP数据报，一看目的地址是广播地址，因此进行处理，根据IP报头中的信息确定是UDP协议，然后抽出UDP，根据UDP端口67到达DHCP服务器，DHCP解析得到<strong>DHCP发现报文</strong></li>
</ol>
<h4 id="服务提供">服务提供</h4>
<p>由于一个局域网下可能会有多个路由器，也会有多个提供DHCP服务的服务器，因此不能直接选定，需要由客户机自己选择DHCP服务器，因此返回的<strong>服务提供报文</strong>的</p>
<ul>
<li>目的地址是广播地址</li>
<li>源地址是自身IP地址</li>
<li>还有DHCP服务号，用于最终选择哪个DHCP服务器</li>
<li>yiaddr（你的IP地址），指最终分给客户端的IP地址</li>
<li>其他若干信息，包括租期时间等等</li>
</ul>
<h4 id="发起请求">发起请求</h4>
<ol>
<li>A生成一个<strong>DHCP请求报文</strong></li>
<li>目的端口67，源端口68</li>
<li>目的IP地址依然是广播地址，源地址是<code>0.0.0.0</code></li>
<li>以太网帧的目的地址依然是广播地址，源地址是A自己的MAC地址</li>
<li>以太网帧通过交换机广播到所有设备上</li>
<li>路由器收到广播后解析，最终得到<strong>DHCP请求报文</strong></li>
</ol>
<p>以上和发现步骤相同，不同的是<strong>DHCP请求报文</strong>多带了一个DHCP服务号，这样即使由多个DHCP服务器，依然能确定选择哪个获取IP地址</p>
<ol start="7">
<li>对应的DHCP服务器将原来已经预分配的yiaddr作为IP地址，将<strong>IP地址，子网掩码，默认网关路由器，DNS服务器</strong>封装为一个DHCP ACK报文</li>
</ol>
<h4 id="处理返回">处理返回</h4>
<p>和服务提供步骤相同，不一样的是<strong>服务提供报文</strong>没有子网掩码等，</p>
<ol>
<li>将<strong>DHCP ACK报文</strong>封装进UDP，目的端口是68（客户端）</li>
<li>放入IP数据报，和服务提供步骤一样，源IP地址是自身IP地址，目的地址是广播地址</li>
<li>最后放入一个以太网帧，源地址是路由器MAC，目的地址是电脑A</li>
<li>由于交换机有自学习能力，在发现服务的时候就已经知道对应的MAC地址怎么转发了</li>
<li>返回到A，A记录并更新自己的状态</li>
</ol>
<p>到这里一个设备已经完整的加入到我们的局域网了</p>
<h2 id="dns和arp">DNS和ARP</h2>
<p>踏出请求的第一步就是获取对应的IP地址，这就是DNS查询</p>
<ol>
<li>
<p>将<code>google.com</code>放入一个UDP报文，目的端口53，源端口就是大于1024的随机一个</p>
</li>
<li>
<p>包装到IP报文中，目的地址是<strong>DNS服务器的IP地址</strong>，源地址就是自身的IP地址</p>
</li>
<li>
<p>由于路由表上没有直接对DNS服务的记录，因此会转发到默认网关路由器上</p>
<p>然而A只是知道了默认网关的IP地址，但以太网帧又不知道转到哪，这就需要ARP协议</p>
<ol>
<li>A生成一个具有目的IP地址（默认网关）的<strong>ARP查询报文</strong></li>
<li>把报文放到一个以太网帧中，该帧的目的地址是广播地址，把帧发送给交换机，交换机（一般情况下是路由器的交换部分）将转发给所有设备</li>
<li>每个设备都会解析报文，如果目的地址和自己的地址符合，就准备一个<strong>ARP回答报文</strong>，包括自己的IP地址和MAC地址</li>
<li>放到以太网帧中，目的地址是A的地址，通过交换机发送给A</li>
<li>A收到<strong>回答报文</strong>后将IP地址和MAC地址保存到ARP表中，下次直接调用就好</li>
</ol>
<p>这样就有了默认网关的MAC地址</p>
</li>
<li>
<p>将IP报文包装到以太网帧中，目标地址是<strong>默认网关的MAC</strong>，经过交换机转发给默认网关</p>
</li>
<li>
<p>默认网关根据自身的路由表选择将报文转发给下一跳路由器，同时<strong>更新目的地址</strong>，源地址保持不变，最终<strong>目的地址应该就是DNS服务器的MAC地址</strong>，路由表的更新由RIP，OSPF等域内协议以及域间协议BGP维护</p>
</li>
<li>
<p>经过重重转发到了DNS服务器，服务器收到查询报文后找到对应的IP地址，生成一个包括IP地址和<code>google.com</code>的UDP报文</p>
</li>
<li>
<p>然后就是放入IP报文和以太网帧，一路转发回到最初的起点A</p>
</li>
</ol>
<p>至此A终于知道了IP地址开始正式的访问</p>
<h2 id="tcp和https">TCP和HTTPS</h2>
<h3 id="建立http连接">建立HTTP连接</h3>
<h4 id="tcp三次握手">TCP三次握手</h4>
<ol>
<li>A生成一个TCP请求报文，四元组（源地址，目的地址，源端口号，目的端口号）填写好，FLAG为SYN</li>
<li>通过中间的路由器和交换机不断地转发到达目的地，然后被解析，服务端生成一个TCP报文，FLAG为SYN ACK</li>
<li>A收到报文后就已经进入连接状态了，对于A来说已经建立连接完成了，下一步就是发送数据，但对于服务端来说还处于同步等待状态，不过它会在下一次收到ACK报文的时候进入连接状态，这个报文可能是已经带有数据的</li>
</ol>
<p>至此，几乎所有准备工作都已经做完了，终于可以开始请求网页了。</p>
<h4 id="http请求">HTTP请求</h4>
<h5 id="请求报文">请求报文</h5>
<figure data-type="image" tabindex="1"><img src="https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png" alt="img" loading="lazy"></figure>
<ul>
<li>请求行 回车符和换行符就是<CR><LF></li>
<li>请求头 除了Host外都是可选的</li>
<li>空行 除了回车符和换行符以外无其他空格</li>
<li>数据</li>
</ul>
<pre><code class="language-http">GET / HTTP/1.1
Host: www.google.com
（注意这里是个空行）
</code></pre>
<p>将报文放入一个TCP报文，然后依据建立好的TCP连接发送出去</p>
<h5 id="响应报文">响应报文</h5>
<p><code>google.coom</code>服务器收到80端口的请求，生成响应报文，将请求的web页面内容放入响应体。</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20131107163544468" alt="img" loading="lazy"></figure>
<ul>
<li>状态行 请求成功的状态码就是200，描述 ok</li>
<li>响应头</li>
<li>空行</li>
<li>响应数据，正文部分</li>
</ul>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Length: 3059
Server: GWS/2.0
Date: Sat, 11 Jan 2003 02:44:04 GMT
Content-Type: text/html
Cache-control: private
Set-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqy
X9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com
Connection: keep-alive

&lt;html&gt;
Hello Google
&lt;/html&gt;
</code></pre>
<p>响应体经过路由器的重重转发，回到了A，A终于拿到了<code>google.com</code>的内容，浏览器将返回来的响应体进行渲染，渲染出了最终的页面。</p>
<h4 id="tcp四次挥手">TCP四次挥手</h4>
<p>连接完成后，当A已经不需要继续请求的时候就会开始回收步骤，结束连接</p>
<ol>
<li>A发送FIN</li>
<li>服务器收到FIN，返回ACK，此时A已经不能向服务器发送消息了，服务器将继续把没发完的发掉</li>
<li>服务器数据发送完毕后，发送FIN</li>
<li>A收到后返回ACK，等待2MSL后如果没收到服务器的消息则释放连接资源，此次链接结束</li>
<li>服务器收到ACK，确定A已经关闭，中断连接</li>
</ol>
<p>至此，从插入网线开始，一次完整的HTTP请求就结束了</p>
<h3 id="http的改进">HTTP的改进</h3>
<h4 id="http11">HTTP/1.1</h4>
<p>上面讲述的是一次完整的HTTP/1.1请求，它相比1.0改进了几个部分</p>
<ol>
<li>长连接，增加了connection报头，通过设置<code>Keep-Alive</code>可以保持HTTP连接不断开，避免了每次请求结束后都要重复释放，重复建立，提高了效率，当客户端像关闭HTTP连接的时候可以再请求头中携带<code>Connction: false</code>来告知服务器关闭请求。</li>
<li>增加了Host请求头，有时候同一个IP地址上会有不同的主机和或网站，因此可以通过携带不同的Host请求头来区分请求的主机。</li>
<li>身份认证，状态管理和缓存机制</li>
<li>断点续传，通过增加range头，请求资源的一部分，响应206</li>
</ol>
<h4 id="http20">HTTP/2.0</h4>
<p>由于1.x版本都是基于文字的，健壮性和性能都受到了挑战，而且长连接并没有解决TCP阻塞问题，于是有了2.0。</p>
<ol>
<li>头部压缩 2.0版本是基于二进制的，类似于TCP报头一样，规定好了位数，这样只需要在服务端和客户端同时维护一份静态的数据字典，用来确定请求头，省去了大部分重复字段</li>
<li>服务端推送，在1.x时代，当网页同时包含了<code>style.css</code>和<code>style.js</code>时，会再重复两次请求去获取两个文件，但是2.0中，服务端可以主动推送相关文件，客户端需要获取的时候就无需重复请求了</li>
<li>引入了帧和流的概念，实现了多路复用，抽象一点理解：
<ol>
<li>每一个帧可看做是一个学生，流可以认为是组（流标识符为帧的属性值），一个班级（一个连接）内学生被分为若干个小组，每一个小组分配不同的具体任务。</li>
<li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个小组任务都需要建立一个班级，多个小组任务多个班级，1:1比例</li>
<li>HTTP/1.1 Pipeling解决方式为，若干个小组任务排队串行化单线程处理，后面小组任务等待前面小组任务完成才能获得执行机会，一旦有任务处理超时等，后续任务只能被阻塞，毫无办法，也就是人们常说的线头阻塞，因此并未实际使用</li>
<li>HTTP/2多个小组任务可同时并行（严格意义上是并发）在班级内执行。一旦某个小组任务耗时严重，但不会影响到其它小组任务正常执行</li>
<li>这样自始至终就只有一个TCP连接，控制权完全在HTTP手中，而且也能最大化利用每个TCP连接可以传输的带宽</li>
</ol>
</li>
</ol>
<p>HTTP2.0对以前的1.x版本也提供了兼容，只需要经过一个二进制分帧层就可以将文本信息转化为对应的二进制头</p>
<h4 id="https">HTTPS</h4>
<p>不管http怎么改进，他始终是明文加密的一种传输方式，因此提出了加密方案——SSL协议，TCP/IP四层协议模型中应该是处于应用层，在OSI七层模型中可以算会话层</p>
<p>SSL的1.0版本有重大的安全缺陷，因此从未公开过，到3.0版本已经证明是成熟的方案了，于是在1999年，SSL3.0被更名成了TLS（传输层安全），TLS1.0实际上就是SSL3.1，这样，当HTTP经过了SSL/TLS协议加密后再传输的方式就被称为HTTPS</p>
<p>注：很多教程里说HTTP2.0要求强制使用HTTPS，其实这并不是2.0的要求，它只是规定了HTTP的协议，真正要求HTTPS的是浏览器</p>
<p>至此，我们的这次请求就由HTTP1.1更换为了HTTPS2.0</p>
<p>对于TLS的详解，请见下章</p>
]]></content>
    </entry>
</feed>