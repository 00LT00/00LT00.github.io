<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.zerokirin.online</id>
    <title>Zer0kiriN</title>
    <updated>2021-03-18T13:57:34.565Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.zerokirin.online"/>
    <link rel="self" href="http://blog.zerokirin.online/atom.xml"/>
    <subtitle>记录</subtitle>
    <logo>http://blog.zerokirin.online/images/avatar.png</logo>
    <icon>http://blog.zerokirin.online/favicon.ico</icon>
    <rights>All rights reserved 2021, Zer0kiriN</rights>
    <entry>
        <title type="html"><![CDATA[go语法基础巩固（string）]]></title>
        <id>http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-string/</id>
        <link href="http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-string/">
        </link>
        <updated>2021-03-18T11:39:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="字符串不能用下标访问">字符串不能用下标访问</h2>
<pre><code class="language-go">var str = &quot;Hello, 世界&quot;
</code></pre>
<p>在<code>golang</code>中，字符串几乎一定是<code>utf-8</code>编码的，而在<code>utf-8</code>中，中文有些是3个字节，有些是4个字节，英文是一个字节，而字符串这个类型的本质其实是一个字符slice，对str遍历可得</p>
<pre><code class="language-go">func main() {

	var str = &quot;Hello, 世界&quot;
	for i := 0; i &lt; len(str); i++ {
		fmt.Printf(&quot;%c &quot;, str[i])
	}
	fmt.Println()
	for i := 0; i &lt; len(str); i++ {
		fmt.Printf(&quot;%q &quot;, str[i])
	}
	fmt.Println()
	for i := 0; i &lt; len(str); i++ {
		fmt.Printf(&quot;%v &quot;, str[i])
	}
}
</code></pre>
<p>结果是</p>
<pre><code>H e l l o ,   ä ¸  ç   
'H' 'e' 'l' 'l' 'o' ',' ' ' 'ä' '¸' '\u0096' 'ç' '\u0095' '\u008c' 
72 101 108 108 111 44 32 228 184 150 231 149 140 
</code></pre>
<p>根据v和q的值可以看到，对于能解析的会被q解析为字符，解析不了的直接输出<code>utf-8</code>编码过后的结果，因此无法直接通过下标访问，但是可以将字符串转为rune数组</p>
<pre><code class="language-go">var str = &quot;Hello, 世界&quot;
fmt.Println(string([]rune(str[7:])))
//结果是 世界
</code></pre>
<p>go中对rune的定义是</p>
<pre><code class="language-go">type rune = int32
</code></pre>
<p>在转位rune数组的过程中，会将单个字符的全部字节放入（32位正好是<code>utf-8</code>的可变字符范围)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go语法基础巩固（map）]]></title>
        <id>http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-map/</id>
        <link href="http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-map/">
        </link>
        <updated>2021-03-18T10:34:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.bookstack.cn/read/qcrao-Go-Questions/map.md">map - 《Go 语言问题集(Go Questions)》 - 书栈网 · BookStack</a></p>
</blockquote>
<h2 id="map遍历是无序的">map遍历是无序的</h2>
<p>参考大佬的文章,本文仅仅是用我个人语言总结了一遍，仅作个人笔记使用</p>
<h3 id="map的结构">map的结构</h3>
<pre><code class="language-go">type hmap struct {
    // 元素个数，调用 len(map) 时，直接返回此值
    count     int
    flags     uint8
    // buckets 的对数 log_2
    B         uint8
    // overflow 的 bucket 近似数
    noverflow uint16
    // 计算 key 的哈希的时候会传入哈希函数
    hash0     uint32
    // 指向 buckets 数组，大小为 2^B
    // 如果元素个数为0，就为 nil
    buckets    unsafe.Pointer
    // 扩容的时候，buckets 长度会是 oldbuckets 的两倍
    oldbuckets unsafe.Pointer
    // 指示扩容进度，小于此地址的 buckets 迁移完成
    nevacuate  uintptr
    extra *mapextra // optional fields
}
</code></pre>
<p>首先是经过hash函数（由编译阶段确定是什么hash函数）获得了key，将k-v存在一个bucket（实际上是一个指向bmap的指针）中，bucket个数是2^B</p>
<pre><code>hmap[hash(key)]-&gt; bucket[2^B]-&gt; bmap[0:8]
</code></pre>
<p>每个bmap最多可以存储8对hash后结果相同的数据，因此还要再bmap中查找一边key，才能找到真正对应的值，属于时间换空间，经过编译器处理后bmap结构如下，当8个不够用时，overflow会指向新的一个bmap</p>
<pre><code class="language-go">type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
</code></pre>
<p>一般来说好的hash算法会尽量让每个bucket被平均分配，而不是一个超过太多，另一个是空的，但是当数据太多一样会发生拥挤，因此有一个指标叫做装载因子</p>
<pre><code class="language-go">loadFactor := count / (2^B)
</code></pre>
<p>两个条件都会触发</p>
<ol>
<li>
<p>装载因子大于6.5的时候</p>
</li>
<li>
<p>当overflow的bucket过多（bmap并不真正拥有overflow，overflow实际上是hmap中的结构）</p>
<ul>
<li>
<p>B&lt;15时，overflow的bucket数量大于2^B</p>
</li>
<li>
<p>B&gt;=15时，overflow的bucket数量大于2^15</p>
</li>
</ul>
</li>
</ol>
<p>此时会触发map的扩容，两种情况不一样</p>
<ol>
<li>
<p>条件一说明虽然很均匀，但是大家都快装满了，因此直接B+1解决问题</p>
</li>
<li>
<p>有两种可能</p>
<ul>
<li>
<p>不停的插入删除大量数据导致创建了过多的bucket，导致每个bucket都很空，但是都指向了一堆新的bucket，这时候就创建一个新的bucket将旧的bucket全部集中起来</p>
</li>
<li>
<p>极端情况：hash(key)都一样，怎么移动都没用，此时大家都集中在同一个bmap里面，就会创建很多bucket，但此时hash表已经退化为链表了</p>
</li>
</ul>
</li>
</ol>
<p>由于扩容的时候是不停的key-value的搬迁，因此非常影响性能，所以go是渐进式搬迁，每次插入修改删除key的时候移动两个，旧的bucket并没有真正被搬迁，而是挂载到了hmap的oldbuckets字段，直到完全迁移结束</p>
<p>如果是条件一则bucket变为两倍，如果条件二则不增加</p>
<h3 id="为什么无序">为什么无序？</h3>
<p>因为每次遍历map的时候实际上是遍历bucket，当B加一后，原来后B位的key变化了，多了一位，因此会分配到两个不一样的bucket中（但是同样可能不变），所以无法控制具体情况，自然就是无序的</p>
<ul>
<li>
<p>特殊情况：硬编码map</p>
<p>对于固定的map，不修改则完全不变，但是会给不熟悉的人带来疑惑，所以从go1.0 开始，遍历的时候是随机选择一个bucket中的cell（8个之一）开始，完全杜绝有序情况。</p>
</li>
</ul>
]]></content>
    </entry>
</feed>