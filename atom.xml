<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.zerokirin.online</id>
    <title>Zer0kiriN</title>
    <updated>2021-03-20T21:37:46.013Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.zerokirin.online"/>
    <link rel="self" href="http://blog.zerokirin.online/atom.xml"/>
    <subtitle>记录</subtitle>
    <logo>http://blog.zerokirin.online/images/avatar.png</logo>
    <icon>http://blog.zerokirin.online/favicon.ico</icon>
    <rights>All rights reserved 2021, Zer0kiriN</rights>
    <entry>
        <title type="html"><![CDATA[go语法基础巩固（channel）]]></title>
        <id>http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-channel/</id>
        <link href="http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-channel/">
        </link>
        <updated>2021-03-20T21:37:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="channel分为有缓冲和无缓冲">channel分为有缓冲和无缓冲</h2>
<p>channel有两种定义方式</p>
<pre><code class="language-go">var c1 = make(chan int) //无缓冲
var c2 = make(chan int,n) //有缓冲
close(c2)
</code></pre>
<ul>
<li>对无缓冲的c1的操作是同步的
<ul>
<li>必须同时存在接收者和发送者才会执行，否则会阻塞</li>
</ul>
</li>
<li>对有缓冲的c2是存在异步操作的
<ul>
<li>缓冲区满了则无法继续写入，进入阻塞，未满之前不阻塞程序</li>
<li>缓冲区空了则无法读取，进入阻塞，没有空之前不阻塞</li>
</ul>
</li>
</ul>
<h2 id="close关闭一个channel">close关闭一个channel</h2>
<ul>
<li>不能对一个关闭了的，或者本来就未通过make()初始化的channel执行关闭操作，会panic</li>
<li>关闭channel在某种角度上讲只是不允许继续写入，对于已经存入缓冲的数据还是可以读取的</li>
</ul>
<pre><code class="language-go">func main() {
	c1 := make(chan int, 5)
	for i := 0; i &lt; 5; i++ {
		c1 &lt;- i
	}
	close(c1)
	for i := 0; i &lt; 6; i++ {
		m, ok := &lt;-c1
		fmt.Println(m, ok)
	}
}
//结果：
//0 true
//1 true
//2 true
//3 true
//4 true
//0 false， 只有到这一步才因为没有数据而返回了默认的零值
</code></pre>
<p>总结一下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作\对象</th>
<th style="text-align:center">nil channel</th>
<th style="text-align:center">closed channel</th>
<th style="text-align:center">not nil, not closed channel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">close</td>
<td style="text-align:center">panic</td>
<td style="text-align:center">panic</td>
<td style="text-align:center">正常关闭</td>
</tr>
<tr>
<td style="text-align:center">读 &lt;- ch</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">读到对应类型的零值</td>
<td style="text-align:center">阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td>
</tr>
<tr>
<td style="text-align:center">写 ch &lt;-</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">panic</td>
<td style="text-align:center">阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td>
</tr>
</tbody>
</table>
<h2 id="channel的实现原理">channel的实现原理</h2>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000019839546">深度解密Go语言之channel - SegmentFault 思否</a></p>
</blockquote>
<p>以下内容均为个人转述总结，仅作笔记使用，参考出处如上</p>
<h3 id="channel结构">channel结构</h3>
<pre><code class="language-go">type hchan struct {
    // chan 里元素数量
    qcount   uint
    // chan 底层循环数组的长度
    dataqsiz uint
    // 指向底层循环数组的指针
    // 只针对有缓冲的 channel
    buf      unsafe.Pointer
    // chan 中元素大小
    elemsize uint16
    // chan 是否被关闭的标志
    closed   uint32
    // chan 中元素类型
    elemtype *_type // element type
    // 已发送元素在循环数组中的索引
    sendx    uint   // send index
    // 已接收元素在循环数组中的索引
    recvx    uint   // receive index
    // 等待接收的 goroutine 队列
    recvq    waitq  // list of recv waiters
    // 等待发送的 goroutine 队列
    sendq    waitq  // list of send waiters

    // 保护 hchan 中所有字段
    lock mutex
}

type waitq struct {
    first *sudog //对goroutine的封装
    last  *sudog //对goroutine的封装
}
</code></pre>
<p>和map一样，底层实际上是一个hchan结构体，调用了makechan()来创建channel，根据创建的时候是否有缓冲决定了buf指针是否有意义，sendx和recvx均为缓冲数组服务</p>
<pre><code class="language-go">func goroutine(a &lt;-chan int) {
    val := &lt;- a
    fmt.Println(&quot;received data: &quot;, val)
    return
}
func main(){
	var ch = make(chan int, 10)
    go goroutine(ch) //隐式转换为只读channel
    go goroutine(ch) //隐式转换为只读channel
    time.Sleep(time.Second)
}

</code></pre>
<p>上面go出去了两个读取ch的goroutine，所以此时接收队列应该是两个，结构如下（图源参考文章）</p>
<figure data-type="image" tabindex="1"><img src="https://segmentfault.com/img/remote/1460000019839562" alt="recvq structure" loading="lazy"></figure>
<p>可以看到G1，G2其实就是个sudog结构的双向循环列表，recvq分别通过first和last指向了头尾</p>
<p>发送队列也是个wait结构，因此和接收队列几乎一致</p>
<h3 id="写入">写入</h3>
<ol>
<li>
<p>先判断是否有接收队列，如果有则直接拷贝到接收队列中，不复制到buf</p>
</li>
<li>
<p>对于有缓冲的channel，若还有空间，则将数据拷贝到buf中，同时更改相应的index</p>
</li>
<li>
<p>若没有空间或非缓冲则阻塞，然后创建一个sudog（sudog实际上是goroutine的封装，因此新的sudog实际就是包括了执行函数的这个goroutine</p>
<p>将新的sudog加入发送队列，当前goroutine被系统挂起，等待接受进程唤醒</p>
</li>
</ol>
<h3 id="读取">读取</h3>
<ol>
<li>先判断是否有缓冲，若无缓冲则直接从发送者的栈拷贝到接收者的栈，发送者是通过遍历sendq找到的</li>
<li>若有缓冲则从buf所指的空间拷贝数据（只要不为空就会一直有数据写入，不会有主动寻找sendq的时机）</li>
<li>若没有数据则将自己挂起到接收队列等待被发送进程找到，也是创建一个sudog</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go语法基础巩固（string）]]></title>
        <id>http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-string/</id>
        <link href="http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-string/">
        </link>
        <updated>2021-03-18T11:39:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="字符串不能用下标访问">字符串不能用下标访问</h2>
<pre><code class="language-go">var str = &quot;Hello, 世界&quot;
</code></pre>
<p>在<code>golang</code>中，字符串几乎一定是<code>utf-8</code>编码的，而在<code>utf-8</code>中，中文有些是3个字节，有些是4个字节，英文是一个字节，而字符串这个类型的本质其实是一个字符slice，对str遍历可得</p>
<pre><code class="language-go">func main() {

	var str = &quot;Hello, 世界&quot;
	for i := 0; i &lt; len(str); i++ {
		fmt.Printf(&quot;%c &quot;, str[i])
	}
	fmt.Println()
	for i := 0; i &lt; len(str); i++ {
		fmt.Printf(&quot;%q &quot;, str[i])
	}
	fmt.Println()
	for i := 0; i &lt; len(str); i++ {
		fmt.Printf(&quot;%v &quot;, str[i])
	}
}
</code></pre>
<p>结果是</p>
<pre><code>H e l l o ,   ä ¸  ç   
'H' 'e' 'l' 'l' 'o' ',' ' ' 'ä' '¸' '\u0096' 'ç' '\u0095' '\u008c' 
72 101 108 108 111 44 32 228 184 150 231 149 140 
</code></pre>
<p>根据v和q的值可以看到，对于能解析的会被q解析为字符，解析不了的直接输出<code>utf-8</code>编码过后的结果，因此无法直接通过下标访问，但是可以将字符串转为rune数组</p>
<pre><code class="language-go">var str = &quot;Hello, 世界&quot;
fmt.Println(string([]rune(str[7:])))
//结果是 世界
</code></pre>
<p>go中对rune的定义是</p>
<pre><code class="language-go">type rune = int32
</code></pre>
<p>在转为rune数组的过程中，会将单个字符的全部字节放入（32位正好是<code>utf-8</code>的可变字符范围)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go语法基础巩固（map）]]></title>
        <id>http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-map/</id>
        <link href="http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-map/">
        </link>
        <updated>2021-03-18T10:34:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.bookstack.cn/read/qcrao-Go-Questions/map.md">map - 《Go 语言问题集(Go Questions)》 - 书栈网 · BookStack</a></p>
</blockquote>
<h2 id="map遍历是无序的">map遍历是无序的</h2>
<p>参考大佬的文章,本文仅仅是用我个人语言总结了一遍，仅作个人笔记使用</p>
<h3 id="map的结构">map的结构</h3>
<pre><code class="language-go">type hmap struct {
    // 元素个数，调用 len(map) 时，直接返回此值
    count     int
    flags     uint8
    // buckets 的对数 log_2
    B         uint8
    // overflow 的 bucket 近似数
    noverflow uint16
    // 计算 key 的哈希的时候会传入哈希函数
    hash0     uint32
    // 指向 buckets 数组，大小为 2^B
    // 如果元素个数为0，就为 nil
    buckets    unsafe.Pointer
    // 扩容的时候，buckets 长度会是 oldbuckets 的两倍
    oldbuckets unsafe.Pointer
    // 指示扩容进度，小于此地址的 buckets 迁移完成
    nevacuate  uintptr
    extra *mapextra // optional fields
}
</code></pre>
<p>首先是经过hash函数（由编译阶段确定是什么hash函数）获得了key，将k-v存在一个bucket（实际上是一个指向bmap的指针）中，bucket个数是2^B</p>
<pre><code>hmap[hash(key)]-&gt; bucket[2^B]-&gt; bmap[0:8]
</code></pre>
<p>每个bmap最多可以存储8对hash后结果相同的数据，因此还要再bmap中查找一边key，才能找到真正对应的值，属于时间换空间，经过编译器处理后bmap结构如下，当8个不够用时，overflow会指向新的一个bmap</p>
<pre><code class="language-go">type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
</code></pre>
<p>一般来说好的hash算法会尽量让每个bucket被平均分配，而不是一个超过太多，另一个是空的，但是当数据太多一样会发生拥挤，因此有一个指标叫做装载因子</p>
<pre><code class="language-go">loadFactor := count / (2^B)
</code></pre>
<p>两个条件都会触发</p>
<ol>
<li>
<p>装载因子大于6.5的时候</p>
</li>
<li>
<p>当overflow的bucket过多（bmap并不真正拥有overflow，overflow实际上是hmap中的结构）</p>
<ul>
<li>
<p>B&lt;15时，overflow的bucket数量大于2^B</p>
</li>
<li>
<p>B&gt;=15时，overflow的bucket数量大于2^15</p>
</li>
</ul>
</li>
</ol>
<p>此时会触发map的扩容，两种情况不一样</p>
<ol>
<li>
<p>条件一说明虽然很均匀，但是大家都快装满了，因此直接B+1解决问题</p>
</li>
<li>
<p>有两种可能</p>
<ul>
<li>
<p>不停的插入删除大量数据导致创建了过多的bucket，导致每个bucket都很空，但是都指向了一堆新的bucket，这时候就创建一个新的bucket将旧的bucket全部集中起来</p>
</li>
<li>
<p>极端情况：hash(key)都一样，怎么移动都没用，此时大家都集中在同一个bmap里面，就会创建很多bucket，但此时hash表已经退化为链表了</p>
</li>
</ul>
</li>
</ol>
<p>由于扩容的时候是不停的key-value的搬迁，因此非常影响性能，所以go是渐进式搬迁，每次插入修改删除key的时候移动两个，旧的bucket并没有真正被搬迁，而是挂载到了hmap的oldbuckets字段，直到完全迁移结束</p>
<p>如果是条件一则bucket变为两倍，如果条件二则不增加</p>
<h3 id="为什么无序">为什么无序？</h3>
<p>因为每次遍历map的时候实际上是遍历bucket，当B加一后，原来后B位的key变化了，多了一位，因此会分配到两个不一样的bucket中（但是同样可能不变），所以无法控制具体情况，自然就是无序的</p>
<ul>
<li>
<p>特殊情况：硬编码map</p>
<p>对于固定的map，不修改则完全不变，但是会给不熟悉的人带来疑惑，所以从go1.0 开始，遍历的时候是随机选择一个bucket中的cell（8个之一）开始，完全杜绝有序情况。</p>
</li>
</ul>
]]></content>
    </entry>
</feed>