<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.zerokirin.online</id>
    <title>Zer0kiriN</title>
    <updated>2021-05-31T08:15:48.171Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.zerokirin.online"/>
    <link rel="self" href="http://blog.zerokirin.online/atom.xml"/>
    <subtitle>记录</subtitle>
    <logo>http://blog.zerokirin.online/images/avatar.png</logo>
    <icon>http://blog.zerokirin.online/favicon.ico</icon>
    <rights>All rights reserved 2021, Zer0kiriN</rights>
    <entry>
        <title type="html"><![CDATA[Mysql 事务隔离等级和锁详解（一）]]></title>
        <id>http://blog.zerokirin.online/post/mysql-shi-wu-ge-chi-deng-ji-he-suo-xiang-jie-yi/</id>
        <link href="http://blog.zerokirin.online/post/mysql-shi-wu-ge-chi-deng-ji-he-suo-xiang-jie-yi/">
        </link>
        <updated>2021-05-28T19:12:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一致性">一致性</h2>
<p>我们都知道数据库原理中著名的ACID</p>
<ul>
<li>atomicity 原子性</li>
<li>consistency 一致性</li>
<li>isolation 隔离性</li>
<li>durability 持久性</li>
</ul>
<p>这其中一致性是通过原子性和隔离性保证的，如何保证一致性是数据库的最重要的问题，这是一切的开头</p>
<h2 id="并发一致性问题">并发一致性问题</h2>
<p>这里借用下<a href="http://cyc2018.gitee.io/cs-notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86">CS-Notes (gitee.io)</a>，过程就不写文字了，图很清楚</p>
<h3 id="丢失修改">丢失修改</h3>
<figure data-type="image" tabindex="1"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png" alt="img" loading="lazy"></figure>
<h3 id="读脏数据">读脏数据</h3>
<figure data-type="image" tabindex="2"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png" alt="img" loading="lazy"></figure>
<h3 id="不可重复读">不可重复读</h3>
<figure data-type="image" tabindex="3"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png" alt="img" loading="lazy"></figure>
<h3 id="幻影读">幻影读</h3>
<table>
<thead>
<tr>
<th style="text-align:left">时间点</th>
<th style="text-align:left">事务A</th>
<th style="text-align:left">事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">开启事务</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"></td>
<td style="text-align:left">开启事务</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">查询数据“老王”，不存在</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"></td>
<td style="text-align:left">插入数据“老王”</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"></td>
<td style="text-align:left">提交事务</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">查询数据“老王”，不存在</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">插入数据“老王”，不成功</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">更新数据“老王”，成功 ？</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">查询数据“老王”，成功 ？</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>官网对幻影读的讲解非常模糊，网上还有很多乱讲的东西，比如什么范围中间插入后，个数发生变化，错</p>
<p>我们先看个例子：</p>
<pre><code class="language-sql">--事务1
mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select count(*) from gap;
+----------+
| count(*) |
+----------+
|        4 |
+----------+
1 row in set (0.04 sec)

mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select count(*) from gap;
+----------+
| count(*) |
+----------+
|        4 |
+----------+
1 row in set (0.04 sec)

--事务2
mysql&gt; insert into gap values(8,'老王');
Query OK, 1 row affected (0.05 sec)

--事务1
mysql&gt; select count(*) from gap;
+----------+
| count(*) |
+----------+
|        4 | --没有任何变化
+----------+
1 row in set (0.00 sec)

mysql&gt; select * from gap;
+----+------+
| id | name |
+----+------+
|  1 | 张三 |
|  5 | 李四 |
|  7 | 王五 |
| 11 | 赵6  |
+----+------+
4 rows in set (0.00 sec)
</code></pre>
<p>那么幻读幻到哪去了？继续看</p>
<pre><code class="language-sql">--事务1
mysql&gt; insert into gap values(8,'赵四');
ERROR 1062 (23000): Duplicate entry '8' for key 'gap.PRIMARY'
</code></pre>
<p>看到了么，明明没有查到，但是却没法添加，但他却可以被更新</p>
<pre><code class="language-sql">mysql&gt; update gap set name = '刘能' where id = 8;
Query OK, 1 row affected (0.04 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; select * from gap;
+----+------+
| id | name |
+----+------+
|  1 | 张三 |
|  5 | 李四 |
|  7 | 王五 |
|  8 | 刘能 |
| 11 | 赵6  |
+----+------+
5 rows in set (0.00 sec)
</code></pre>
<p>明明没有的数据，凭空冒了出来这才是幻读，和不可重复读有很大区别。</p>
<h2 id="事务隔离等级">事务隔离等级</h2>
<ul>
<li>read uncommitted   读未提交</li>
<li>read committed   读已提交</li>
<li>repeatable read   可重复读</li>
<li>serializable   串行化</li>
</ul>
<p>从上到下依次严格，每个隔离等级都解决了一个并行问题</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离等级</th>
<th>未解决的并发一致性问题</th>
<th style="text-align:right">解决的并发一致性问题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读未提交</td>
<td>幻影读，不可重复读，读脏数据</td>
<td style="text-align:right">丢失修改</td>
</tr>
<tr>
<td style="text-align:center">读已提交</td>
<td>幻影读，不可重复读</td>
<td style="text-align:right">读脏数据，丢失修改</td>
</tr>
<tr>
<td style="text-align:center">可重复读</td>
<td>幻影读</td>
<td style="text-align:right">不可重复读，读脏数据，丢失修改</td>
</tr>
<tr>
<td style="text-align:center">串行化</td>
<td>串行化已经不是并行了，自然没问题</td>
<td style="text-align:right">幻影读，不可重复读，读脏数据，丢失修改</td>
</tr>
</tbody>
</table>
<p>暂时先不要关注隔离等级，让我们先了解下实现他们的前置知识——锁</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql基础回顾]]></title>
        <id>http://blog.zerokirin.online/post/mysql-ji-chu-hui-gu/</id>
        <link href="http://blog.zerokirin.online/post/mysql-ji-chu-hui-gu/">
        </link>
        <updated>2021-05-16T13:32:23.000Z</updated>
        <content type="html"><![CDATA[<p><s>ORM库用起来是真的爽，面试的时候被问sql也是真的爽，人自闭了重新复习吧</s></p>
<h2 id="增删改查">增删改查</h2>
<h3 id="select">select</h3>
<pre><code class="language-sql">(8)SELECT (9)[ALL|DISTINCT|DISTINCTROW|TOP]
(11){*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]}
(1)FROM &lt;left_table[,…]&gt;
(3)[[{LEFT|RIGHT|INNER|CROSS}] JOIN &lt;right_table&gt; 
(2)	ON &lt;condition&gt;]
(4)[WHERE &lt;where_condition&gt;]
(5)[GROUP BY {col_name | expr | position}, ... (6)[WITH ROLLUP]]
(7)[HAVING &lt;where_condition&gt;]
(10)[ORDER BY {col_name | expr | position} [ASC | DESC]}
</code></pre>
<p>这是一个缩略版的select的解释顺序，括号中的数字代表解释的优先级，可以看到观察到几个点</p>
<ul>
<li>order by，field_list 等的优先级可以说是整个流程的最低级</li>
<li>group by 和 having 比where的优先级要低，也就是说所有的分组操作都是来源于where筛选后的结果</li>
<li>having做的是对分组后的结果集的再次查询，因此应该先使用where过滤，比如说找到非A用户的登录记录，筛选条件是可以放到having后的，但是A用户已经被分组了，同时参与了count等运算，只是最后剔除了这一组，所以说having可以看作是where的补充，能不用就不用</li>
<li>group by 和 order by 都支持position，也就是下标访问，不过是从1开始的，数组就是field_list</li>
</ul>
<h3 id="insert">insert</h3>
<p>insert into 有三种写法，官网的语句太复杂了，简化一下</p>
<ul>
<li>
<p>一种就是最基础的</p>
<pre><code class="language-sql">INSERT INTO tbl_name [(a,b,c)] VALUES (1,2,3)[, (4,5,6), (7,8,9)];
--或者是
INSERT INTO tbl_name [(a,b,c)] VALUES ROW(1,2,3)[, ROW(4,5,6), ROW(7,8,9)];
</code></pre>
<p>table后面可选择列名，如果不选的话，values后面每个括号中的内容都要按字段顺序填入</p>
<p>多个括号就是批量插入的意思</p>
</li>
<li>
<p>这种是用set代替了values</p>
<pre><code class="language-sql">INSERT INTO
	friend
SET
	name = 'Kim',
	isBFF = true
;
</code></pre>
<p>用法和普通的一样，类似于update语句，个人感觉更符合直觉一点，但是不支持批量插入</p>
</li>
<li>
<p>比较特殊的，从另一个表搜索数据然后插入</p>
<pre><code class="language-sql">INSERT INTO tbl_temp2 (fld_id)
  SELECT tbl_temp1.fld_order_id
  FROM tbl_temp1 WHERE tbl_temp1.fld_order_id &gt; 100;
  
--8.0.19版本后支持用table字段替代select
INSERT INTO ta TABLE tb; --select * from tb;支持limit和order by
</code></pre>
</li>
</ul>
<p>insert的特殊用法</p>
<ul>
<li>
<p>插入的行的主键已经存在 <code>ON DUPLICATE KEY UPDATE</code> ，存在就更新，大概有三种用法</p>
<pre><code class="language-sql">--可以引用a，b列的值，类似于分别设置c=1+2和c=4+5
INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6) ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);
--8.0.19版本后增加了AS关键字，可以通过表名来引用行
INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6) AS new ON DUPLICATE KEY UPDATE c = new.a+new.b;
--更骚的是还支持指定列名
INSERT INTO t1 SET a=1,b=2,c=3 AS new(m,n,p) ON DUPLICATE KEY UPDATE c = m+n;
--如果是插入，影响条数1，更新是2，内容不变的话是0
--这个用法在insert into select中也是可以的，其实就是把values...这部分换成了select...只放例子不再赘述
INSERT INTO t1
  SELECT * FROM (SELECT c, c+d AS e FROM t2) AS dt
  ON DUPLICATE KEY UPDATE b = e; --insert ...select语句的update部分不能使用VALUES()会报错
</code></pre>
</li>
<li>
<p>insert开头的可选项</p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>已存在</strong></th>
<th><strong>不存在</strong></th>
<th><strong>举例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>insert</td>
<td>报错</td>
<td>插入</td>
<td>insert into names(name, age) values(“小明”, 23);</td>
</tr>
<tr>
<td>insert ignore</td>
<td>忽略</td>
<td>插入</td>
<td>insert ignore into names(name, age) values(“小明”, 24);</td>
</tr>
<tr>
<td>replace</td>
<td>替换</td>
<td>插入</td>
<td>replace into names(name, age) values(“小明”, 25);</td>
</tr>
</tbody>
</table>
<p>重点看第三个，replace和on duplicate key的区别</p>
<ul>
<li>如果主键不存在，都是insert，无区别</li>
<li>如果存在，replace是真的delete后再insert，原有数据被清空，因此新行的值要写全不然会置零</li>
<li>on duplicate key是只更新update后面描述的结果，不是删除插入</li>
</ul>
</li>
</ul>
<h3 id="delete">delete</h3>
<p>这个没什么好说的用法不多基础语法如下：</p>
<pre><code class="language-sql">--删除一个表的数据
DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name [[AS] tbl_alias]
    [PARTITION (partition_name [, partition_name] ...)] --这里是分区
    [WHERE where_condition]
    [ORDER BY ...]
    [LIMIT row_count]
    
--多个表一起删或者作为辅助查询，下面两个用法一样，只是写法不同
DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    tbl_name[.*] [, tbl_name[.*]] ...
    FROM table_references --此处的写法和select中的join一样，支持各种join
    [WHERE where_condition]
--实例1. 
DELETE t1, t2 FROM t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id;

DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    FROM tbl_name[.*] [, tbl_name[.*]] ...
    USING table_references
    [WHERE where_condition]
--实例2.
DELETE FROM t1, t2 USING t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id; --没啥子区别，join部分一模一样

--比较实用的例子，从t1中删掉t2没有的行
DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;
</code></pre>
<h3 id="update">update</h3>
<p>最朴实无华的语法（非官方定义）</p>
<pre><code class="language-sql">UPDATE Tab1, [Tab2, [INNER JOIN | LEFT JOIN] Tab1 ON Tab1.C1 = Tab2.C1]  
SET Tab1.C2 = [Tab2.C2, Tab2.C3 =] expression  
WHERE Condition;  
</code></pre>
<p>如果只更新一个表就很简单，直接再set后面写出谁等于谁就好</p>
<pre><code class="language-sql">UPDATE t SET id = id + 1 ORDER BY id DESC; --这里用了orderby desc是因为，如果升序来，会先把1-&gt;2，这样就有两个2的记录了，违反了主键约束原则，因此降序更新
</code></pre>
<p>多个表的例子（多表时不能用order by 和limit）</p>
<pre><code class="language-sql">UPDATE items,month SET items.price=month.price WHERE items.id=month.id; --这里默认是inner join
</code></pre>
<p>左连接例子</p>
<pre><code class="language-sql">UPDATE Employees e LEFT JOIN Performance p   
ON e.performance = p.performance  
SET salary = salary + salary * 0.025  
WHERE p.percentage IS NULL;  
</code></pre>
<p>需要注意的一个问题是，update中where的子语句不能直接使用当前表的结果，例如：</p>
<pre><code class="language-sql">mysql&gt; UPDATE items
     &gt; SET retail = retail * 0.9
     &gt; WHERE id IN
     &gt;     (SELECT id FROM items
     &gt;         WHERE retail / wholesale &gt;= 1.3 AND quantity &gt; 100);
ERROR 1093 (HY000): You can't specify target table 'items' for update in FROM clause
</code></pre>
<p>需要将子查询移到一个新的派生表中</p>
<pre><code class="language-sql">UPDATE items,
       (SELECT id FROM items
        WHERE id IN
            (SELECT id FROM items
             WHERE retail / wholesale &gt;= 1.3 AND quantity &lt; 100))
        AS discounted
SET items.retail = items.retail * 0.9
WHERE items.id = discounted.id;
</code></pre>
<h2 id="数据类型">数据类型</h2>
<p>数据分为数值类型，字符串类型，时间类型，空间类型</p>
<h3 id="数值类型">数值类型</h3>
<h4 id="整型">整型</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left">1 byte</td>
<td style="text-align:left">(-128，127)</td>
<td style="text-align:left">(0，255)</td>
<td style="text-align:left">小整数值</td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left">2 bytes</td>
<td style="text-align:left">(-32 768，32 767)</td>
<td style="text-align:left">(0，65 535)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMINT</td>
<td style="text-align:left">3 bytes</td>
<td style="text-align:left">(-8 388 608，8 388 607)</td>
<td style="text-align:left">(0，16 777 215)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">INT或INTEGER</td>
<td style="text-align:left">4 bytes</td>
<td style="text-align:left">(-2 147 483 648，2 147 483 647)</td>
<td style="text-align:left">(0，4 294 967 295)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">8 bytes</td>
<td style="text-align:left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td style="text-align:left">(0，18 446 744 073 709 551 615)</td>
<td style="text-align:left">极大整数值</td>
</tr>
</tbody>
</table>
<p>借用菜鸟的表格，可以看到每种类型的大小已经固定了，而在类型声明的时候有可能会有这种情况</p>
<pre><code class="language-sql">CREATE TABLE test(
    id1 int(1),
    id2 tinyint(1)
);
</code></pre>
<p>这里内的值我们暂时称为M，M表示的意思就是实际的显示位数，但是<strong>上述写法是没有意义的</strong>，因为int和tinyint本身的长度是已经确定的，加括号的真正写法是</p>
<pre><code class="language-sql">CREATE TABLE test(
    int_test_M int(3) ZEROFILL,
);
</code></pre>
<p>只有用zerofill 修饰才有意义，加了zerofill后，会默认添加unsigned参数，也就是变成无符号数（非负数）</p>
<pre><code class="language-sql">mysql&gt; desc test1;
+------------+--------------------------+------+-----+---------+-------+
| Field      | Type                     | Null | Key | Default | Extra |
+------------+--------------------------+------+-----+---------+-------+
| int_test_M | int(3) unsigned zerofill | YES  |     | NULL    |       |
+------------+--------------------------+------+-----+---------+-------+
1 row in set (0.02 sec)

mysql&gt; select * from test1;
+------------+
| int_test_M |
+------------+
|        001 | --这里吧一位的长度补足了
|       1111 | --没啥用了
+------------+
2 rows in set (0.00 sec)
</code></pre>
<blockquote>
<p>As of MySQL 8.0.17, the <code>ZEROFILL</code> attribute is deprecated for numeric data types; you should expect support for it to be removed in a future version of MySQL. Consider using an alternative means of producing the effect of this attribute. For example, applications could use the <a href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad"><code>LPAD()</code></a> function to zero-pad numbers up to the desired width, or they could store the formatted numbers in <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>CHAR</code></a> columns.</p>
</blockquote>
<p>官方文档已经说了zerofill这玩意已经快废弃了，就别用这种骚操作了</p>
<p>另外还有两个整数型</p>
<ul>
<li>
<p><strong>BIT[(M)]</strong>  表示Mbits的数据大小，默认M为1，存储二进制数据，长度就是M，超过了大小则无法插入</p>
</li>
<li>
<p><strong>BOOL/BOOLEAN</strong> 本质上是TINYINT(1)，1是<code>'true'</code> 0是<code>'false'</code>，其他的值既不是true也不是false</p>
</li>
</ul>
<h4 id="浮点数">浮点数</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">4 bytes</td>
<td style="text-align:left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td style="text-align:left">单精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">8 bytes</td>
<td style="text-align:left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">双精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">小数值</td>
</tr>
</tbody>
</table>
<p>先说float和double，这是最常见的单精度和双精度浮点数，这里我们在M的基础上引入D，M说过了就是位数，D则代表了小数点后的位数，默认情况下float的D是7，double的D是15</p>
<p>这里float还有个特殊的骚操作，float[p]，用p代替了DM，p在0-24时当作float，25-53时当作double</p>
<p>但是给float和double指定精度的操作都是mysql特有的，并不是sql标准语法，并且官方文档已经说明，从8.0.17开始将不再建议此写法，同时有可能在未来的版本中删除，因此不要写这种奇奇怪怪的东西了，又不方便拓展又不能节省空间，何必呢</p>
<p>这里再说下<strong>DECIMAL</strong>，这个类型和float，double<strong>完全不一样</strong>，默认情况下他的(M,D)是(10,0)，M最大支持65，D最大30，千万不要把他理解成double，这是<strong>完全不一样</strong>的类型，众所周知，计算机内浮点数的存储方式和整型不一样，因为阶码和尾数的存在永远只能近似，但是DECIMAL<strong>完全不一样</strong>（三遍）</p>
<p>DECIMAL的英文含义就是十进制，因此它的存储结构和他的名字类似</p>
<table>
<thead>
<tr>
<th style="text-align:center">数位</th>
<th style="text-align:center">字节</th>
<th style="text-align:center">最大值（有符号）</th>
<th style="text-align:center">最大值位数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1-2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">127</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3-4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">32767</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">5-6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">8388607</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">7-9</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2147483647</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
<p>这样，每一个位数的最大值9999999都可以被他的空间完全表示出来，位数逢十进一，每10位占4个字节，整数和小数分开存储，举个例子，decimal(26,14)，小数14位，9+5，所以需要4+3=7字节大小存储小数，整数12位，9+3，也就是4+2=6字节存储，一共6+7=13字节大小</p>
<p>通过这种饱和式的存储方式，可以实现真正意义上的精度，再也不会有<code>1-0.0000000001!=0.9999999999</code>的情况出现，当然缺点就是存储空间大，但如果不是非要用那么大的精度的话，其实还好</p>
<p>当然这个类型也支持unsigned和zerofill，但是同样在8.0.17后已经不被推荐了，以后少用</p>
<h3 id="字符串类型">字符串类型</h3>
<p>字符串类型也大概可以分成两类，字符串和二进制字符串，当然还有一类比较特殊的ENUM和SET，我们先讲这两个</p>
<h4 id="enum-枚举set-集合">ENUM 枚举，SET 集合</h4>
<p>共同点：</p>
<ul>
<li>虽然显示格式是字符串，但是实际上存储的是其定义时的索引位置</li>
<li>直接插入整型变量的时候会当作索引</li>
<li>如果插入的字符串变量不在声明之中，会尝试将其索引化</li>
<li>空值是null，''是一个合法的值，代表着索引0的值，不是null</li>
</ul>
<p>区别就是ENUM只能存定义里的其中一个，SET是存任意多个</p>
<p>在存储上，ENUM只需要存储对应字符串的索引即可，最多支持65535个可选项，因此索引值最大也就是65535，正好是2Bytes的存储上限</p>
<p>而SET，集合就不一样了，集合有很多操作，比如交并补，因此set中子项的保存形式是以二进制字符串中1的位置来确定的，<code>SET('a','b','c','d')</code> 的索引值如下表</p>
<table>
<thead>
<tr>
<th style="text-align:left"><code>SET</code> Member</th>
<th style="text-align:left">Decimal Value</th>
<th style="text-align:left">Binary Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>''</code></td>
<td style="text-align:left"><code>0</code></td>
<td style="text-align:left"><code>0000</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'a'</code></td>
<td style="text-align:left"><code>1</code></td>
<td style="text-align:left"><code>0001</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'b'</code></td>
<td style="text-align:left"><code>2</code></td>
<td style="text-align:left"><code>0010</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'c'</code></td>
<td style="text-align:left"><code>4</code></td>
<td style="text-align:left"><code>0100</code></td>
</tr>
<tr>
<td style="text-align:left"><code>'d'</code></td>
<td style="text-align:left"><code>8</code></td>
<td style="text-align:left"><code>1000</code></td>
</tr>
</tbody>
</table>
<p>这样集合的交并补就变成了两个二进制数的与或非操作</p>
<p>SET最大支持64个子项，也就是最大8Bytes，具体的字节数为 (N+7)/8四舍五入</p>
<p>在匹配的时候可以使用函数FIND_IN_SET()也可以用 like '%value%'</p>
<h4 id="字符串和二进制字符串">字符串和二进制字符串</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CHAR(M)</td>
<td style="text-align:left">0-255 个字符</td>
<td style="text-align:left">定长字符串</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR(M)</td>
<td style="text-align:left">取决于整行的大小</td>
<td style="text-align:left">变长字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYBLOB</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYTEXT</td>
<td style="text-align:left">0-255 bytes</td>
<td style="text-align:left">短文本字符串</td>
</tr>
<tr>
<td style="text-align:left">BLOB(M)</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:left">TEXT(M)</td>
<td style="text-align:left">0-65 535 bytes</td>
<td style="text-align:left">长文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMBLOB</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMTEXT</td>
<td style="text-align:left">0-16 777 215 bytes</td>
<td style="text-align:left">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGBLOB</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGTEXT</td>
<td style="text-align:left">0-4 294 967 295 bytes</td>
<td style="text-align:left">极大文本数据</td>
</tr>
</tbody>
</table>
<p><s>表是从菜鸟拿的，错得离谱。。。</s></p>
<h5 id="先从老生常谈的char与varchar说起">先从老生常谈的char与varchar说起</h5>
<ul>
<li>
<p>char</p>
<p>char是固定长度字符串，一般用法是char(M)，如果省略M，默认值1最大长度255，早在5.0以后M就不是字节了，M代表的是字符，菜鸟这么多年都没改过表格吗。。。</p>
<p>一个utf8编码下的中文字符占了3个字节，256*3=768字节，这才是CHAR的标准上限，但是如果使用utf8mb4过长的编码格式，就会超过768字节，innoDB会将多余的字节存到其他位置，所以只要是5.0版本以后就根本不需要care字节数的问题</p>
<p>存储时如果不足M长度，自动在末尾补' '填充，这也是为啥char类型的末尾' '会消失</p>
</li>
<li>
<p>varchar</p>
<p>varchar和char的区别不只是可变长度，其存储结构也不一样</p>
<p>在varchar中开头需要预留1或者2个字节作为长度的值，分别能表示255和65535个字节的长度，但这是字节数的理论上限，M的范围呢？</p>
<p>在innoDB中要求每一行一共能存储65535字节大小的数据，这是所有列共享的，因此M的大小还受到其他的列的影响，假如只有一列，那么一个中文字符大小3个字节，算上开头的两个表示长度的字节，一个NULL标记字节，65535-2-1=65532，65532/3=21844，这就是M在这种情况下的理论最大值</p>
<p>可以看到这个值是很不稳定的，因为还要考虑其他的列，因此不建议设这么大</p>
</li>
</ul>
<h5 id="binary和varbinar">BINARY和VARBINAR</h5>
<p>这俩和char，varchar非常相似，几乎一样，官方文档直说区别仅仅是保存的二进制字符串而已，不再赘述</p>
<h5 id="剩下的主要就是blob和text">剩下的主要就是BLOB和TEXT</h5>
<p>在mysql的官方文档中，可以看到它和varchar与varbinary十分类似</p>
<blockquote>
<p>In most respects, you can regard a <code>BLOB</code> column as a <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>VARBINARY</code></a> column that can be as large as you like. Similarly, you can regard a <code>TEXT</code> column as a <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a> column. <code>BLOB</code> and <code>TEXT</code> differ from <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>VARBINARY</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a> in the following ways:</p>
<ul>
<li>For indexes on <code>BLOB</code> and <code>TEXT</code> columns, you must specify an index prefix length. For <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>CHAR</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a>, a prefix length is optional. See <a href="https://dev.mysql.com/doc/refman/8.0/en/column-indexes.html">Section 8.3.5, “Column Indexes”</a>.</li>
<li><code>BLOB</code> and <code>TEXT</code> columns cannot have <code>DEFAULT</code> values.</li>
</ul>
</blockquote>
<p>主要的区别就是TEXT和BLOB需要指定前缀位数作为索引，不可以设置默认值</p>
<p>他们的存储方式取决于<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-dynamic">InnoDB Row Formats</a>， 在mysql5.7.9以后默认是dynamic</p>
<p>我们暂且只介绍dynamic模式，在这种存储方式下，数据会尽可能的填充满整个行，但不是我们所谓的65535的上限值，官方提供了一个例子</p>
<pre><code class="language-sql">mysql&gt; CREATE TABLE t4 (
       c1 CHAR(255),c2 CHAR(255),c3 CHAR(255),
       c4 CHAR(255),c5 CHAR(255),c6 CHAR(255),
       c7 CHAR(255),c8 CHAR(255),c9 CHAR(255),
       c10 CHAR(255),c11 CHAR(255),c12 CHAR(255),
       c13 CHAR(255),c14 CHAR(255),c15 CHAR(255),
       c16 CHAR(255),c17 CHAR(255),c18 CHAR(255),
       c19 CHAR(255),c20 CHAR(255),c21 CHAR(255),
       c22 CHAR(255),c23 CHAR(255),c24 CHAR(255),
       c25 CHAR(255),c26 CHAR(255),c27 CHAR(255),
       c28 CHAR(255),c29 CHAR(255),c30 CHAR(255),
       c31 CHAR(255),c32 CHAR(255),c33 CHAR(255)
       ) ENGINE=InnoDB ROW_FORMAT=DYNAMIC DEFAULT CHARSET latin1;
ERROR 1118 (42000): Row size too large (&gt; 8126). Changing some columns to TEXT or BLOB may help.
In current row format, BLOB prefix of 0 bytes is stored inline.
</code></pre>
<p>算算字节数，255*33=8415这点字节还远不到65535，但是却提示超过了8126，这个数是哪来的呢？</p>
<p>原来65535是mysql层判断的，实际存储的时候还需要存储引擎去判断，innoDB的策略是略小于存储页面大小的一半，默认的页面大小是16KB，它的一半就是8192，因此在innoDB看来最大行不能超过8126字节，这样上限我们就搞清楚了</p>
<p>TEXT与BLOB类型都会尽可能的存在这一行中，也就是B+树的叶子节点中，当长度已经满了的时候，会从所有的字段中选择最长的一列放到外部存储，dynamic的思想是，如果要用外部页面存储，就把整个数据都放过去，页内只留20字节的指针指向外部存储，对于长度小于40字节的TEXT和BLOB，并不会转移到外部，而是直接存在行内</p>
<p>BLOB和TEXT都支持M的用法（但是真的别用了，挺没意义的，都已经用这个类型了还纠结长度不如取用varchar，人家速度还快），如果用了M，会返回一个能满足M的要求的最小的预定义的TEXT或BLOB，举个例子：</p>
<pre><code class="language-sql">mysql&gt; alter table test1 add text_test text(20);
mysql&gt; desc test1;
+----------------+--------------------------+------+-----+---------+-------+
| Field          | Type                     | Null | Key | Default | Extra |
+----------------+--------------------------+------+-----+---------+-------+
| int_test_M     | int(3) unsigned zerofill | YES  |     | NULL    |       |
| bit_test_M     | bit(3)                   | YES  |     | NULL    |       |
| decimal_test_M | decimal(65,0)            | YES  |     | NULL    |       |
| binary_test    | binary(6)                | YES  |     | NULL    |       |
| set_test       | set('1','一')            | YES  |     | NULL    |       |
| text_test      | tinytext                 | YES  |     | NULL    |       |
+----------------+--------------------------+------+-----+---------+-------+
6 rows in set (0.02 sec)
</code></pre>
<p>可以看到，text_test并没有像其他的一样有M，而是直接分配了一个tinytext，blob同理，至此字符串基本上讲完了</p>
<h3 id="时间类型">时间类型</h3>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小 ( bytes)</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1000-01-01/9999-12-31</td>
<td style="text-align:left">YYYY-MM-DD</td>
<td style="text-align:left">日期值</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">3</td>
<td style="text-align:left">'-838:59:59'/'838:59:59'</td>
<td style="text-align:left">HH:MM:SS</td>
<td style="text-align:left">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1901/2155</td>
<td style="text-align:left">YYYY</td>
<td style="text-align:left">年份值</td>
</tr>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">8</td>
<td style="text-align:left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td style="text-align:left">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:left">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">4</td>
<td style="text-align:left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07，本质是一个存着时间戳的四字节整型</td>
<td style="text-align:left">YYYYMMDD HHMMSS</td>
<td style="text-align:left">混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<p>datetime和timestamp有个区别就是，当存入数据库的时候，datetime存储的是当前时区的时间，而时间戳是全球统一的，无需担心时区的问题</p>
<ul>
<li>8.0.19版本开始，可以在datetime和timestamp类型修改的时候添加时间偏移量</li>
<li>8.0.22版本开始，支持通过CAST()函数将timestamp转换成特定时区的datetime值</li>
</ul>
<p>举两个魔改的官方例子解释</p>
<pre><code class="language-sql">mysql&gt; SELECT @@system_time_zone; --提示了系统时区，现在是EST，北美东部标准时间，-05:00，我国是+08:00
+--------------------+
| @@system_time_zone |
+--------------------+
| EST                |
+--------------------+

mysql&gt; CREATE TABLE ts (
    -&gt;     id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -&gt;     col TIMESTAMP NOT NULL
    -&gt; ) AUTO_INCREMENT = 1;

mysql&gt; SET @@time_zone = 'SYSTEM'; -- -05:00

mysql&gt; INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');
--这里插入了三个，后两个的含义是，当前时区为+05:30的10.10.10，和当前时区-08:00的10.10.10，如果转换成UTC，分别应该-5.30和+8.00，但和第一个值明显对不上，原因看下一个

mysql&gt; SET @@time_zone = '+00:00';

mysql&gt; INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00'); 
--这里已经将时区切换成标准UTC时间了，再让我们看看结果，下面的23和56都是一样的，也就是说，当我们手动添加时区的偏移量的时候，会屏蔽掉设置的时区 


mysql&gt; SET @@time_zone = 'SYSTEM';
--这里又切换回了-5的时区，导致UTC时间的10.10.10，在显示的时候按照-5的时区显示，变成了05.10.10

mysql&gt; SELECT col, UNIX_TIMESTAMP(col) FROM ts ORDER BY id;
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 | --这里代表了-5:00的时区下的时间
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 05:10:10 |          1577873410 | --这里才是真实的UTC标准时间
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
+---------------------+---------------------+


mysql&gt; CREATE TABLE dt (
    -&gt;     id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -&gt;     col DATETIME NOT NULL
    -&gt; ) AUTO_INCREMENT = 1;

mysql&gt; INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');

mysql&gt; SET @@time_zone = '+00:00';

mysql&gt; INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),
    -&gt;     ('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');
--从这里的1，4可以看到，不管在哪个时区下，datetime的值只取决于获取时的时间，不随时区变化而改变
--但是一旦手动设置了偏移量，偏移量的大小都会先计算一次时区偏移，比如23的结果，都是在10.10.10的基础上-5，然后再-05.30和+08.00
--也就是说它老把自己当成UTC时间，手动改修改偏移量后然后自作聪明的想存进该时区时间，所以会先算一次时区，再计算时间戳

mysql&gt; SET @@time_zone = 'SYSTEM';

mysql&gt; SELECT col, UNIX_TIMESTAMP(col) FROM dt ORDER BY id;
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 10:10:10 |          1577891410 |
| 2020-01-01 04:40:10 |          1577871610 |
| 2020-01-01 18:10:10 |          1577920210 |
+---------------------+---------------------+
</code></pre>
<p>可以看到，timestamp和datetime在面对不一样的时区时做的操作是完全不同的，相比之下timestamp更通用一些</p>
<p>timestamp和datetime还支持自动更新</p>
<pre><code class="language-sql">created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP --创建时间
updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP --更新时间
</code></pre>
<p>至此时间类型也差不多讲完了，空间类型这个是真的一般用不到，等用到了再细究不迟，这里就不再赘述了，现在才发现其实mysql的官方文档才是最好的教程，远比网上搜的东西清楚</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在github上开源自己的包]]></title>
        <id>http://blog.zerokirin.online/post/ru-he-zai-github-shang-kai-yuan-zi-ji-de-bao/</id>
        <link href="http://blog.zerokirin.online/post/ru-he-zai-github-shang-kai-yuan-zi-ji-de-bao/">
        </link>
        <updated>2021-05-07T14:46:53.000Z</updated>
        <content type="html"><![CDATA[<p>由于go没有自带的栈结构，因此我们手写了两种stack方便刷题及日后使用，顺便尝试下开源</p>
<p>由于栈有切片和链表两种实现方式，因此仓库内有两个package，此时有两种发布方式</p>
<h3 id="1-将两个package当作一个module发布">1. 将两个package当作一个module发布</h3>
<p>此时只要在根目录上创建go.mod文件，文件内容如下</p>
<pre><code>module github.com/00LT00/go-stack

go 1.15
</code></pre>
<p>这样我们的module根目录地址就是<code>github.com/00LT00/go-stack</code></p>
<p>此时总文件结构</p>
<pre><code>│  go.mod
│  README.md
│
├─nodelistStack
│      stack.go
│      stack_test.go
│
└─sliceStack
        stack.go
        stack_test.go
</code></pre>
<p>下属的nodelistStack和sliceStack作为go-stack这个module的子package存在</p>
<pre><code class="language-go">import &quot;github.com/00LT00/go-stack&quot;
</code></pre>
<p>此时go.mod文件中会有版本号，和最后一次提交的时间与md5相关</p>
<p>当然也可以打tag，或者通过github release发布一个新的版本，比如现在的最新版就是</p>
<pre><code class="language-go">require github.com/00LT00/go-stack v0.4.0 // 根目录下没有package有可能会报错，应手动写入go.mod中
</code></pre>
<p>当然只是引入了go-stack是肯定不能用的，毕竟根目录下毛都没有，要想用肯定要引入两个package之一</p>
<pre><code class="language-go">import (
	stack1 &quot;github.com/00LT00/go-stack/sliceStack&quot;
	stack2 &quot;github.com/00LT00/go-stack/nodelistStack&quot;
)
</code></pre>
<p>这样的不足之处在于两者依赖同一个tag，如果对其中一个进行修改，打出来的新tag对两个都会生效，因此还有第二种方式</p>
<h3 id="2-发布两个不一样的module">2. 发布两个不一样的module</h3>
<p>文件结构如下</p>
<pre><code>│  README.md
│
├─nodelistStack
|	   go.mod
│      stack.go
│      stack_test.go
│
└─sliceStack
		go.mod
        stack.go
        stack_test.go
</code></pre>
<p>两个go.mod文件开头就自由发挥</p>
<pre><code>module github.com/00LT00/go-stack/nodelistStack

go 1.15
</code></pre>
<pre><code>module github.com/00LT00/go-stack/sliceStack

go 1.15
</code></pre>
<p>这时可以通过github release 发布不同的版本号解决问题</p>
<figure data-type="image" tabindex="1"><img src="https://files.catbox.moe/lurk0v.png" alt="image-20210508002249201" loading="lazy"></figure>
<p>这里就给子目录单独创建了一个版本号 v0.1.3</p>
<p>虽然引用方式和之前没有任何变化，仍然是</p>
<pre><code class="language-go">import (
	stack2 &quot;github.com/00LT00/go-stack/nodelistStack&quot;
)
</code></pre>
<p>但是go.mod文件中已经发生了变化</p>
<pre><code>require github.com/00LT00/go-stack/nodelistStack v0.1.3
</code></pre>
<p>此时这就是一个单独的module，自己管理自己的package，这样的好处是，可以单独对两个目录发布不一样的版本</p>
<figure data-type="image" tabindex="2"><img src="https://files.catbox.moe/p3rjem.png" alt="image-20210508003849181" loading="lazy"></figure>
<p>可以参考<a href="https://golang.org/ref/mod#vcs-version">go mod 官方文档</a></p>
<blockquote>
<p>If a module is defined in a subdirectory within the repository, that is, the module subdirectory portion of the module path is not empty, then each tag name must be prefixed with the module subdirectory, followed by a slash. For example, the module golang.org/x/tools/gopls is defined in the gopls subdirectory of the repository with root path golang.org/x/tools. The version v0.4.0 of that module must have the tag named gopls/v0.4.0 in that repository.</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 运行时（一）]]></title>
        <id>http://blog.zerokirin.online/post/golang-yun-xing-shi-yi/</id>
        <link href="http://blog.zerokirin.online/post/golang-yun-xing-shi-yi/">
        </link>
        <updated>2021-04-23T16:36:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="内存分区">内存分区</h2>
<p>一个应用程序在运行的时候会分出对应的区域</p>
<ol>
<li>
<p>text 代码区</p>
<p>用于存放cpu执行的机器指令，只读</p>
</li>
<li>
<p>data 数据区</p>
<ul>
<li>初始化后的全局变量</li>
<li>初始化后的静态变量（包括全局和局部）</li>
<li>常量</li>
</ul>
</li>
<li>
<p>bss 未初始化区</p>
<ul>
<li>未初始化的全局变量</li>
<li>未初始化的静态变量</li>
</ul>
<p>尽管会被默认分配为零值，但仍属于未初始化区</p>
</li>
<li>
<p>stack 栈区</p>
<p>由编译器自动分配释放的，一般用于存储哈描述的参数值、返回值、局部变量等。一般只有1M，可自动扩充，基本上也就是函数运行的空间，所以无限递归会造成的是栈溢出</p>
<p>分配的方式是从高地址向低地址</p>
</li>
<li>
<p>heap 堆区</p>
<p>由程序员手动分配，手动回收或者较高级语言有GC自动回收</p>
<p>分配的地址是在栈区地址和.bss区之间</p>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://github.com/overnote/over-golang/raw/master/images/go/runtime-02.svg" alt="img" loading="lazy"></figure>
<h2 id="逃逸分析">逃逸分析</h2>
<pre><code class="language-go">func toHeap() *int {
	var x int
	return &amp;x
}

func toStack() int {
	y := new(int)
	*y = 1
	return *y
}

func main() {

}
</code></pre>
<p>如果我们暂时忘记go，用C/C++语言的思维来看，上述的<code>toHeap()</code>函数就是一个典型的空指针错误，在函数内部创建了一个变量，调用结束后将指针返回，而该地址是随着函数的调用而被分配在函数栈上的，因此当调用结束后栈会被清空，该指针就成了一个野指针。而对于<code>toStack</code>函数来说，手动使用new从堆上分配了一块变量，直到使用对应的delete函数手动释放空间</p>
<p>但是在go中，情况完全不同，go在一定程度上消除了堆栈的区别，在编译的时候会自动进行<strong>逃逸分析</strong>，将逃逸的对象放到堆上，不逃逸的对象放到栈上</p>
<p>由于x是返回值，而这个指针会被函数外部进行操作，从外部是可以找到这个变量的，因此就可以说是变量逃逸</p>
<p>第一种情况就可以说发生了逃逸，go会在编译阶段将x放到堆上，而y在函数结束后就无法访问了，因此分配到栈上，随着函数结束而消失</p>
<p>Go的GC判断变量是否回收的实现思路：从每个包级的变量、每个当前运行的函数的局部变量开始，通过指针和引用的访问路径遍历，是否可以找到该变量，如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响后续计算结果。</p>
<h3 id="逃逸案例">逃逸案例</h3>
<ol>
<li>
<p>指针逃逸</p>
<pre><code class="language-go">func f() *int{
    var i int
    i = 1
    return &amp;i
}
</code></pre>
</li>
<li>
<p>局部变量大小过大</p>
<pre><code class="language-go">s := make([]int, 0, 10000)//其实就是stack区不够分了，所以分到heap上
</code></pre>
</li>
<li>
<p>动态类型逃逸</p>
<pre><code class="language-go">cap:= 20
s := make([]int, 0, cap) //大小是动态的，不能确定，因此放入heap
</code></pre>
</li>
<li>
<p>闭包引用逃逸</p>
<pre><code class="language-go">//闭包函数在这里声明了两个隐式变量a，b，当f()被多次调用的时候，其使用的是被Fibonacci()创建出来大的时候的a，b，因此a，b不会随着f()函数的结束而小时，因此会被分配到heap
func Fibonacci() func() int { 
    a, b := 0, 1
	return func() int {
		a, b = b, a+b
		return a
	}
}

f:= Fibonacci()
</code></pre>
</li>
<li>
<p>切片，map逃逸</p>
<pre><code class="language-go">i := 1
s := make([]*int, 0, 10) //m没有被转移给其他的函数调用，也没有分配过大的空间，也不是全局变量，因此没有必要分配到heap上
s = append(s, &amp;i) //i被添加到m中，没有人知道什么时候会用到，因此无论有没有被用到，都会分配到heap上

j := 1
m := make(map[int]*int) //一个道理，也是分配在stack上
m[1] = &amp;j //heap上
</code></pre>
</li>
</ol>
<h3 id="分配位置的原则">分配位置的原则</h3>
<ul>
<li>变量是否被取地址</li>
<li>变量是否发生逃逸</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang基础语法题]]></title>
        <id>http://blog.zerokirin.online/post/golang-ji-chu-yu-fa-ti/</id>
        <link href="http://blog.zerokirin.online/post/golang-ji-chu-yu-fa-ti/">
        </link>
        <updated>2021-04-17T12:10:32.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>使用值为nil的slice、map会发生啥？</p>
<p>slice可以正常添加内容，map会报错，需要通过make分配地址</p>
<pre><code class="language-go">// map 错误示例
func main() {
    var m map[string]int
    m[&quot;one&quot;] = 1  // error: panic: assignment to entry in nil map
    // m := make(map[string]int)// map 的正确声明，分配了实际的内存
}    
 
// slice 正确示例
func main() {
 var s []int
 s = append(s, 1)
}
</code></pre>
<p>再往细了说，slice底层用指针维护了一个数组，无论是empty还是nil都可以通过append进行扩容，毕竟append强制返回一个原类型的结构，但是map的底层是一个叫做hmap的东西，非常复杂，需要通过makemap这个函数进行初始化才能进行使用（比如说最起码得给人一个hash函数不是）因此对着nil直接赋值是不现实的</p>
</li>
<li>
<p>map中key是否存在？</p>
<p>对于不存在的key，map一定会返回默认零值，因此需要通过第二个参数来判断</p>
<pre><code class="language-go">// 错误的 key 检测方式
func main() {
 x := map[string]string{&quot;one&quot;: &quot;2&quot;, &quot;two&quot;: &quot;&quot;, &quot;three&quot;: &quot;3&quot;}
 if v := x[&quot;two&quot;]; v == &quot;&quot; {
  fmt.Println(&quot;key two is no entry&quot;) // 键 two 存不存在都会返回的空字符串
 }
}
 
// 正确示例
func main() {
 x := map[string]string{&quot;one&quot;: &quot;2&quot;, &quot;two&quot;: &quot;&quot;, &quot;three&quot;: &quot;3&quot;}
 if _, ok := x[&quot;two&quot;]; !ok {
  fmt.Println(&quot;key two is no entry&quot;)
 }
}
</code></pre>
<p>两种取值方式调用的是不同的函数，但他们的区别也仅仅就是判断下key存不存在而已</p>
</li>
<li>
<p>string类型可以修改吗</p>
<p>不能，go中的string类型本质是一个slice，里面存储的是utf-8，但是utf-8是不固定长的（utf-8的意义就是为了压缩字节数）英文字母和数字是1个字节，但中文是3或4字节，这就导致如果直接对下标进行操作的话，会导致编码错乱。</p>
<p>要修改可以转换成[]byte类型，此时实质上是把每个字符转换成了rune类型，rune也就是int32的别名，因此4字节可以存储下完整的utf-8中文字符了，不用担心结构错乱</p>
</li>
<li>
<p>switch 默认带有break，如果想和其它语言一样继续执行下一个case，可以写上fallthrough</p>
</li>
<li>
<p>解析json时的默认数据格式</p>
<pre><code class="language-json">Bool                   对应JSON布尔类型
float64                对应JSON数字类型
string                 对应JSON字符串类型
[]interface{}          对应JSON数组
map[string]interface{} 对应JSON对象
nil                    对应JSON的null
</code></pre>
</li>
<li>
<p>简短声明</p>
<p>只能在函数内部进行简短声明，如果是函数外部则只能用var</p>
<p>struct的变量不能用:=（别问我为什么，官方文档说的无法推断）</p>
<p>不能重复申明，至少有一个新的变量名才行</p>
</li>
<li>
<p>map迭代顺序</p>
<p>完全无序，1.9版本以前，如果是对硬编码的map还可以说有序，但是1.10版本在迭代的时候已经纯随机了，详见<a href="http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-map/">go语法基础巩固（map）</a></p>
</li>
<li>
<p>recover</p>
<p>recover函数是用来捕捉祖父级调用时的异常，需要用在defer中</p>
<pre><code class="language-go">func main(){
    defer func(){
        r:= recover()
        log.Println(r)
    }()
    panic(&quot;error&quot;)
}
</code></pre>
</li>
<li>
<p>闭包函数传参数</p>
<p>如果不传参数进去，他们引用的都是同一个变量， 这样当迭代的时候，还没有执行到的goroutine打印出来的是已经变化了的i，不是调用时的i</p>
<pre><code class="language-go">func main(){
    for i:=0;i&lt;10;i++{
        go func(i int){
            fmt.Println(i)
        }(i) //如果不传参会导致他们实际使用的是同一个变量
    }
    ......
}
</code></pre>
</li>
<li>
<p>goroutine内存泄露</p>
<p>本质上就是goroutine函数执行过程中没有正确的结束，因此就不会被释放，最终可能会导致内存越来越高</p>
</li>
<li>
<p>for select 一起使用的时候break 标签跳出</p>
<p>若无标签，直接break只是退出select语句而已</p>
<pre><code class="language-go">func main() {
	var ch chan int
exit:
	for {
		select {
		case v, ok := &lt;-ch:
			if !ok {
				break exit//跳出了整个exit循环，直接到最下方了
			}
			fmt.Println(v)
		}
	}
	
    fmt.Println(&quot;exit&quot;)
}
</code></pre>
</li>
<li>
<p>sort包对slice进行快排及搜索操作</p>
<p>注：当要找的目标不存在时，返回的值是其在排序后因该存在的位置</p>
<pre><code class="language-go">func main() {
	ints := []int{1, 2, 5, 4, 3, 7}
	sort.Ints(ints)
	fmt.Println(sort.SearchInts(ints, 6))
	fmt.Println(sort.SearchInts(ints, 4))
	fmt.Println(ints)
}

------------
5 //没有6，但是6应该放在第5个位置（从0开始）
3 //4在第3个位置
[1 2 3 4 5 7]

</code></pre>
</li>
<li>
<p>数组和切片的区别</p>
<table>
<thead>
<tr>
<th style="text-align:center">数组</th>
<th style="text-align:center">切片</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">值类型</td>
<td style="text-align:center">引用类型</td>
</tr>
<tr>
<td style="text-align:center">var arr [5]int</td>
<td style="text-align:center">var sli []int</td>
</tr>
<tr>
<td style="text-align:center">固定长度</td>
<td style="text-align:center">可变长度</td>
</tr>
<tr>
<td style="text-align:center">作为函数参数时是值传递，复制一份</td>
<td style="text-align:center">引用传递，相当于传了地址，本质上还是通一slice</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>new make 区别</p>
<table>
<thead>
<tr>
<th style="text-align:center">new</th>
<th style="text-align:center">make</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始化一个指向类型的指针</td>
<td style="text-align:center">为slice，map，chan初始化出其需要的</td>
</tr>
<tr>
<td style="text-align:center">返回值是指向分配的零值的指针，因此对引用类型的变量返回的就是nil</td>
<td style="text-align:center">返回的是类型的一个经过初始化的实例</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>for 循环多变量赋值</p>
<p>for循环中如果有多个变量，需要平行赋值</p>
<pre><code class="language-go">for i, j := 0, 0; i &lt; j; i, j = j+1, i+1 { //最后一个 i++,j++是不被允许的，因为这本身就是两个语句
	......
}
</code></pre>
</li>
<li>
<p>go的接口是什么</p>
<p>interface，方法的集合，不关心数据，只关心如何实现，只要实现了interface定义的方法，就可以说实现了该接口，也因此，一个空的interface{}可以说是被所有的数据类型所共有的一个父类，也可以说所有的数据类型都是的本质都是interface，其底层包括eface（无方法），iface（有方法）两种结构</p>
<p>对于第一种，在动态赋值的时候，其内部的_type指针会随数据类型变化</p>
<pre><code class="language-go">//不带函数的interface
var e interface{}
tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}

e = tty
</code></pre>
<p>这里的e完全就是个工具人，赋值以后的结构就是<img src="https://i6448038.github.io/img/reflection/eface2.png" alt="img" loading="lazy"></p>
<p>第二种除了其原本的静态类型指针以外，还有一个动态混合类型指针，eg.</p>
<pre><code class="language-go">//带函数的interface
var r io.Reader 

tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}

r = tty
</code></pre>
<p>这本来是一个静态类型的io.Reader，但是我们知道os.File类型一样实现了Reader方法，因此可以说os.File实现了io.Reader接口，因此<code>r = tty</code>是被允许的这时候，结构就变为了<img src="https://i6448038.github.io/img/reflection/iface2.png" alt="img" loading="lazy"></p>
<p>可以看到，其依然是静态类型io.Reader，但是实际上他已经是动态混合类型了</p>
<p>因此我们可以通过对interface的操作实现多态</p>
</li>
<li>
<p>类型断言</p>
<p>当想知道interface的具体类型时就需要断言</p>
<pre><code class="language-go">var e interface{}
tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return err.Error()
}

e = tty
//接上例
_, ok := e.(*os.File) //断言是否是该类型
if !ok {
    return &quot;error&quot;
}
switch v := e.(type) { //根据e的不同类型选择不同的方法
    case *os.File:
    	return v.Name()
    default:
    	return &quot;error&quot;
}
</code></pre>
</li>
<li>
<p>方法和函数是两个概念</p>
<p>但是怎么看他们也都差不多。。。我更愿意把方法称作成员函数，方法只不过是在函数的基础上，写上了这是属于谁的函数而已</p>
<pre><code class="language-go">func(s Service)Run(){//最奇怪的用法，这里的s是通过值传递调用的，因此这里无论做什么都不能影响原本的s，而且对于大型结构体还会导致频繁的复制。。暂时没用过。。。
    
}

func(s *Service)Run(){//方法，大写开头，因此是公开函数，函数外部可以调用
    foo() //同一个包内调用
}

func foo(){//函数,小写开头，所以是包内函数，其他package不能访问
    
}
</code></pre>
<pre><code class="language-go">type P struct {
	val int
}

func main() {
	p := new(P)
	p.val = 1
	fmt.Printf(&quot;%p,%p,%v\n&quot;, &amp;p, p, p)
	p.addr()
	p.addr2()
	fmt.Printf(&quot;%p,%p,%v\n&quot;, &amp;p, p, p)
}

func (p P) addr() {
	i := &amp;p
	p.val = 2
	fmt.Printf(&quot;%p,%p,%v\n&quot;, &amp;i, &amp;p, p)
}
func (p *P) addr2() {
	fmt.Printf(&quot;%p,%p,%v\n&quot;, &amp;p, p, p)
	p.val = 3
}
------------------------------
0xc000006028,0xc0000120b0,&amp;{1}
0xc000006038,0xc0000120e0,{2}
0xc000006040,0xc0000120b0,&amp;{1}
0xc000006028,0xc0000120b0,&amp;{3}
</code></pre>
<p>可以看到134行很明显是同一个地址，前面的是放p指针的地址，因此函数调用的时候只复制了地址过去，而第2行就明显的是值传递了</p>
</li>
<li>
<p>slice的扩容机制</p>
<ul>
<li>如果申请容量长度大于2倍的旧容量，则最终容量就是新申请的容量</li>
<li>如果旧其切片长度小于1024则新容量变为两倍</li>
<li>如果是大于等于1024，则旧容量增加原来的4分之一，直到大于新容量为止，然后进行内存对齐操作，因此是大于等于</li>
<li>如果容量计算溢出了，那新容量就是溢出之前的值</li>
<li>一旦触发扩容，则扩容后的slice就指向了新的地址</li>
</ul>
</li>
<li>
<p>empty slice 和nil slice</p>
<pre><code class="language-go">func main() {
	s1 := make([]int, 0)
	var s2 []int
	str, _ := json.Marshal(struct {
		S1 interface{} `json:&quot;s1&quot;`
		S2 interface{} `json:&quot;s2&quot;`
	}{
		S1: s1,
		S2: s2,
	})
	fmt.Printf(&quot;%+s&quot;, str)
}
-------------------
{&quot;s1&quot;:[],&quot;s2&quot;:null}
</code></pre>
</li>
<li>
<p>Data Race问题</p>
<p>互斥锁sync.Mutex或者是管道，管道的效率高一点</p>
</li>
<li>
<p>range slice 遍历</p>
<p>用range遍历slice得到的是要给值的拷贝，要对值修改需要用下标访问</p>
</li>
<li>
<p>nil interface</p>
<pre><code class="language-go">func main() {
   var data *byte
   var in interface{}

   fmt.Println(data, data == nil) // &lt;nil&gt; true
   fmt.Println(in, in == nil) // &lt;nil&gt; true

   in = data
   fmt.Println(in, in == nil) // &lt;nil&gt; false // data 值为 nil，但 in 值不为 nil
}
</code></pre>
<p>in原本是一个nil，最后被赋值了一个nil，nil也是个类型，因此赋值过后in就不是nil了，但他指向的值还是nil（没有十年脑血栓写不出这种代码，少一天都不行）</p>
</li>
</ol>
<p>本来以为是个什么考题，结果都是一些基础知识，就当再复习一遍吧</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一次完整的请求及改进]]></title>
        <id>http://blog.zerokirin.online/post/yi-ci-wan-zheng-de-qing-qiu-ji-gai-jin/</id>
        <link href="http://blog.zerokirin.online/post/yi-ci-wan-zheng-de-qing-qiu-ji-gai-jin/">
        </link>
        <updated>2021-04-16T11:48:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="准备阶段">准备阶段</h2>
<p>当你通过网线或者是WIFI连接到宿舍路由器时，无论进行何种访问，首当其冲的都是要清楚的知道自己所处的网络位置，因此需要初始化<strong>IP地址，默认网关，子网掩码</strong>，这决定了最基础的，你在当前局域网内的网络位置</p>
<h3 id="dhcp">DHCP</h3>
<h4 id="发现服务">发现服务</h4>
<ol>
<li><strong>笔记本A</strong>的操作系统首先生成一个<strong>DHCP发现报文</strong></li>
<li>放入一个UDP报文，目的端口67（DHCP服务器），源端口68（DHCP客户端）</li>
<li>UDP报文被放入一个IP数据报，目的IP地址为<code>255.255.255.255</code>（广播地址），源IP地址为<code>0.0.0.0</code>，因为此时A还没有有效的IP地址，所以才要获取呀</li>
<li>IP数据报被放入一个以太网帧，该帧的目的地址是<code>FF:FF:FF:FF:FF:FF</code>（广播地址），源地址是A自己的MAC地址，该帧会被广播到所有与交换机（在这里也就是寝室路由器，它充当了交换机的功能）相连的所有设备</li>
<li>这个以太网帧是第一个由A发送到交换机的帧，该交换机将在所有的出端口把此帧广播出去，包括路由器（寝室路由器的另一个功能）连接的端口</li>
<li>路由器收到该广播帧后进行解析，抽出IP数据报，一看目的地址是广播地址，因此进行处理，根据IP报头中的信息确定是UDP协议，然后抽出UDP，根据UDP端口67到达DHCP服务器，DHCP解析得到<strong>DHCP发现报文</strong></li>
</ol>
<h4 id="服务提供">服务提供</h4>
<p>由于一个局域网下可能会有多个路由器，也会有多个提供DHCP服务的服务器，因此不能直接选定，需要由客户机自己选择DHCP服务器，因此返回的<strong>服务提供报文</strong>的</p>
<ul>
<li>目的地址是广播地址</li>
<li>源地址是自身IP地址</li>
<li>还有DHCP服务号，用于最终选择哪个DHCP服务器</li>
<li>yiaddr（你的IP地址），指最终分给客户端的IP地址</li>
<li>其他若干信息，包括租期时间等等</li>
</ul>
<h4 id="发起请求">发起请求</h4>
<ol>
<li>A生成一个<strong>DHCP请求报文</strong></li>
<li>目的端口67，源端口68</li>
<li>目的IP地址依然是广播地址，源地址是<code>0.0.0.0</code></li>
<li>以太网帧的目的地址依然是广播地址，源地址是A自己的MAC地址</li>
<li>以太网帧通过交换机广播到所有设备上</li>
<li>路由器收到广播后解析，最终得到<strong>DHCP请求报文</strong></li>
</ol>
<p>以上和发现步骤相同，不同的是<strong>DHCP请求报文</strong>多带了一个DHCP服务号，这样即使由多个DHCP服务器，依然能确定选择哪个获取IP地址</p>
<ol start="7">
<li>对应的DHCP服务器将原来已经预分配的yiaddr作为IP地址，将<strong>IP地址，子网掩码，默认网关路由器，DNS服务器</strong>封装为一个DHCP ACK报文</li>
</ol>
<h4 id="处理返回">处理返回</h4>
<p>和服务提供步骤相同，不一样的是<strong>服务提供报文</strong>没有子网掩码等，</p>
<ol>
<li>将<strong>DHCP ACK报文</strong>封装进UDP，目的端口是68（客户端）</li>
<li>放入IP数据报，和服务提供步骤一样，源IP地址是自身IP地址，目的地址是广播地址</li>
<li>最后放入一个以太网帧，源地址是路由器MAC，目的地址是电脑A</li>
<li>由于交换机有自学习能力，在发现服务的时候就已经知道对应的MAC地址怎么转发了</li>
<li>返回到A，A记录并更新自己的状态</li>
</ol>
<p>到这里一个设备已经完整的加入到我们的局域网了</p>
<h2 id="dns和arp">DNS和ARP</h2>
<p>踏出请求的第一步就是获取对应的IP地址，这就是DNS查询</p>
<ol>
<li>
<p>将<code>google.com</code>放入一个UDP报文，目的端口53，源端口就是大于1024的随机一个</p>
</li>
<li>
<p>包装到IP报文中，目的地址是<strong>DNS服务器的IP地址</strong>，源地址就是自身的IP地址</p>
</li>
<li>
<p>由于路由表上没有直接对DNS服务的记录，因此会转发到默认网关路由器上</p>
<p>然而A只是知道了默认网关的IP地址，但以太网帧又不知道转到哪，这就需要ARP协议</p>
<ol>
<li>A生成一个具有目的IP地址（默认网关）的<strong>ARP查询报文</strong></li>
<li>把报文放到一个以太网帧中，该帧的目的地址是广播地址，把帧发送给交换机，交换机（一般情况下是路由器的交换部分）将转发给所有设备</li>
<li>每个设备都会解析报文，如果目的地址和自己的地址符合，就准备一个<strong>ARP回答报文</strong>，包括自己的IP地址和MAC地址</li>
<li>放到以太网帧中，目的地址是A的地址，通过交换机发送给A</li>
<li>A收到<strong>回答报文</strong>后将IP地址和MAC地址保存到ARP表中，下次直接调用就好</li>
</ol>
<p>这样就有了默认网关的MAC地址</p>
</li>
<li>
<p>将IP报文包装到以太网帧中，目标地址是<strong>默认网关的MAC</strong>，经过交换机转发给默认网关</p>
</li>
<li>
<p>默认网关根据自身的路由表选择将报文转发给下一跳路由器，同时<strong>更新目的地址</strong>，源地址保持不变，最终<strong>目的地址应该就是DNS服务器的MAC地址</strong>，路由表的更新由RIP，OSPF等域内协议以及域间协议BGP维护</p>
</li>
<li>
<p>经过重重转发到了DNS服务器，服务器收到查询报文后找到对应的IP地址，生成一个包括IP地址和<code>google.com</code>的UDP报文</p>
</li>
<li>
<p>然后就是放入IP报文和以太网帧，一路转发回到最初的起点A</p>
</li>
</ol>
<p>至此A终于知道了IP地址开始正式的访问</p>
<h2 id="tcp和https">TCP和HTTPS</h2>
<h3 id="建立http连接">建立HTTP连接</h3>
<h4 id="tcp三次握手">TCP三次握手</h4>
<ol>
<li>A生成一个TCP请求报文，四元组（源地址，目的地址，源端口号，目的端口号）填写好，FLAG为SYN</li>
<li>通过中间的路由器和交换机不断地转发到达目的地，然后被解析，服务端生成一个TCP报文，FLAG为SYN ACK</li>
<li>A收到报文后就已经进入连接状态了，对于A来说已经建立连接完成了，下一步就是发送数据，但对于服务端来说还处于同步等待状态，不过它会在下一次收到ACK报文的时候进入连接状态，这个报文可能是已经带有数据的</li>
</ol>
<p>至此，几乎所有准备工作都已经做完了，终于可以开始请求网页了。</p>
<h4 id="http请求">HTTP请求</h4>
<h5 id="请求报文">请求报文</h5>
<figure data-type="image" tabindex="1"><img src="https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png" alt="img" loading="lazy"></figure>
<ul>
<li>请求行 回车符和换行符就是<CR><LF></li>
<li>请求头 除了Host外都是可选的</li>
<li>空行 除了回车符和换行符以外无其他空格</li>
<li>数据</li>
</ul>
<pre><code class="language-http">GET / HTTP/1.1
Host: www.google.com
（注意这里是个空行）
</code></pre>
<p>将报文放入一个TCP报文，然后依据建立好的TCP连接发送出去</p>
<h5 id="响应报文">响应报文</h5>
<p><code>google.coom</code>服务器收到80端口的请求，生成响应报文，将请求的web页面内容放入响应体。</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20131107163544468" alt="img" loading="lazy"></figure>
<ul>
<li>状态行 请求成功的状态码就是200，描述 ok</li>
<li>响应头</li>
<li>空行</li>
<li>响应数据，正文部分</li>
</ul>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Length: 3059
Server: GWS/2.0
Date: Sat, 11 Jan 2003 02:44:04 GMT
Content-Type: text/html
Cache-control: private
Set-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqy
X9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com
Connection: keep-alive

&lt;html&gt;
Hello Google
&lt;/html&gt;
</code></pre>
<p>响应体经过路由器的重重转发，回到了A，A终于拿到了<code>google.com</code>的内容，浏览器将返回来的响应体进行渲染，渲染出了最终的页面。</p>
<h4 id="tcp四次挥手">TCP四次挥手</h4>
<p>连接完成后，当A已经不需要继续请求的时候就会开始回收步骤，结束连接</p>
<ol>
<li>A发送FIN</li>
<li>服务器收到FIN，返回ACK，此时A已经不能向服务器发送消息了，服务器将继续把没发完的发掉</li>
<li>服务器数据发送完毕后，发送FIN</li>
<li>A收到后返回ACK，等待2MSL后如果没收到服务器的消息则释放连接资源，此次链接结束</li>
<li>服务器收到ACK，确定A已经关闭，中断连接</li>
</ol>
<p>至此，从插入网线开始，一次完整的HTTP请求就结束了</p>
<h3 id="http的改进">HTTP的改进</h3>
<h4 id="http11">HTTP/1.1</h4>
<p>上面讲述的是一次完整的HTTP/1.1请求，它相比1.0改进了几个部分</p>
<ol>
<li>长连接，增加了connection报头，通过设置<code>Keep-Alive</code>可以保持HTTP连接不断开，避免了每次请求结束后都要重复释放，重复建立，提高了效率，当客户端像关闭HTTP连接的时候可以再请求头中携带<code>Connction: false</code>来告知服务器关闭请求。</li>
<li>增加了Host请求头，有时候同一个IP地址上会有不同的主机和或网站，因此可以通过携带不同的Host请求头来区分请求的主机。</li>
<li>身份认证，状态管理和缓存机制</li>
<li>断点续传，通过增加range头，请求资源的一部分，响应206</li>
</ol>
<h4 id="http20">HTTP/2.0</h4>
<p>由于1.x版本都是基于文字的，健壮性和性能都受到了挑战，而且长连接并没有解决TCP阻塞问题，于是有了2.0。</p>
<ol>
<li>头部压缩 2.0版本是基于二进制的，类似于TCP报头一样，规定好了位数，这样只需要在服务端和客户端同时维护一份静态的数据字典，用来确定请求头，省去了大部分重复字段</li>
<li>服务端推送，在1.x时代，当网页同时包含了<code>style.css</code>和<code>style.js</code>时，会再重复两次请求去获取两个文件，但是2.0中，服务端可以主动推送相关文件，客户端需要获取的时候就无需重复请求了</li>
<li>引入了帧和流的概念，实现了多路复用，抽象一点理解：
<ol>
<li>每一个帧可看做是一个学生，流可以认为是组（流标识符为帧的属性值），一个班级（一个连接）内学生被分为若干个小组，每一个小组分配不同的具体任务。</li>
<li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个小组任务都需要建立一个班级，多个小组任务多个班级，1:1比例</li>
<li>HTTP/1.1 Pipeling解决方式为，若干个小组任务排队串行化单线程处理，后面小组任务等待前面小组任务完成才能获得执行机会，一旦有任务处理超时等，后续任务只能被阻塞，毫无办法，也就是人们常说的线头阻塞，因此并未实际使用</li>
<li>HTTP/2多个小组任务可同时并行（严格意义上是并发）在班级内执行。一旦某个小组任务耗时严重，但不会影响到其它小组任务正常执行</li>
<li>这样自始至终就只有一个TCP连接，控制权完全在HTTP手中，而且也能最大化利用每个TCP连接可以传输的带宽</li>
</ol>
</li>
</ol>
<p>HTTP2.0对以前的1.x版本也提供了兼容，只需要经过一个二进制分帧层就可以将文本信息转化为对应的二进制头</p>
<h4 id="https">HTTPS</h4>
<p>不管http怎么改进，他始终是明文加密的一种传输方式，因此提出了加密方案——SSL协议，TCP/IP四层协议模型中应该是处于应用层，在OSI七层模型中可以算会话层</p>
<p>SSL的1.0版本有重大的安全缺陷，因此从未公开过，到3.0版本已经证明是成熟的方案了，于是在1999年，SSL3.0被更名成了TLS（传输层安全），TLS1.0实际上就是SSL3.1，这样，当HTTP经过了SSL/TLS协议加密后再传输的方式就被称为HTTPS</p>
<p>注：很多教程里说HTTP2.0要求强制使用HTTPS，其实这并不是2.0的要求，它只是规定了HTTP的协议，真正要求HTTPS的是浏览器</p>
<p>至此，我们的这次请求就由HTTP1.1更换为了HTTPS2.0</p>
<p>对于TLS的详解，请见下章</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[传输层]]></title>
        <id>http://blog.zerokirin.online/post/chuan-shu-ceng/</id>
        <link href="http://blog.zerokirin.online/post/chuan-shu-ceng/">
        </link>
        <updated>2021-04-08T19:16:02.000Z</updated>
        <content type="html"><![CDATA[<p>提供逻辑上<strong>进程间</strong>通信的功能，使应用看起来像是再两个传输层实体之间有一条端到端的逻辑通信信道</p>
<h2 id="主要协议-udp和tcp">主要协议 UDP和TCP</h2>
<ul>
<li>
<p>用户数据报协议 UDP（User Datagram Protocol）</p>
<p>是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
<p>常用于游戏，音视频流媒体等，对数据完整性要求不是很高，但是对实时性有比较高要求的传输</p>
</li>
<li>
<p>传输控制协议 TCP（Transmission Control Protocol）</p>
<p>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p>
<p>由于有拥塞控制，流量控制，及时性必然不如UDP，但可靠</p>
</li>
</ul>
<h2 id="udpuser-datagram-protocol-用户数据报协议">UDP(User Datagram Protocol) 用户数据报协议</h2>
<figure data-type="image" tabindex="1"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="img" loading="lazy"></figure>
<ul>
<li>
<p>伪首部</p>
<p>从IP首部提取出源IP地址和目的IP地址，然后是0x00，然后是IP首部中协议字段的值，UDP是17，然后是UDP的长度，总共12字节。</p>
<p>伪首部仅用作校验和，仅在发送和接收的时候被临时拼出来，计算出校验和后就抛弃，将校验和填入首部</p>
</li>
<li>
<p>源端口（可选）</p>
<p>UDP是无序应答的，因此没有必要记住源端口</p>
</li>
<li>
<p>目的端口</p>
</li>
<li>
<p>长度</p>
<p>就是UDP长度，和伪首部中的一样，最小值是8字节，因为首部已经占了8字节了</p>
<p>由于IP数据包的最大值不能超过64K字节（只有两个字节用来标识长度，2^16= 64K），所以最大长度不能超过（65,535 − 8字节UDP报头 − 20字节）</p>
</li>
<li>
<p>校验和（可选）</p>
<p>若不需要则全部填充0</p>
</li>
<li>
<p>整体结构，图源维基百科</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://files.catbox.moe/glwzey.png" alt="整体结构" loading="lazy"></figure>
<h2 id="tcptransmission-control-protocol传输控制协议">TCP（Transmission Control Protocol）传输控制协议</h2>
<h3 id="tcp结构">TCP结构</h3>
<figure data-type="image" tabindex="3"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img" loading="lazy"></figure>
<ul>
<li>
<p>序号（sequence number）：为每一个字节都编上序号。这里的值代表本报文发送的数据的第一个字节的序号。例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li>
<p>确认号（acknowledgement number）：期望收到的下一个报文段的起始序号，也即已经收到的数据的字节长度加1。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
</li>
<li>
<p>数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
</li>
<li>
<p>保留字段：6bits，保留今后使用，目前置0处理。（但在RFC 3168和RFC 3540中增加了三个标识符，保留字段只剩3bits）</p>
</li>
<li>
<p>标识符</p>
<p>URG：紧急比特，1bit，当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)<br>
ACK：确认比特，1bit，只有当 ACK=1时确认号字段才有效。当 ACK=0 时，确认号无效<br>
PSH：推送比特，1bit，接收方 TCP 收到推送比特置1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付<br>
RST：复位比特，1bit，当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接<br>
SYN：同步比特，1bit，同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文<br>
FIN：终止比特，1bit，用来释放一个连接。当FIN=1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</p>
</li>
<li>
<p>窗口（WIN）：窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</p>
</li>
<li>
<p>校验和（checksum）：生成12字节的伪首部然后计算出来</p>
</li>
<li>
<p>紧急指针：紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。</p>
</li>
<li>
<p>选项字段：最多40字节。每个选项的开始是1字节的kind字段，说明选项的类型。</p>
<ul>
<li>0：选项表结束（1字节）</li>
<li>1：无操作（1字节）用于选项字段之间的字边界对齐。</li>
<li>2：最大报文段长度（4字节，Maximum Segment Size，MSS）通常在创建连接而设置SYN标志的数据包中指明这个选项，指明本端所能接收的最大长度的报文段。通常将MSS设置为（MTU-40）字节，携带TCP报文段的IP数据报的长度就不会超过MTU（MTU最大长度为1518字节，最短为64字节），从而避免本机发生IP分片。只能出现在同步报文段中，否则将被忽略。</li>
<li>3：窗口扩大因子（3字节，wscale），取值0-14。用来把TCP的窗口的值左移的位数，使窗口值乘倍。只能出现在同步报文段中，否则将被忽略。这是因为现在的TCP接收数据缓冲区（接收窗口）的长度通常大于65535字节。</li>
<li>4：sackOK—发送端支持并同意使用SACK选项。</li>
<li>5：SACK实际工作的选项。</li>
<li>8：时间戳（10字节，TCP Timestamps Option，TSopt）
<ul>
<li>发送端的时间戳（Timestamp Value field，TSval，4字节）</li>
<li>时间戳回显应答（Timestamp Echo Reply field，TSecr，4字节）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="tcp连接过程">TCP连接过程</h3>
<h4 id="三次握手">三次握手</h4>
<figure data-type="image" tabindex="4"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" loading="lazy"></figure>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个随机的初始序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个随机的初始序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<h4 id="为什么是三次挥手">为什么是三次挥手</h4>
<p>通俗但不是根本原因的解释：</p>
<blockquote>
<p>A--&gt;B--&gt;A--&gt;B这样传三次能保证A有发有收，B也有发有收。多一次浪费少一次不够。</p>
</blockquote>
<p>详细版本，来源于知乎问题下的回答<a href="https://www.zhihu.com/question/24853633">TCP 为什么是三次握手，而不是两次或四次？ - 知乎 (zhihu.com)</a>）：</p>
<blockquote>
<p>TCP可靠传输的精髓在于，由操作系统随机的选取两个32位长的初始序列号（Initial Sequence Number）</p>
<p>假设A的初始序列号为1000，以该序列号为原点对将要发送的每个字节编号，然后把自己的初始序列号（ISN）发送个B，<strong>让B有个心理准备</strong>，什么编号的数据才是合法的，<strong>可靠的</strong>，同时B还要对A的数据进行确认，如果A收到的确认号为2001，则证明字节编号1001-2000，一共1000个字节的数据已经被<strong>完整接受</strong></p>
<p>（三次握手的过程中，初始x为1000，B的确认码是x+1=1001，所以真正发送的数据的第一个编号是1001，等B收到数据后返回给A的确认码是2001，代表着期望收到2001数据，也就是说，2000以前的数据已经完整收到了）</p>
</blockquote>
<p>所以原因是为了让双方创建好初始号ISN，完整的流程应该是四步：</p>
<ol>
<li>
<p>A 发送同步信号<strong>SYN</strong> + <strong>A's Initial sequence number</strong></p>
<blockquote>
<p>A --&gt; B SYN my sequence number is X</p>
<p>第一次握手SYN为1，表示请你记录下我的ISN</p>
</blockquote>
</li>
<li>
<p>B 确认收到A的同步信号，并记录 A's ISN 到本地，命名 <strong>B's ACK sequence number</strong></p>
</li>
</ol>
<blockquote>
<p>A &lt;-- B ACK your sequence number is X</p>
<p>第二次握手ACK为1，表示收到了</p>
</blockquote>
<ol start="3">
<li>B发送同步信号<strong>SYN</strong> + <strong>B's Initial sequence number</strong></li>
</ol>
<blockquote>
<p>A &lt;-- B SYN my sequence number is Y</p>
<p>第三次握手SYN为1，表示也请你记录下我的ISN</p>
</blockquote>
<ol start="4">
<li>A确认收到B的同步信号，并记录 B's ISN 到本地，命名 <strong>A's ACK sequence number</strong></li>
</ol>
<blockquote>
<p>A --&gt; B ACK your sequence number is Y</p>
<p>第四次握手ACK为1，表示我也受到了你的ISN了，我要开始传数据了哦</p>
</blockquote>
<p>很显然2和3这两个步骤可以合并，**只需要三次握手，**可以提高连接的速度与效率</p>
<p>最最根本的原因就是，三次通信过程是能够确保可靠传输的理论最小值，所以三次握手不是TCP的要求，而是为了满足在IP这种不可靠通信上建立可靠通信</p>
<h4 id="三次握手中丢包了">三次握手中丢包了</h4>
<ol>
<li>
<p>第一个包，A--&gt;B的带有SYN的包没了</p>
<p>A会周期性超时重传，直到B的确认，毕竟是追女孩子，要勤快一点</p>
</li>
<li>
<p>第二个，B--&gt;A的带有ACK+SYN的包没了</p>
<p>B会周期性重传，直到A的确认，女孩子同意了，怎么男的不回消息了？？？不是你先撩我的？？？我再问问</p>
</li>
<li>
<p>第三个包，A--&gt;B带有ACK的包没了</p>
<p>A知道B同意了就变为了Established，但B很好奇A怎么什么反应都没有</p>
<ol>
<li>如果A倒头就睡了打算明天传数据，B就会一直重传问A到底啥情况（对于B来说和 2 情况一样）</li>
<li>如果A直接给B发送了数据，B会自动更改为Established状态并接受状态，原来大猪蹄子只是睡着了没发晚安，不是渣男</li>
<li>如果B要给A发数据是发不了的，毕竟我同意了你竟然一点反应都没有，老娘一肚子火怎么可能跟你说正事，还是会一直重传ACK+SYN，你给老娘个答复！</li>
</ol>
<p>到这一步A--&gt;B的ACK必须被B接受才行，这代表双方都承认了关系的建立</p>
</li>
</ol>
<h4 id="现实情况">现实情况</h4>
<p>客户端发送的请求如果在网络中滞留，那么客户端要很长一段时间才能收到服务端的反馈，客户端等待时间过长后会超时重传，但是这个请求最后还是会到达服务器，如果没有保存两个ISN，那么就无法确认数据包是传输中还是建立连接的包，那么就会打开两个连接。如果有三次握手，双方保存了ISN，则发现错误后直接抛弃就好。</p>
<h4 id="四次挥手">四次挥手</h4>
<figure data-type="image" tabindex="5"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img" loading="lazy"></figure>
<p>ack，seq自始至终的含义是相同的，无需解释，ACK咋建立连接后全都是1，无需分析</p>
<ul>
<li>
<p>A发送释放连接的报文，FIN=1</p>
</li>
<li>
<p>B收到后还可以继续向A发送数据，但A不能向B发送数据</p>
</li>
<li>
<p>当B决定终止时向A发送释放连接报文，FIN=1</p>
</li>
<li>
<p>A收到后发出确认，进入TIME-WAIT状态，等待2个MSL（Maximum Segment Lifetime）时长后释放连接</p>
</li>
<li>
<p>B收到A的确认后释放连接</p>
</li>
</ul>
<h4 id="time-wait">Time-Wait</h4>
<p>A收到B的FIN报文后不是直接close而是先进入TIME-WAIT状态，等待两个MSL的时间，原因有两个：</p>
<ul>
<li>如果最后一个A--&gt;B的包丢了，那么对于A来说，A时刻+1MSL时还没到达B，B就应该重传了，B重传的时长最多是1MSL，因此A最多等待2MSL就能收到B的重传报文，如果没收到那就证明B已经ok了</li>
<li>让本链接持续时间内所产生的所有报文都从网络消失掉，使下一个新的连接创建的时候不会出现旧的报文</li>
</ul>
<h3 id="tcp可靠传输">TCP可靠传输</h3>
<p>TCP使用重传来实现可靠传输：如果一个已经发送的报文在超时时间内没有收到确认报文，则重传报文</p>
<p>一个报文的往返时间为RTT（Round Trip Time） <code>RTTs=(1-a)*(RTTs)+a*RTT</code> （并未被广泛使用，后来发明了新的算法）a一般为0.8-0.9</p>
<p>超时重传的超时时间为RTO（Restransmission TimeOut）<code>RTO=RTTs+4*RTTd</code></p>
<ul>
<li>
<p>RTO不能小于RTT否则会大量的重传</p>
</li>
<li>
<p>RTO不能太大，否则延迟会变得很大</p>
</li>
<li>
<p>因此RTO应该略大于RTT</p>
</li>
</ul>
<blockquote>
<h5 id="jacobson-karels-算法">Jacobson / Karels 算法</h5>
<p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看<a href="http://tools.ietf.org/html/rfc6298">RFC6289</a>）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）</p>
<p><strong>SRTT</strong> <strong>= S</strong> <strong>RTT</strong>  <strong>+ α</strong> <strong>(</strong> <strong>RTT</strong> <strong>– S</strong> <strong>RTT</strong> <strong>)</strong>  —— 计算平滑RTT</p>
<p><strong>DevRTT</strong> <strong>= (1-β</strong> *<em>)* ** <strong>DevRTT</strong> <strong>+ β</strong></em> <strong>(|</strong> <strong>RTT-SRTT</strong> <strong>|)</strong> ——计算平滑RTT和真实的差距（加权移动平均）</p>
<p><strong>RTO= µ * SRTT + ∂ *DevRTT</strong> —— 神一样的公式</p>
<p>（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609">tcp_rtt_estimator</a>）。</p>
<p>——来源<a href="https://coolshell.cn/articles/11609.html#Karn_Partridge_%E7%AE%97%E6%B3%95">TCP 的那些事儿（下） | 酷 壳 - CoolShell</a></p>
</blockquote>
<h3 id="tcp分段">TCP分段</h3>
<p>这里引入两个概念</p>
<ul>
<li>MTU（Maximum Transmission Unit）最大传输单元，以太网的MTU为1500字节，因此IP包只有1480</li>
<li>MSS（Maximum Segment Size）最大分段大小，这是一个TCP协议中的定义，MSS应该等于MTU-40，也就是1460，但若是双方未指定MSS大小的话，默认情况下MSS大小是536字节，这是因为 <a href="http://tools.ietf.org/html/rfc791">RFC 791</a>里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，网络中不只有以太网，还有很多其他连接方式，而576减去IP头的20个字节和TCP头的20个字节就是536）。</li>
</ul>
<p>为什么要主动引入MSS呢，看起来不是和MTU差不多吗？</p>
<p>其实是因为网络层数据包对IP包来说是透明的，像UDP没有引入MSS，且不会主动分段的话，直接交由IP封装的结果就是这样：</p>
<figure data-type="image" tabindex="6"><img src="https://files.catbox.moe/272t08.png" alt="UDP分段" loading="lazy"></figure>
<p>等接收方拿到第二个包的时候直接就扔了，也就是UDP不讲究。。。</p>
<p>但是对于可靠传输的TCP，这是完全不能忍受的，因此TCP会自己分段，保证自己发出的时候就不大于IP的MTU，别让IP帮我分</p>
<figure data-type="image" tabindex="7"><img src="https://files.catbox.moe/xkj8vx.png" alt="TCP分段" loading="lazy"></figure>
<p>这样第二个包也会被接收端正确解析</p>
<h3 id="tcp滑动窗口">TCP滑动窗口</h3>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文中的WIN字段告知发送方应该发送多大的数据，发送方收到报文后设置自己的窗口大小。</p>
<ul>
<li>
<p>发送窗口</p>
<p>发送窗口内的字节都允许被发送，如果发送窗口左边的字节已经发送并且收到了确认（ack），那么就讲发送窗口向右滑动一定距离，直到左边第一个没被确认的字节为止。</p>
</li>
<li>
<p>接收窗口</p>
<p>接收窗口内的字节都允许被接受，接收窗口只会对最后一个按序到达的字节进行确认，确认后向右滑动接收窗口。</p>
<p>例如：接收窗口已经收到了字节{31，34，35...}，其中{31}是按序到达的，因此只对31进行确认，同时向右滑动，当发送方接收到31的确认时，就知道31号之前的都已经被正确接受了</p>
</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" alt="img" loading="lazy"></figure>
<h4 id="zero-window">Zero Window</h4>
<p>如果某种原因导致接收端返回的确认报文中WIN=0，那么发送端就不会发送数据了，等到接收方的WIN腾出来了应该怎么告诉发送端呢？</p>
<p>这就是ZWP（Zero Window Probe），发送端在窗口变为0后会发送ZWP包给接收方，让接收方来重新设置WIN大小，具体重传次数和间隔看实现方案。如果多次仍为0，就可以直接RST</p>
<h4 id="silly-window-syndrome">Silly Window Syndrome</h4>
<p>翻译成中文就是“愚蠢窗口综合征”，其实也就是TCP的流量控制部分。如果接收方繁忙，每次都只能腾出一两个字节的WIN，但发送方仍会义无反顾地发送数据，但这样很浪费空间，一两个字节要经过TCP包，IP包的封装，仅仅是报文头部就最少有40个字节</p>
<p>一次传输肯定是越接近MTU最好，这样对带宽的利用率最大，不会浪费，因此为了避免数据包太小，那就憋着，等窗口够大了再发送数据，类似于大巴车等人满了再发车一个道理。发送方和接收方都有解决办法：</p>
<ul>
<li>
<p>接收端：</p>
<p>使用David D Clark’s方案。如果收到的数据或者自己处理太慢了，导致WIN小于某个值，就直接窗口0，啥也别发了，等缓过来，<strong>数据大于等于MSS，或者接受buffer腾出一半空间了再设置正常的窗口大小</strong>就好</p>
</li>
<li>
<p>发送端：</p>
<p>使用著名的<a href="https://zh.wikipedia.org/wiki/%E7%B4%8D%E6%A0%BC%E7%AE%97%E6%B3%95">纳格算法</a>，本质思路也是延迟等待。</p>
<pre><code> if有新資料要傳送
   if訊窗大小&gt;= MSS and可傳送的資料&gt;= MSS
     立刻傳送完整MSS大小的segment
   else
    if管線中有尚未確認的資料
      在下一個確認（ACK）封包收到前，將資料排進緩衝區佇列
    else
      立即傳送資料  
</code></pre>
<p>有两个条件：</p>
<ul>
<li>窗口大小&gt;=MSS 且 数据大小&gt;=MSS，立刻发送数据段（Segment）</li>
<li>收到了之前发送的未确认数据的ACK回包，立刻发送数据</li>
</ul>
<p>不过要注意，纳格算法不能和<a href="https://zh.wikipedia.org/wiki/TCP%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4">TCP延迟确认</a>同时开启，TCP延迟确认是将多个ACK回包合并成一个，节约利用资源（毕竟首部太大了），当两者同时开启的时候，一个憋着ACK不放，一个ACK不来不发，两人活生生就憋死了。</p>
<p>另外，纳格算法是默认打开的，但是对于SSH，telnet这种交互性程序，发送的都是小包，就需要主动关闭纳格算法。</p>
</li>
</ul>
<h3 id="tcp拥塞控制">TCP拥塞控制</h3>
<p>主要有四个阶段：</p>
<ol>
<li>慢启动（slow start）</li>
<li>拥塞避免（Congestion Avoidance）</li>
<li>拥塞发生</li>
<li>快速恢复（Fast Recovery）</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://segmentfault.com/img/remote/1460000023924957" alt="img" loading="lazy"></figure>
<h4 id="慢启动">慢启动</h4>
<ol>
<li>连接建立好后初始化一个cwnd（congestion window）=1，表示可以传输一个MSS大小的数据</li>
<li>每当收到一个ACK，cwnd++；线性上升（其实是指数增长）</li>
<li>2的结果是，每当过了一个RTT后，cwnd会刚好变为cwnd*2，因为第一次是一个ACK，所以增加一次，第二次是两个ACK所以增加两次</li>
<li>还有一个ssthresh（slow start threshold）慢启动阈值，<strong>cwnd&gt;=ssthresh后会进入拥塞避免阶段</strong></li>
</ol>
<h4 id="拥塞避免">拥塞避免</h4>
<ol>
<li>收到一个ACK时，cwnd = cwnd+1/cwnd；（其实是线性增长）</li>
<li>1的结果是，每当过了一个RTT后，cwnd =cwnd+1；因为cwnd正好等于可以发送的MSS数量大小，因此ACK的数量就等于cwnd</li>
</ol>
<h4 id="拥塞发生">拥塞发生</h4>
<p>当丢包的时候，有两种方法</p>
<ul>
<li>超时重传，也就是超过RTO的时长就重传，同时进行拥塞控制
<ol>
<li>sshthresh = cwnd/2</li>
<li>cwnd重置为1</li>
<li>进入慢启动过程</li>
</ol>
</li>
<li>快重传（Fast Retransmit），收到三个重复的ACK时就重传，无需等到RTO超时
<ul>
<li>TCP Tahoe：方法和超时一样</li>
<li>TCP Reno：
<ol>
<li>cwnd = cwnd/2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="快速恢复">快速恢复</h4>
<p>TCP Reno中定义的快速恢复算法是这样的：</p>
<ol>
<li>cwnd = sshthresh +3（意思是确认有三个数据包收到了）</li>
<li>重传这个重复的ACK指定的数据包</li>
<li>如果还是收到那个重复的ACK，cwnd = cwnd+1</li>
<li>如果收到了新的ACK，那么cwnd = sshthresh</li>
<li>进入拥塞避免状态</li>
</ol>
<p>然而如果不止重复ACK丢失的话，仅仅重传重复ACK，其他的还是会触发RTO超时重传，但是目前所说的所有方法都没办法知道到底是丢了几个数据包，除非使用SACK字段，但这需要通信双方都支持，基于SACK也有新的FACK算法进行拥塞控制，但若是不支持SACK就没办法了，因此提出了一个新的 TCP New Reno</p>
<ol>
<li>
<p>重传重复的数据包，根据返回的ack和已经发送的seq+长度进行对比，就可以推理出是否有其他包丢失</p>
<p>比如说发送方的seq = 1，长度20，正确的ack应该是21，如果此时收到了三个ack=5，如果说只有5号丢了，那第5号数据发送过去后返回的ack应该时21，如果返回是11，则证明11也丢了，甚至时12，13等等</p>
</li>
<li>
<p>与正确的ack不匹配的被称作Partial ACK，当发送方接收到Partial ACK后会一直重传没有被ack的第一个包，直到再也收不到Partial ACK，结束了快速恢复状态</p>
</li>
<li>
<p>进入拥塞避免阶段</p>
</li>
</ol>
<blockquote>
<p>本文大量引用他人文章，仅作个人笔记使用<br>
[CS-Notes (gitee.io)](http://cyc2018.gitee.io/cs-notes/#/notes/计算机网络 - 传输层)<br>
<a href="https://coolshell.cn/articles/11609.html#TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">TCP 的那些事儿（下） | 酷 壳 - CoolShell</a><br>
<a href="https://segmentfault.com/a/1190000023924934">万字长文 | 23 个问题 TCP 疑难杂症全解析 - SegmentFault 思否</a><br>
<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81">传输控制协议 - 维基百科，自由的百科全书 (wikipedia.org)</a><br>
<a href="https://draveness.me/whys-the-design-tcp-segment-ip-packet/">为什么 TCP/IP 协议会拆分数据 - 面向信仰编程 (draveness.me)</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络层]]></title>
        <id>http://blog.zerokirin.online/post/wang-luo-ceng/</id>
        <link href="http://blog.zerokirin.online/post/wang-luo-ceng/">
        </link>
        <updated>2021-04-01T09:06:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ip协议internet-protocol">IP协议（Internet Protocol）</h2>
<h3 id="数据报格式">数据报格式</h3>
<figure data-type="image" tabindex="1"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="img" loading="lazy"></figure>
<ul>
<li>
<p>版本：ipv4和ipv6</p>
</li>
<li>
<p>首部长度：一共4位，最多只有15，单位是4字节大小，数据报固定首部长度有20个字节，因此首部长度最短为5</p>
</li>
<li>
<p>区分服务：一般不使用</p>
</li>
<li>
<p>总长度：定义了报文的总长度，单位是字节，最短为固定首部长度（20）</p>
</li>
<li>
<p>标识：唯一的标识一个报文的所有分片，因为分片不一定按顺序到达，重组的时候需要知道顺序</p>
</li>
<li>
<p>标志：三个bit分别用于：</p>
<ul>
<li>位0：保留，必须为0；</li>
<li>位1：禁止分片（Don’t Fragment，DF），当DF=0时才允许分片；</li>
<li>位2：更多分片（More Fragment，MF），MF=1代表后面还有分片，MF=0 代表已经是最后一个分片。</li>
</ul>
<p>如果DF标志被设置为1，但路由要求必须分片报文，此报文会被丢弃。这个标志可被用于发往没有能力组装分片的主机。</p>
</li>
<li>
<p>片偏移：单位为8字节，当有分片时，指示该分片相对于报文起始地址的偏移量（对于最后一个分片的报文，由于片偏移不为零，尽管MF字段是0，依然能够确定这是个分片的数据包，而不是不分片数据包(MF=0)）</p>
<figure data-type="image" tabindex="2"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png" alt="img" loading="lazy"></figure>
</li>
<li>
<p>生存时间：定义的是该数据包在互联网中存在的时长，以秒为单位，但后来被用作了跳数计算器，每经历一次转发就将该字段减一，当字段为0时，不在向下跳转，最大值255</p>
</li>
<li>
<p>协议：指出数据应该交给哪个协议进行处理，例如ICMP，TCP，UDP</p>
</li>
<li>
<p>首部校验和：只检查首部，每一跳都要重新计算（最起码TTL发生了改变，偏移量和标志位也有可能变化），然后对比，不相同就丢弃</p>
</li>
<li>
<p>源地址、目标地址：一共32位</p>
</li>
<li>
<p>可选字段：不常用，1-40字节不等，参考维基百科上的表格</p>
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">长度（位）</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>备份</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">当此选项需要被备份到所有分片中时，设为1。</td>
</tr>
<tr>
<td style="text-align:center"><strong>类</strong></td>
<td style="text-align:center">2</td>
<td style="text-align:center">常规的选项类别，0为“控制”，2为“查错和措施”，1和3保留。</td>
</tr>
<tr>
<td style="text-align:center"><strong>数字</strong></td>
<td style="text-align:center">5</td>
<td style="text-align:center">指明一个选项。</td>
</tr>
<tr>
<td style="text-align:center"><strong>长度</strong></td>
<td style="text-align:center">8</td>
<td style="text-align:center">指明整个选项的长度，对于简单的选项此字段可能不存在。</td>
</tr>
<tr>
<td style="text-align:center"><strong>数据</strong></td>
<td style="text-align:center">可变</td>
<td style="text-align:center">选项相关数据，对于简单的选项此字段可能不存在。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>填充：记得最上面的首部长度吗，当有可选字段的时候，首部长度就一定大于20字节了，而首部长度的单位是4字节，因此当可选字段不是4的整数倍的时候，需要填充为EOL（选项列表结束，0x00）</p>
</li>
</ul>
<h2 id="ip地址编址方式">IP地址编址方式</h2>
<p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h3 id="分类">分类</h3>
<p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<figure data-type="image" tabindex="3"><img src="https://pic3.zhimg.com/80/v2-13c1daebb7b5706a847f4e727d9dacde_720w.jpg" alt="img" loading="lazy"></figure>
<h3 id="子网划分">子网划分</h3>
<p>可以看出，两级 IP 地址 不够灵活, 对 IP 地址空间的利用率比较低。如, C 类地址的局域网最多分配 254 个主机号, B 类地址的局域网最多分配 65534 个主机号。如果有个单位有 255 台主机，则只能为其分配一个 B 类地址的 网络号。这样就会浪费很多 IP 地址。</p>
<p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<h3 id="无分类">无分类</h3>
<p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为超网 。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<h3 id="网络地址和广播地址">网络地址和广播地址</h3>
<p>其实就是特殊的主机地址，由于IP = 网络号+主机号</p>
<ul>
<li>主机号全为0的时候就是网络地址</li>
<li>全为1的时候就是广播地址</li>
</ul>
<h4 id="举例">举例：</h4>
<p>一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在网络的网络地址和广播地址</p>
<p><code>255.255.255.224</code> 转二进制：</p>
<pre><code>11111111 11111111 11111111 11100000
</code></pre>
<p>则IP地址的前27位是网络号，后5位是主机号</p>
<p><code>202.112.14.137</code>转二进制：</p>
<table>
<thead>
<tr>
<th>11001010 01110000 00001110 100</th>
<th>01001</th>
</tr>
</thead>
<tbody>
<tr>
<td>网络号</td>
<td>主机号</td>
</tr>
</tbody>
</table>
<p>广播地址是<code>11001010 01110000 00001110 100</code> <code>11111</code> 即<code>202.112.14.159</code></p>
<p>网络地址是<code>11001010 01110000 00001110 100</code> <code>00000</code> 即<code>202.112.14.128</code></p>
<h2 id="地址解析协议arpaddress-resolution-protocol">地址解析协议ARP（Address Resolution Protocol）</h2>
<p>将IP地址转换为MAC地址的协议</p>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<figure data-type="image" tabindex="4"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8006a450-6c2f-498c-a928-c927f758b1d0.png" alt="img" loading="lazy"></figure>
<p>维基百科中说的更详细一些</p>
<blockquote>
<p>1.当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可。</p>
<p>2.如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？”</p>
<p>3.网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”，此回应以单播方式。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP高速缓存（ARP cache），下次再向主机B发送信息时，直接从ARP缓存表里查找就可。</p>
</blockquote>
<h2 id="网际控制报文协议icmpinternet-control-message-protocol">网际控制报文协议ICMP（Internet Control Message Protocol）</h2>
<blockquote>
<p>它用于网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。</p>
<p>——维基百科</p>
</blockquote>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<figure data-type="image" tabindex="5"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" alt="img" loading="lazy"></figure>
<p>ICMP 报文分为差错报告报文和询问报文。</p>
<figure data-type="image" tabindex="6"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" alt="img" loading="lazy"></figure>
<h3 id="常见应用">常见应用</h3>
<ul>
<li>
<p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
</li>
<li>
<p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
</li>
</ul>
<h2 id="路由器的结构">路由器的结构</h2>
<p>路由器从功能上可以划分为：路由选择和分组转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<figure data-type="image" tabindex="7"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c3369072-c740-43b0-b276-202bd1d3960d.jpg" alt="img" loading="lazy"></figure>
<h3 id="路由转发流程">路由转发流程</h3>
<figure data-type="image" tabindex="8"><img src="https://files.catbox.moe/21o038.png" alt="路由转发" loading="lazy"></figure>
<ul>
<li>
<p>提取出目的主机的IP地址D，然后得到网络地址N</p>
</li>
<li>
<p>若N是此路由器直接连着的地址，直接解析，否则就是间接交付</p>
</li>
<li>
<p>间接交付</p>
<ul>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1ab49e39-012b-4383-8284-26570987e3c4.jpg" alt="img" loading="lazy"></figure>
<h2 id="路由选择协议">路由选择协议</h2>
<p>用于调整路由表的可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GMP模型简介]]></title>
        <id>http://blog.zerokirin.online/post/gmp-mo-xing-jian-jie/</id>
        <link href="http://blog.zerokirin.online/post/gmp-mo-xing-jian-jie/">
        </link>
        <updated>2021-03-21T09:53:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>[<a href="https://learnku.com/articles/41728">典藏版] Golang 调度器 GMP 原理与调度全分析 | Go 技术论坛 (learnku.com)</a></p>
<p>大量文字和图片来源于上文，以下仅为个人理解转述，仅作笔记使用</p>
</blockquote>
<h2 id="进程线程">进程&amp;线程</h2>
<ul>
<li>
<p>根本区别：</p>
<ul>
<li>进程是操作系统资源分配的基本单位</li>
<li>线程是处理器<strong>任务调度和执行的基本单位</strong></li>
</ul>
</li>
<li>
<p>资源开销：</p>
<ul>
<li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销</li>
<li>线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</li>
</ul>
</li>
<li>
<p>包含关系：</p>
<ul>
<li>线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li>
</ul>
</li>
<li>
<p>内存分配：</p>
<ul>
<li>同一进程的线程共享本进程的地址空间和资源</li>
<li>而进程之间的地址空间和资源是相互独立的</li>
</ul>
</li>
<li>
<p>影响关系：</p>
<ul>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响</li>
<li>一个线程崩溃整个进程都死掉，所以多进程要比多线程健壮</li>
</ul>
</li>
</ul>
<h2 id="内核态用户态">内核态&amp;用户态</h2>
<p>简单的说，用户的应用程序运行在用户态，内核程序运行在内核态，<strong>任何资源调度都需要进入内核态执行</strong></p>
<p>详细一点，以32位linux操作系统为例，2^32 = 4G，所以每个进程最多可以访问4G的内存空间（虚拟内存），操作系统将高地址的1G空间分配给了内核态，低地址的3G分配给用户态，又由于内核操作是唯一的，不随用户程序的不同而改变，因此可以说内核态的空间是所有进程共享的，而用户态的空间属于进程独有（实际上大家都是访问的虚拟地址，只不过对于内核态的代码始终映射到了同一空间，用户态就完全随机了）</p>
<p>再详细一点，intel提供了R0-R3一共四个等级的权限，而linux使用了R0和R3两个等级作为区分，R3最低，应用程序运行在3级的时候就是用户态，运行在0级的时候就是内核态，用户态到内核态一共有三种转换方式：</p>
<ul>
<li>
<p>系统调用（主动）</p>
<ul>
<li>使用系统提供的服务，比如请求键盘输入，这时会从用户态切换到内核态，因为用户态的程序无法调用系统资源，任何资源调用都是由内核态程序完成的</li>
<li>本质就是用户程序向系统发出了一个中断信号<code>int 80h</code>，通过中断信号告诉操作系统来将应用程序调入内核态</li>
</ul>
</li>
<li>
<p>异常（被动）</p>
<ul>
<li>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li>
</ul>
</li>
<li>
<p>外围设备中断（被动）</p>
<ul>
<li>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li>
</ul>
</li>
</ul>
<h2 id="协程">协程</h2>
<h3 id="线程的优缺点">线程的优缺点</h3>
<ul>
<li>
<p>缺点</p>
<ul>
<li>即便他的资源依赖进程，上下文切换的时候无需切换内存空间，但上文提到过，线程是操作系统任务调度的最小资源，也就意味着线程的切换仍然是内核操作，<strong>这就会使应用程序频繁的处于用户态内核态的切换中</strong>，这中间无疑是对cpu的浪费</li>
<li>创建一个线程需要8MB大小的空间（ubuntu18.04默认的线程栈大小），一千个线程就是8g的空间，非常夸张</li>
</ul>
</li>
<li>
<p>优点</p>
<ul>
<li>系统调度的最小单元，意味着它是<strong>真正的并行执行</strong>，可以同时运行在多个不同的cpu核心上</li>
</ul>
</li>
</ul>
<h3 id="协程的概念">协程的概念</h3>
<p>根据上文可以看到多线程模型在运算效率上很高，因为它可以充分利用多核优势，但是每次线程的切换都需要内核介入，就导致在某些场景下大量的资源被浪费在程序状态的转换上，有没有可能让内核不介入线程的切换呢？</p>
<p>协程应运而生，也可以说它是用户态的线程，将线程调度这一概念放到了用户态去做，让用户态的程序自己控制调度程序，避免频繁切换。</p>
<p>协程的执行则是通过绑定到不同的线程去执行，因为只有线程才是执行的最小单位，因此<strong>怎么将线程和协程绑定能最大化利用资源则是重中之重</strong></p>
<figure data-type="image" tabindex="1"><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/ANDQLx3g9U.png!large" alt="协程" loading="lazy"></figure>
<p>golang中通过提出了goroutine来实现协程这个概念，用go scheduler在用户态做调度。</p>
<p>协程和线程主要区别：</p>
<ul>
<li>线程是由操作系统调度的，是抢占式的</li>
<li>协程是协作式的，执行完毕由调度器控制自动让出资源</li>
<li>协程说到底还是绑定到线程执行的，因此绑定到同一个线程下的协程只能是串行，无法做到并行处理</li>
</ul>
<h2 id="gmp模型">GMP模型</h2>
<p>提出三个概念</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/zaZ4nQYcZe.png!large" alt="GMP" loading="lazy"></figure>
<ul>
<li>G goroutine 协程</li>
<li>M thread 线程</li>
<li>P processor <strong>它包含了运行 goroutine 的资源</strong>，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/Ugu3C2WSpM.jpeg!large" alt="GMP" loading="lazy"></figure>
<p><s>（这图做的是真好，一目了然，都不需要讲什么了）</s></p>
<h5 id="p的数量">P的数量</h5>
<p>通过<code>GOMAXPROCS</code>这个变量来控制整个程序中P的数量，这是在调度器初始化的时候就确定好的，P不随程序运行改变，默认值是cpu核心数，因为整个模型中，P通过绑定M去执行操作，而M也就是线程，最多可以并行执行的数量就是cpu核心数，因此这样可以最大化利用资源，减少浪费</p>
<h5 id="m的数量">M的数量</h5>
<p>由于每个P都必须绑定一个M，通过绑定的M去执行P上的G，因此M的数量至少等于P（休眠状态另算）</p>
<p>当M被阻塞时，P上的G就无法继续执行，此时就会创造一个新的M，因此通常来说M的数量要大于P</p>
<h3 id="调度器初始化的过程">调度器初始化的过程</h3>
<figure data-type="image" tabindex="4"><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/j37FX8nek9.png!large" alt="调度器初始化" loading="lazy"></figure>
<p>特殊的 M0 和 G0</p>
<h5 id="m0">M0</h5>
<p>M0 是启动程序后的编号为 0 的主线程，相当于程序的起点，企业的创始人，在这里初始化了调度器，然后启动第一个G（也就是主函数main），在这后M0就和其他的M一样了，从创始人沦为打工仔</p>
<h5 id="g0">G0</h5>
<p>G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，相当于一个总经理把任务G指派给M执行，G0 不指向任何可执行的函数，他自己不干活，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</p>
<h3 id="一个程序运行的全过程">一个程序运行的全过程</h3>
<ol>
<li>runtime 创建最初的线程 m0 和 goroutine g0，并把 2 者关联。</li>
<li>调度器初始化：初始化 m0、栈、垃圾回收，以及创建和初始化由 GOMAXPROCS 个 P 构成的 P 列表。</li>
<li>示例代码中的 main 函数是 main.main，runtime 中也有 1 个 main 函数 ——runtime.main，代码经过编译后，runtime.main 会调用 main.main，程序启动时会为 runtime.main 创建 goroutine，称它为 main goroutine 吧，然后把 main goroutine 加入到 P 的本地队列。</li>
<li>启动 m0，m0 已经绑定了 P，会从 P 的本地队列获取 G，获取到 main goroutine。</li>
<li>G 拥有栈，M 根据 G 中的栈信息和调度信息设置运行环境</li>
<li>M 运行 G</li>
<li>G 退出，再次回到 M 获取可运行的 G，这样重复下去，直到 main.main 退出，runtime.main 执行 Defer 和 Panic 处理，或调用 runtime.exit 退出程序。</li>
</ol>
<h3 id="一个goroutine的执行顺序">一个goroutine的执行顺序</h3>
<figure data-type="image" tabindex="5"><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/a4vWtvRWGQ.jpeg!large" alt="调度执行顺序" loading="lazy"></figure>
<p>从上图我们可以分析出几个结论：</p>
<ol>
<li>有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；</li>
<li>G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行；</li>
<li>一个 M 调度 G 执行的过程是一个循环机制；</li>
<li>当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；</li>
<li>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，<strong>然后这个 G 会被放入全局队列中</strong>。</li>
</ol>
<h2 id="完整的调度过程全解析">完整的调度过程全解析</h2>
<p><s>（这图画的真的绝了，看图说话吧）</s></p>
<ol>
<li>
<p>P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用 <code>go func()</code> 创建了 G2，为了局部性 G2 优先加入到 P1 的本地队列。</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/Pm8LOYcsWQ.png!large" alt="1" loading="lazy"></figure>
</li>
<li>
<p>G1 运行完成后 (函数：goexit)，M 上运行的 goroutine 切换为 G0，G0 负责调度时协程的切换（函数：schedule）。从 P 的本地队列取 G2（偷取其他队列的G直到没有G），从 G0 切换到 G2，并开始运行 G2 (函数：execute)。实现了线程 M1 的复用。</p>
<figure data-type="image" tabindex="7"><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/JWDtmKG3rK.png!large" alt="2" loading="lazy"></figure>
</li>
<li>
<p>假设每个 P 的本地队列只能存 3 个 G。G2 要创建了 6 个 G，前 3 个 G（G3, G4, G5）已经加入 p1 的本地队列，p1 本地队列满了。</p>
<figure data-type="image" tabindex="8"><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/UpjRxzIBd3.png!large" alt="3" loading="lazy"></figure>
</li>
<li>
<p>G2 在创建 G7 的时候，发现 P1 的本地队列已满，需要执行<strong>负载均衡</strong> (把 P1 中本地队列中前一半的 G，还有新创建 G <strong>转移</strong>到全局队列)</p>
<p>这些 G 被转移到全局队列时，会被打乱顺序。所以 G3,G4,G7 被转移到全局队列。</p>
<figure data-type="image" tabindex="9"><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/chqTgsiuWi.png!large" alt="4" loading="lazy"></figure>
</li>
<li>
<p>G2 创建 G8 时，P1 的本地队列未满（挪走了前一半去全局了），所以 G8 会被加入到 P1 的本地队列。</p>
<figure data-type="image" tabindex="10"><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/nukEY92G6D.png!large" alt="5" loading="lazy"></figure>
</li>
<li>
<p>规定：<strong>在创建 G 时，运行的 G 会尝试唤醒其他空闲的 P 和 M 组合去执行</strong>。</p>
<p>假定 G2 唤醒了 M2，M2 绑定了 P2，并运行 G0，但 P2 本地队列没有 G，M2 此时为自旋线程**（没有 G 但为运行状态的线程，不断寻找 G）**。</p>
<figure data-type="image" tabindex="11"><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/2FWNXSuHfX.png!large" alt="6" loading="lazy"></figure>
</li>
<li>
<p>M2 尝试从全局队列 (简称 “GQ”) 取一批 G 放到 P2 的本地队列（函数：<code>findrunnable()</code>）。M2 从全局队列取的 G 数量符合下面的公式：</p>
<pre><code class="language-go">n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))
</code></pre>
<p>从全局队列取出差不多平均给每个M-P的数量的G，，不要拿太多，给其他M-P留一些</p>
<figure data-type="image" tabindex="12"><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/0fn8DGqI8N.jpeg!large" alt="7" loading="lazy"></figure>
<p>假定我们场景中一共有 4 个 P（GOMAXPROCS 设置为 4，那么我们允许最多就能用 4 个 P 来供 M 使用）。所以 M2 只从能从全局队列取 1 个 G（即 G3）移动 P2 本地队列，然后完成从 G0 到 G3 的切换，运行 G3。</p>
</li>
<li>
<p>假设 G2 一直在 M1 上运行，经过 2 轮后，M2 已经把 G7、G4 从全局队列获取到了 P2 的本地队列并完成运行，全局队列和 P2 的本地队列都空了，如场景 8 图的左半部分。</p>
<p>全局队列已经没有 G，那 m 就要执行 work stealing (偷取)：<strong>从其他有 G 的 P 哪里偷取一半 G 过来，放到自己的 P 本地队列</strong>。P2 从 P1 的本地队列尾部取一半的 G，本例中一半则只有 1 个 G8，放到 P2 的本地队列并执行。</p>
<figure data-type="image" tabindex="13"><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/qn1NRMLqnp.png!large" alt="8" loading="lazy"></figure>
</li>
<li>
<p>G1 本地队列 G5、G6 已经被其他 M 偷走并运行完成，当前 M1 和 M2 分别在运行 G2 和 G8，M3 和 M4 没有 goroutine 可以运行，M3 和 M4 处于自旋状态，它们不断寻找 goroutine。</p>
<figure data-type="image" tabindex="14"><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/1DjlseEGTT.png!large" alt="9" loading="lazy"></figure>
<p>为什么要让 m3 和 m4 自旋，自旋本质是在运行，线程在运行却没有执行 G，就变成了浪费 CPU. 为什么不销毁现场，来节约 CPU 资源。因为创建和销毁 CPU 也会浪费时间，我们希望当有新 goroutine 创建时，立刻能有 M 运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费 CPU，所以系统中最多有 <code>GOMAXPROCS</code> 个自旋的线程 (当前例子中的 GOMAXPROCS=4，所以一共 4 个 P)，多余的没事做线程会让他们休眠。</p>
</li>
<li>
<p>假定当前除了 M3 和 M4 为自旋线程，还有 M5 和 M6 为空闲的线程 (没有得到 P 的绑定，注意我们这里最多就只能够存在 4 个 P，所以 P 的数量应该永远是 M&gt;=P, 大部分都是 M 在抢占需要运行的 P)，G8 创建了 G9，G8 进行了阻塞的系统调用，M2 和 P2 立即解绑，P2 会执行以下判断：</p>
<ul>
<li>如果 P2 本地队列有 G、全局队列有 G 或有空闲的 M，P2 都会立马唤醒 1 个 M 和它绑定</li>
<li>否则 P2 则会加入到空闲 P 列表，等待 M 来获取可用的 p。</li>
</ul>
<p>本场景中，P2 本地队列有 G9，可以和其他空闲的线程 M5 绑定。</p>
<figure data-type="image" tabindex="15"><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/k3HKE9U21M.png!large" alt="10" loading="lazy"></figure>
</li>
<li>
<p>G8 创建了 G9，假如 G8 进行了<strong>非阻塞系统调用</strong>。</p>
<figure data-type="image" tabindex="16"><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/zBvpl8ENSb.png!large" alt="11" loading="lazy"></figure>
<p>M2 和 P2 会解绑，但 M2 会记住 P2，然后 G8 和 M2 进入系统调用状态。当 G8 和 M2 退出系统调用时，会尝试获取 P2，如果无法获取，则获取空闲的 P，如果依然没有，G8 会被记为可运行状态，并加入到全局队列，M2 因为没有 P 的绑定而变成休眠状态 (长时间休眠等待 GC 回收销毁)。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go语法基础巩固（channel）]]></title>
        <id>http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-channel/</id>
        <link href="http://blog.zerokirin.online/post/go-yu-fa-ji-chu-gong-gu-channel/">
        </link>
        <updated>2021-03-20T21:37:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="channel分为有缓冲和无缓冲">channel分为有缓冲和无缓冲</h2>
<p>channel有两种定义方式</p>
<pre><code class="language-go">var c1 = make(chan int) //无缓冲
var c2 = make(chan int,n) //有缓冲
close(c2)
</code></pre>
<ul>
<li>对无缓冲的c1的操作是同步的
<ul>
<li>必须同时存在接收者和发送者才会执行，否则会阻塞</li>
</ul>
</li>
<li>对有缓冲的c2是存在异步操作的
<ul>
<li>缓冲区满了则无法继续写入，进入阻塞，未满之前不阻塞程序</li>
<li>缓冲区空了则无法读取，进入阻塞，没有空之前不阻塞</li>
</ul>
</li>
</ul>
<h2 id="close关闭一个channel">close关闭一个channel</h2>
<ul>
<li>不能对一个关闭了的，或者本来就未通过make()初始化的channel执行关闭操作，会panic</li>
<li>关闭channel在某种角度上讲只是不允许继续写入，对于已经存入缓冲的数据还是可以读取的</li>
</ul>
<pre><code class="language-go">func main() {
	c1 := make(chan int, 5)
	for i := 0; i &lt; 5; i++ {
		c1 &lt;- i
	}
	close(c1)
	for i := 0; i &lt; 6; i++ {
		m, ok := &lt;-c1
		fmt.Println(m, ok)
	}
}
//结果：
//0 true
//1 true
//2 true
//3 true
//4 true
//0 false， 只有到这一步才因为没有数据而返回了默认的零值
</code></pre>
<p>总结一下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作\对象</th>
<th style="text-align:center">nil channel</th>
<th style="text-align:center">closed channel</th>
<th style="text-align:center">not nil, not closed channel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">close</td>
<td style="text-align:center">panic</td>
<td style="text-align:center">panic</td>
<td style="text-align:center">正常关闭</td>
</tr>
<tr>
<td style="text-align:center">读 &lt;- ch</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">读到对应类型的零值</td>
<td style="text-align:center">阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td>
</tr>
<tr>
<td style="text-align:center">写 ch &lt;-</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">panic</td>
<td style="text-align:center">阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td>
</tr>
</tbody>
</table>
<h2 id="channel的实现原理">channel的实现原理</h2>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000019839546">深度解密Go语言之channel - SegmentFault 思否</a></p>
</blockquote>
<p>以下内容均为个人转述总结，仅作笔记使用，参考出处如上</p>
<h3 id="channel结构">channel结构</h3>
<pre><code class="language-go">type hchan struct {
    // chan 里元素数量
    qcount   uint
    // chan 底层循环数组的长度
    dataqsiz uint
    // 指向底层循环数组的指针
    // 只针对有缓冲的 channel
    buf      unsafe.Pointer
    // chan 中元素大小
    elemsize uint16
    // chan 是否被关闭的标志
    closed   uint32
    // chan 中元素类型
    elemtype *_type // element type
    // 已发送元素在循环数组中的索引
    sendx    uint   // send index
    // 已接收元素在循环数组中的索引
    recvx    uint   // receive index
    // 等待接收的 goroutine 队列
    recvq    waitq  // list of recv waiters
    // 等待发送的 goroutine 队列
    sendq    waitq  // list of send waiters

    // 保护 hchan 中所有字段
    lock mutex
}

type waitq struct {
    first *sudog //对goroutine的封装
    last  *sudog //对goroutine的封装
}
</code></pre>
<p>和map一样，底层实际上是一个hchan结构体，调用了makechan()来创建channel，根据创建的时候是否有缓冲决定了buf指针是否有意义，sendx和recvx均为缓冲数组服务</p>
<pre><code class="language-go">func goroutine(a &lt;-chan int) {
    val := &lt;- a
    fmt.Println(&quot;received data: &quot;, val)
    return
}
func main(){
	var ch = make(chan int, 10)
    go goroutine(ch) //隐式转换为只读channel
    go goroutine(ch) //隐式转换为只读channel
    time.Sleep(time.Second)
}

</code></pre>
<p>上面go出去了两个读取ch的goroutine，所以此时接收队列应该是两个，结构如下（图源参考文章）</p>
<figure data-type="image" tabindex="1"><img src="https://image-static.segmentfault.com/311/648/3116484337-5d35b2f0069a8_article732" alt="recvq" loading="lazy"></figure>
<p>可以看到G1，G2其实就是个sudog结构的双向循环列表，recvq分别通过first和last指向了头尾</p>
<p>发送队列也是个wait结构，因此和接收队列几乎一致</p>
<h3 id="写入">写入</h3>
<ol>
<li>
<p>先判断是否有接收队列，如果有则直接拷贝到接收队列中，不复制到buf</p>
</li>
<li>
<p>对于有缓冲的channel，若还有空间，则将数据拷贝到buf中，同时更改相应的index</p>
</li>
<li>
<p>若没有空间或非缓冲则阻塞，然后创建一个sudog（sudog实际上是goroutine的封装，因此新的sudog实际就是包括了执行函数的这个goroutine</p>
<p>将新的sudog加入发送队列，当前goroutine被系统挂起，等待接受进程唤醒</p>
</li>
</ol>
<h3 id="读取">读取</h3>
<ol>
<li>
<p>先判断是否有缓冲，若无缓冲则直接从发送者的栈拷贝到接收者的栈，发送者是通过遍历sendq找到的</p>
</li>
<li>
<p>若有缓冲则从buf所指的空间拷贝数据（只要不为空就会一直有数据写入，不会有主动寻找sendq的时机）</p>
</li>
<li>
<p>若没有数据则将自己挂起到接收队列等待被发送进程找到，也是创建一个sudog</p>
</li>
</ol>
]]></content>
    </entry>
</feed>